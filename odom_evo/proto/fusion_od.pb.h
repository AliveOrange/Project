// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fusion_od.proto

#ifndef PROTOBUF_INCLUDED_fusion_5fod_2eproto
#define PROTOBUF_INCLUDED_fusion_5fod_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fusion_5fod_2eproto 

namespace protobuf_fusion_5fod_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fusion_5fod_2eproto
namespace calmpilot {
namespace fusion {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class ObjFrame;
class ObjFrameDefaultTypeInternal;
extern ObjFrameDefaultTypeInternal _ObjFrame_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class PredictTrajectory;
class PredictTrajectoryDefaultTypeInternal;
extern PredictTrajectoryDefaultTypeInternal _PredictTrajectory_default_instance_;
class PredictTrajectory_Intention;
class PredictTrajectory_IntentionDefaultTypeInternal;
extern PredictTrajectory_IntentionDefaultTypeInternal _PredictTrajectory_Intention_default_instance_;
class PredictTrajectory_TrajPoint;
class PredictTrajectory_TrajPointDefaultTypeInternal;
extern PredictTrajectory_TrajPointDefaultTypeInternal _PredictTrajectory_TrajPoint_default_instance_;
class Vector3d;
class Vector3dDefaultTypeInternal;
extern Vector3dDefaultTypeInternal _Vector3d_default_instance_;
}  // namespace fusion
}  // namespace calmpilot
namespace google {
namespace protobuf {
template<> ::calmpilot::fusion::Header* Arena::CreateMaybeMessage<::calmpilot::fusion::Header>(Arena*);
template<> ::calmpilot::fusion::ObjFrame* Arena::CreateMaybeMessage<::calmpilot::fusion::ObjFrame>(Arena*);
template<> ::calmpilot::fusion::Object* Arena::CreateMaybeMessage<::calmpilot::fusion::Object>(Arena*);
template<> ::calmpilot::fusion::PredictTrajectory* Arena::CreateMaybeMessage<::calmpilot::fusion::PredictTrajectory>(Arena*);
template<> ::calmpilot::fusion::PredictTrajectory_Intention* Arena::CreateMaybeMessage<::calmpilot::fusion::PredictTrajectory_Intention>(Arena*);
template<> ::calmpilot::fusion::PredictTrajectory_TrajPoint* Arena::CreateMaybeMessage<::calmpilot::fusion::PredictTrajectory_TrajPoint>(Arena*);
template<> ::calmpilot::fusion::Vector3d* Arena::CreateMaybeMessage<::calmpilot::fusion::Vector3d>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace calmpilot {
namespace fusion {

enum Object_ClassType {
  Object_ClassType_UNKNOWN = 0,
  Object_ClassType_CAR = 1,
  Object_ClassType_BIG_VEHICLE = 2,
  Object_ClassType_PEDESTRIAN = 3,
  Object_ClassType_BICYCLE = 4,
  Object_ClassType_CONE = 5,
  Object_ClassType_ANIMAL = 6,
  Object_ClassType_Object_ClassType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Object_ClassType_Object_ClassType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Object_ClassType_IsValid(int value);
const Object_ClassType Object_ClassType_ClassType_MIN = Object_ClassType_UNKNOWN;
const Object_ClassType Object_ClassType_ClassType_MAX = Object_ClassType_ANIMAL;
const int Object_ClassType_ClassType_ARRAYSIZE = Object_ClassType_ClassType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_ClassType_descriptor();
inline const ::std::string& Object_ClassType_Name(Object_ClassType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_ClassType_descriptor(), value);
}
inline bool Object_ClassType_Parse(
    const ::std::string& name, Object_ClassType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_ClassType>(
    Object_ClassType_descriptor(), name, value);
}
enum Object_MotionStatus {
  Object_MotionStatus_UNKNOWN_MOTION = 0,
  Object_MotionStatus_MOVING = 1,
  Object_MotionStatus_STATIONARY = 2,
  Object_MotionStatus_ONCOMING = 3,
  Object_MotionStatus_STOPPED = 4,
  Object_MotionStatus_Object_MotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Object_MotionStatus_Object_MotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Object_MotionStatus_IsValid(int value);
const Object_MotionStatus Object_MotionStatus_MotionStatus_MIN = Object_MotionStatus_UNKNOWN_MOTION;
const Object_MotionStatus Object_MotionStatus_MotionStatus_MAX = Object_MotionStatus_STOPPED;
const int Object_MotionStatus_MotionStatus_ARRAYSIZE = Object_MotionStatus_MotionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_MotionStatus_descriptor();
inline const ::std::string& Object_MotionStatus_Name(Object_MotionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_MotionStatus_descriptor(), value);
}
inline bool Object_MotionStatus_Parse(
    const ::std::string& name, Object_MotionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_MotionStatus>(
    Object_MotionStatus_descriptor(), name, value);
}
enum Object_MeasuredSource {
  Object_MeasuredSource_UNKNOWN_SOURCE = 0,
  Object_MeasuredSource_FUSION = 1,
  Object_MeasuredSource_LIDAR_CAMERA = 2,
  Object_MeasuredSource_LIDAR_RADAR = 3,
  Object_MeasuredSource_CAMERA_RADAR = 4,
  Object_MeasuredSource_LIDAR = 5,
  Object_MeasuredSource_CAMERA = 6,
  Object_MeasuredSource_RADAR = 7,
  Object_MeasuredSource_Object_MeasuredSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Object_MeasuredSource_Object_MeasuredSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Object_MeasuredSource_IsValid(int value);
const Object_MeasuredSource Object_MeasuredSource_MeasuredSource_MIN = Object_MeasuredSource_UNKNOWN_SOURCE;
const Object_MeasuredSource Object_MeasuredSource_MeasuredSource_MAX = Object_MeasuredSource_RADAR;
const int Object_MeasuredSource_MeasuredSource_ARRAYSIZE = Object_MeasuredSource_MeasuredSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_MeasuredSource_descriptor();
inline const ::std::string& Object_MeasuredSource_Name(Object_MeasuredSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_MeasuredSource_descriptor(), value);
}
inline bool Object_MeasuredSource_Parse(
    const ::std::string& name, Object_MeasuredSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_MeasuredSource>(
    Object_MeasuredSource_descriptor(), name, value);
}
enum Object_MeasState {
  Object_MeasState_DELETED = 0,
  Object_MeasState_NEW = 1,
  Object_MeasState_UPDATE = 2,
  Object_MeasState_PREDICT = 3,
  Object_MeasState_Object_MeasState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Object_MeasState_Object_MeasState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Object_MeasState_IsValid(int value);
const Object_MeasState Object_MeasState_MeasState_MIN = Object_MeasState_DELETED;
const Object_MeasState Object_MeasState_MeasState_MAX = Object_MeasState_PREDICT;
const int Object_MeasState_MeasState_ARRAYSIZE = Object_MeasState_MeasState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Object_MeasState_descriptor();
inline const ::std::string& Object_MeasState_Name(Object_MeasState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Object_MeasState_descriptor(), value);
}
inline bool Object_MeasState_Parse(
    const ::std::string& name, Object_MeasState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Object_MeasState>(
    Object_MeasState_descriptor(), name, value);
}
enum LatIntention {
  LANE_KEEPING = 0,
  LEFT_LANE_CHANGE = 1,
  RIGHT_LANE_CHANGE = 2,
  LatIntention_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LatIntention_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LatIntention_IsValid(int value);
const LatIntention LatIntention_MIN = LANE_KEEPING;
const LatIntention LatIntention_MAX = RIGHT_LANE_CHANGE;
const int LatIntention_ARRAYSIZE = LatIntention_MAX + 1;

const ::google::protobuf::EnumDescriptor* LatIntention_descriptor();
inline const ::std::string& LatIntention_Name(LatIntention value) {
  return ::google::protobuf::internal::NameOfEnum(
    LatIntention_descriptor(), value);
}
inline bool LatIntention_Parse(
    const ::std::string& name, LatIntention* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LatIntention>(
    LatIntention_descriptor(), name, value);
}
enum LongIntention {
  NORMAL_DRIVING = 0,
  BRAKING = 1,
  ACCELERATING = 2,
  LongIntention_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LongIntention_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LongIntention_IsValid(int value);
const LongIntention LongIntention_MIN = NORMAL_DRIVING;
const LongIntention LongIntention_MAX = ACCELERATING;
const int LongIntention_ARRAYSIZE = LongIntention_MAX + 1;

const ::google::protobuf::EnumDescriptor* LongIntention_descriptor();
inline const ::std::string& LongIntention_Name(LongIntention value) {
  return ::google::protobuf::internal::NameOfEnum(
    LongIntention_descriptor(), value);
}
inline bool LongIntention_Parse(
    const ::std::string& name, LongIntention* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LongIntention>(
    LongIntention_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // uint32 rolling_counter = 2;
  void clear_rolling_counter();
  static const int kRollingCounterFieldNumber = 2;
  ::google::protobuf::uint32 rolling_counter() const;
  void set_rolling_counter(::google::protobuf::uint32 value);

  // uint32 obj_num = 3;
  void clear_obj_num();
  static const int kObjNumFieldNumber = 3;
  ::google::protobuf::uint32 obj_num() const;
  void set_obj_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 rolling_counter_;
  ::google::protobuf::uint32 obj_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vector3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.Vector3d) */ {
 public:
  Vector3d();
  virtual ~Vector3d();

  Vector3d(const Vector3d& from);

  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector3d(Vector3d&& from) noexcept
    : Vector3d() {
    *this = ::std::move(from);
  }

  inline Vector3d& operator=(Vector3d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3d* internal_default_instance() {
    return reinterpret_cast<const Vector3d*>(
               &_Vector3d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Vector3d* other);
  friend void swap(Vector3d& a, Vector3d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector3d* New() const final {
    return CreateMaybeMessage<Vector3d>(NULL);
  }

  Vector3d* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector3d>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector3d& from);
  void MergeFrom(const Vector3d& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.Vector3d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictTrajectory_Intention : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.PredictTrajectory.Intention) */ {
 public:
  PredictTrajectory_Intention();
  virtual ~PredictTrajectory_Intention();

  PredictTrajectory_Intention(const PredictTrajectory_Intention& from);

  inline PredictTrajectory_Intention& operator=(const PredictTrajectory_Intention& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictTrajectory_Intention(PredictTrajectory_Intention&& from) noexcept
    : PredictTrajectory_Intention() {
    *this = ::std::move(from);
  }

  inline PredictTrajectory_Intention& operator=(PredictTrajectory_Intention&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictTrajectory_Intention& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictTrajectory_Intention* internal_default_instance() {
    return reinterpret_cast<const PredictTrajectory_Intention*>(
               &_PredictTrajectory_Intention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PredictTrajectory_Intention* other);
  friend void swap(PredictTrajectory_Intention& a, PredictTrajectory_Intention& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictTrajectory_Intention* New() const final {
    return CreateMaybeMessage<PredictTrajectory_Intention>(NULL);
  }

  PredictTrajectory_Intention* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PredictTrajectory_Intention>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PredictTrajectory_Intention& from);
  void MergeFrom(const PredictTrajectory_Intention& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictTrajectory_Intention* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmpilot.fusion.LatIntention lat_intention = 1;
  void clear_lat_intention();
  static const int kLatIntentionFieldNumber = 1;
  ::calmpilot::fusion::LatIntention lat_intention() const;
  void set_lat_intention(::calmpilot::fusion::LatIntention value);

  // .calmpilot.fusion.LongIntention long_intention = 2;
  void clear_long_intention();
  static const int kLongIntentionFieldNumber = 2;
  ::calmpilot::fusion::LongIntention long_intention() const;
  void set_long_intention(::calmpilot::fusion::LongIntention value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.PredictTrajectory.Intention)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int lat_intention_;
  int long_intention_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictTrajectory_TrajPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.PredictTrajectory.TrajPoint) */ {
 public:
  PredictTrajectory_TrajPoint();
  virtual ~PredictTrajectory_TrajPoint();

  PredictTrajectory_TrajPoint(const PredictTrajectory_TrajPoint& from);

  inline PredictTrajectory_TrajPoint& operator=(const PredictTrajectory_TrajPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictTrajectory_TrajPoint(PredictTrajectory_TrajPoint&& from) noexcept
    : PredictTrajectory_TrajPoint() {
    *this = ::std::move(from);
  }

  inline PredictTrajectory_TrajPoint& operator=(PredictTrajectory_TrajPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictTrajectory_TrajPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictTrajectory_TrajPoint* internal_default_instance() {
    return reinterpret_cast<const PredictTrajectory_TrajPoint*>(
               &_PredictTrajectory_TrajPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PredictTrajectory_TrajPoint* other);
  friend void swap(PredictTrajectory_TrajPoint& a, PredictTrajectory_TrajPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictTrajectory_TrajPoint* New() const final {
    return CreateMaybeMessage<PredictTrajectory_TrajPoint>(NULL);
  }

  PredictTrajectory_TrajPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PredictTrajectory_TrajPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PredictTrajectory_TrajPoint& from);
  void MergeFrom(const PredictTrajectory_TrajPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictTrajectory_TrajPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double dist_long = 1;
  void clear_dist_long();
  static const int kDistLongFieldNumber = 1;
  double dist_long() const;
  void set_dist_long(double value);

  // double dist_lat = 2;
  void clear_dist_lat();
  static const int kDistLatFieldNumber = 2;
  double dist_lat() const;
  void set_dist_lat(double value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.PredictTrajectory.TrajPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double dist_long_;
  double dist_lat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictTrajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.PredictTrajectory) */ {
 public:
  PredictTrajectory();
  virtual ~PredictTrajectory();

  PredictTrajectory(const PredictTrajectory& from);

  inline PredictTrajectory& operator=(const PredictTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictTrajectory(PredictTrajectory&& from) noexcept
    : PredictTrajectory() {
    *this = ::std::move(from);
  }

  inline PredictTrajectory& operator=(PredictTrajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictTrajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictTrajectory* internal_default_instance() {
    return reinterpret_cast<const PredictTrajectory*>(
               &_PredictTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PredictTrajectory* other);
  friend void swap(PredictTrajectory& a, PredictTrajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictTrajectory* New() const final {
    return CreateMaybeMessage<PredictTrajectory>(NULL);
  }

  PredictTrajectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PredictTrajectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PredictTrajectory& from);
  void MergeFrom(const PredictTrajectory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictTrajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PredictTrajectory_Intention Intention;
  typedef PredictTrajectory_TrajPoint TrajPoint;

  // accessors -------------------------------------------------------

  // repeated .calmpilot.fusion.PredictTrajectory.TrajPoint traj_points = 2;
  int traj_points_size() const;
  void clear_traj_points();
  static const int kTrajPointsFieldNumber = 2;
  ::calmpilot::fusion::PredictTrajectory_TrajPoint* mutable_traj_points(int index);
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory_TrajPoint >*
      mutable_traj_points();
  const ::calmpilot::fusion::PredictTrajectory_TrajPoint& traj_points(int index) const;
  ::calmpilot::fusion::PredictTrajectory_TrajPoint* add_traj_points();
  const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory_TrajPoint >&
      traj_points() const;

  // .calmpilot.fusion.PredictTrajectory.Intention intention = 1;
  bool has_intention() const;
  void clear_intention();
  static const int kIntentionFieldNumber = 1;
  private:
  const ::calmpilot::fusion::PredictTrajectory_Intention& _internal_intention() const;
  public:
  const ::calmpilot::fusion::PredictTrajectory_Intention& intention() const;
  ::calmpilot::fusion::PredictTrajectory_Intention* release_intention();
  ::calmpilot::fusion::PredictTrajectory_Intention* mutable_intention();
  void set_allocated_intention(::calmpilot::fusion::PredictTrajectory_Intention* intention);

  // double prob = 3;
  void clear_prob();
  static const int kProbFieldNumber = 3;
  double prob() const;
  void set_prob(double value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.PredictTrajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory_TrajPoint > traj_points_;
  ::calmpilot::fusion::PredictTrajectory_Intention* intention_;
  double prob_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(NULL);
  }

  Object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Object_ClassType ClassType;
  static const ClassType UNKNOWN =
    Object_ClassType_UNKNOWN;
  static const ClassType CAR =
    Object_ClassType_CAR;
  static const ClassType BIG_VEHICLE =
    Object_ClassType_BIG_VEHICLE;
  static const ClassType PEDESTRIAN =
    Object_ClassType_PEDESTRIAN;
  static const ClassType BICYCLE =
    Object_ClassType_BICYCLE;
  static const ClassType CONE =
    Object_ClassType_CONE;
  static const ClassType ANIMAL =
    Object_ClassType_ANIMAL;
  static inline bool ClassType_IsValid(int value) {
    return Object_ClassType_IsValid(value);
  }
  static const ClassType ClassType_MIN =
    Object_ClassType_ClassType_MIN;
  static const ClassType ClassType_MAX =
    Object_ClassType_ClassType_MAX;
  static const int ClassType_ARRAYSIZE =
    Object_ClassType_ClassType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ClassType_descriptor() {
    return Object_ClassType_descriptor();
  }
  static inline const ::std::string& ClassType_Name(ClassType value) {
    return Object_ClassType_Name(value);
  }
  static inline bool ClassType_Parse(const ::std::string& name,
      ClassType* value) {
    return Object_ClassType_Parse(name, value);
  }

  typedef Object_MotionStatus MotionStatus;
  static const MotionStatus UNKNOWN_MOTION =
    Object_MotionStatus_UNKNOWN_MOTION;
  static const MotionStatus MOVING =
    Object_MotionStatus_MOVING;
  static const MotionStatus STATIONARY =
    Object_MotionStatus_STATIONARY;
  static const MotionStatus ONCOMING =
    Object_MotionStatus_ONCOMING;
  static const MotionStatus STOPPED =
    Object_MotionStatus_STOPPED;
  static inline bool MotionStatus_IsValid(int value) {
    return Object_MotionStatus_IsValid(value);
  }
  static const MotionStatus MotionStatus_MIN =
    Object_MotionStatus_MotionStatus_MIN;
  static const MotionStatus MotionStatus_MAX =
    Object_MotionStatus_MotionStatus_MAX;
  static const int MotionStatus_ARRAYSIZE =
    Object_MotionStatus_MotionStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotionStatus_descriptor() {
    return Object_MotionStatus_descriptor();
  }
  static inline const ::std::string& MotionStatus_Name(MotionStatus value) {
    return Object_MotionStatus_Name(value);
  }
  static inline bool MotionStatus_Parse(const ::std::string& name,
      MotionStatus* value) {
    return Object_MotionStatus_Parse(name, value);
  }

  typedef Object_MeasuredSource MeasuredSource;
  static const MeasuredSource UNKNOWN_SOURCE =
    Object_MeasuredSource_UNKNOWN_SOURCE;
  static const MeasuredSource FUSION =
    Object_MeasuredSource_FUSION;
  static const MeasuredSource LIDAR_CAMERA =
    Object_MeasuredSource_LIDAR_CAMERA;
  static const MeasuredSource LIDAR_RADAR =
    Object_MeasuredSource_LIDAR_RADAR;
  static const MeasuredSource CAMERA_RADAR =
    Object_MeasuredSource_CAMERA_RADAR;
  static const MeasuredSource LIDAR =
    Object_MeasuredSource_LIDAR;
  static const MeasuredSource CAMERA =
    Object_MeasuredSource_CAMERA;
  static const MeasuredSource RADAR =
    Object_MeasuredSource_RADAR;
  static inline bool MeasuredSource_IsValid(int value) {
    return Object_MeasuredSource_IsValid(value);
  }
  static const MeasuredSource MeasuredSource_MIN =
    Object_MeasuredSource_MeasuredSource_MIN;
  static const MeasuredSource MeasuredSource_MAX =
    Object_MeasuredSource_MeasuredSource_MAX;
  static const int MeasuredSource_ARRAYSIZE =
    Object_MeasuredSource_MeasuredSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MeasuredSource_descriptor() {
    return Object_MeasuredSource_descriptor();
  }
  static inline const ::std::string& MeasuredSource_Name(MeasuredSource value) {
    return Object_MeasuredSource_Name(value);
  }
  static inline bool MeasuredSource_Parse(const ::std::string& name,
      MeasuredSource* value) {
    return Object_MeasuredSource_Parse(name, value);
  }

  typedef Object_MeasState MeasState;
  static const MeasState DELETED =
    Object_MeasState_DELETED;
  static const MeasState NEW =
    Object_MeasState_NEW;
  static const MeasState UPDATE =
    Object_MeasState_UPDATE;
  static const MeasState PREDICT =
    Object_MeasState_PREDICT;
  static inline bool MeasState_IsValid(int value) {
    return Object_MeasState_IsValid(value);
  }
  static const MeasState MeasState_MIN =
    Object_MeasState_MeasState_MIN;
  static const MeasState MeasState_MAX =
    Object_MeasState_MeasState_MAX;
  static const int MeasState_ARRAYSIZE =
    Object_MeasState_MeasState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MeasState_descriptor() {
    return Object_MeasState_descriptor();
  }
  static inline const ::std::string& MeasState_Name(MeasState value) {
    return Object_MeasState_Name(value);
  }
  static inline bool MeasState_Parse(const ::std::string& name,
      MeasState* value) {
    return Object_MeasState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .calmpilot.fusion.Object.MotionStatus motion_status = 22;
  int motion_status_size() const;
  void clear_motion_status();
  static const int kMotionStatusFieldNumber = 22;
  ::calmpilot::fusion::Object_MotionStatus motion_status(int index) const;
  void set_motion_status(int index, ::calmpilot::fusion::Object_MotionStatus value);
  void add_motion_status(::calmpilot::fusion::Object_MotionStatus value);
  const ::google::protobuf::RepeatedField<int>& motion_status() const;
  ::google::protobuf::RepeatedField<int>* mutable_motion_status();

  // repeated double motion_status_confidence = 23;
  int motion_status_confidence_size() const;
  void clear_motion_status_confidence();
  static const int kMotionStatusConfidenceFieldNumber = 23;
  double motion_status_confidence(int index) const;
  void set_motion_status_confidence(int index, double value);
  void add_motion_status_confidence(double value);
  const ::google::protobuf::RepeatedField< double >&
      motion_status_confidence() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_motion_status_confidence();

  // repeated .calmpilot.fusion.PredictTrajectory trajectories = 26;
  int trajectories_size() const;
  void clear_trajectories();
  static const int kTrajectoriesFieldNumber = 26;
  ::calmpilot::fusion::PredictTrajectory* mutable_trajectories(int index);
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory >*
      mutable_trajectories();
  const ::calmpilot::fusion::PredictTrajectory& trajectories(int index) const;
  ::calmpilot::fusion::PredictTrajectory* add_trajectories();
  const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory >&
      trajectories() const;

  // .calmpilot.fusion.Vector3d center = 6;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 6;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_center() const;
  public:
  const ::calmpilot::fusion::Vector3d& center() const;
  ::calmpilot::fusion::Vector3d* release_center();
  ::calmpilot::fusion::Vector3d* mutable_center();
  void set_allocated_center(::calmpilot::fusion::Vector3d* center);

  // .calmpilot.fusion.Vector3d center_rms = 7;
  bool has_center_rms() const;
  void clear_center_rms();
  static const int kCenterRmsFieldNumber = 7;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_center_rms() const;
  public:
  const ::calmpilot::fusion::Vector3d& center_rms() const;
  ::calmpilot::fusion::Vector3d* release_center_rms();
  ::calmpilot::fusion::Vector3d* mutable_center_rms();
  void set_allocated_center_rms(::calmpilot::fusion::Vector3d* center_rms);

  // .calmpilot.fusion.Vector3d vrel = 8;
  bool has_vrel() const;
  void clear_vrel();
  static const int kVrelFieldNumber = 8;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_vrel() const;
  public:
  const ::calmpilot::fusion::Vector3d& vrel() const;
  ::calmpilot::fusion::Vector3d* release_vrel();
  ::calmpilot::fusion::Vector3d* mutable_vrel();
  void set_allocated_vrel(::calmpilot::fusion::Vector3d* vrel);

  // .calmpilot.fusion.Vector3d vrel_rms = 9;
  bool has_vrel_rms() const;
  void clear_vrel_rms();
  static const int kVrelRmsFieldNumber = 9;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_vrel_rms() const;
  public:
  const ::calmpilot::fusion::Vector3d& vrel_rms() const;
  ::calmpilot::fusion::Vector3d* release_vrel_rms();
  ::calmpilot::fusion::Vector3d* mutable_vrel_rms();
  void set_allocated_vrel_rms(::calmpilot::fusion::Vector3d* vrel_rms);

  // .calmpilot.fusion.Vector3d arel = 10;
  bool has_arel() const;
  void clear_arel();
  static const int kArelFieldNumber = 10;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_arel() const;
  public:
  const ::calmpilot::fusion::Vector3d& arel() const;
  ::calmpilot::fusion::Vector3d* release_arel();
  ::calmpilot::fusion::Vector3d* mutable_arel();
  void set_allocated_arel(::calmpilot::fusion::Vector3d* arel);

  // .calmpilot.fusion.Vector3d arel_rms = 11;
  bool has_arel_rms() const;
  void clear_arel_rms();
  static const int kArelRmsFieldNumber = 11;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_arel_rms() const;
  public:
  const ::calmpilot::fusion::Vector3d& arel_rms() const;
  ::calmpilot::fusion::Vector3d* release_arel_rms();
  ::calmpilot::fusion::Vector3d* mutable_arel_rms();
  void set_allocated_arel_rms(::calmpilot::fusion::Vector3d* arel_rms);

  // .calmpilot.fusion.Vector3d abs_vel = 12;
  bool has_abs_vel() const;
  void clear_abs_vel();
  static const int kAbsVelFieldNumber = 12;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_abs_vel() const;
  public:
  const ::calmpilot::fusion::Vector3d& abs_vel() const;
  ::calmpilot::fusion::Vector3d* release_abs_vel();
  ::calmpilot::fusion::Vector3d* mutable_abs_vel();
  void set_allocated_abs_vel(::calmpilot::fusion::Vector3d* abs_vel);

  // .calmpilot.fusion.Vector3d abs_vel_rms = 13;
  bool has_abs_vel_rms() const;
  void clear_abs_vel_rms();
  static const int kAbsVelRmsFieldNumber = 13;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_abs_vel_rms() const;
  public:
  const ::calmpilot::fusion::Vector3d& abs_vel_rms() const;
  ::calmpilot::fusion::Vector3d* release_abs_vel_rms();
  ::calmpilot::fusion::Vector3d* mutable_abs_vel_rms();
  void set_allocated_abs_vel_rms(::calmpilot::fusion::Vector3d* abs_vel_rms);

  // .calmpilot.fusion.Vector3d size = 14;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 14;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_size() const;
  public:
  const ::calmpilot::fusion::Vector3d& size() const;
  ::calmpilot::fusion::Vector3d* release_size();
  ::calmpilot::fusion::Vector3d* mutable_size();
  void set_allocated_size(::calmpilot::fusion::Vector3d* size);

  // .calmpilot.fusion.Vector3d size_rms = 15;
  bool has_size_rms() const;
  void clear_size_rms();
  static const int kSizeRmsFieldNumber = 15;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_size_rms() const;
  public:
  const ::calmpilot::fusion::Vector3d& size_rms() const;
  ::calmpilot::fusion::Vector3d* release_size_rms();
  ::calmpilot::fusion::Vector3d* mutable_size_rms();
  void set_allocated_size_rms(::calmpilot::fusion::Vector3d* size_rms);

  // .calmpilot.fusion.Vector3d corner_left_front = 16;
  bool has_corner_left_front() const;
  void clear_corner_left_front();
  static const int kCornerLeftFrontFieldNumber = 16;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_corner_left_front() const;
  public:
  const ::calmpilot::fusion::Vector3d& corner_left_front() const;
  ::calmpilot::fusion::Vector3d* release_corner_left_front();
  ::calmpilot::fusion::Vector3d* mutable_corner_left_front();
  void set_allocated_corner_left_front(::calmpilot::fusion::Vector3d* corner_left_front);

  // .calmpilot.fusion.Vector3d corner_right_front = 17;
  bool has_corner_right_front() const;
  void clear_corner_right_front();
  static const int kCornerRightFrontFieldNumber = 17;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_corner_right_front() const;
  public:
  const ::calmpilot::fusion::Vector3d& corner_right_front() const;
  ::calmpilot::fusion::Vector3d* release_corner_right_front();
  ::calmpilot::fusion::Vector3d* mutable_corner_right_front();
  void set_allocated_corner_right_front(::calmpilot::fusion::Vector3d* corner_right_front);

  // .calmpilot.fusion.Vector3d corner_left_rear = 18;
  bool has_corner_left_rear() const;
  void clear_corner_left_rear();
  static const int kCornerLeftRearFieldNumber = 18;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_corner_left_rear() const;
  public:
  const ::calmpilot::fusion::Vector3d& corner_left_rear() const;
  ::calmpilot::fusion::Vector3d* release_corner_left_rear();
  ::calmpilot::fusion::Vector3d* mutable_corner_left_rear();
  void set_allocated_corner_left_rear(::calmpilot::fusion::Vector3d* corner_left_rear);

  // .calmpilot.fusion.Vector3d corner_right_rear = 19;
  bool has_corner_right_rear() const;
  void clear_corner_right_rear();
  static const int kCornerRightRearFieldNumber = 19;
  private:
  const ::calmpilot::fusion::Vector3d& _internal_corner_right_rear() const;
  public:
  const ::calmpilot::fusion::Vector3d& corner_right_rear() const;
  ::calmpilot::fusion::Vector3d* release_corner_right_rear();
  ::calmpilot::fusion::Vector3d* mutable_corner_right_rear();
  void set_allocated_corner_right_rear(::calmpilot::fusion::Vector3d* corner_right_rear);

  // uint64 life_time = 2;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 2;
  ::google::protobuf::uint64 life_time() const;
  void set_life_time(::google::protobuf::uint64 value);

  // uint32 obj_id = 1;
  void clear_obj_id();
  static const int kObjIdFieldNumber = 1;
  ::google::protobuf::uint32 obj_id() const;
  void set_obj_id(::google::protobuf::uint32 value);

  // .calmpilot.fusion.Object.ClassType class_type = 4;
  void clear_class_type();
  static const int kClassTypeFieldNumber = 4;
  ::calmpilot::fusion::Object_ClassType class_type() const;
  void set_class_type(::calmpilot::fusion::Object_ClassType value);

  // double confidence = 3;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  double confidence() const;
  void set_confidence(double value);

  // double class_type_confidence = 5;
  void clear_class_type_confidence();
  static const int kClassTypeConfidenceFieldNumber = 5;
  double class_type_confidence() const;
  void set_class_type_confidence(double value);

  // double orientation_angle = 20;
  void clear_orientation_angle();
  static const int kOrientationAngleFieldNumber = 20;
  double orientation_angle() const;
  void set_orientation_angle(double value);

  // double orientation_rms = 21;
  void clear_orientation_rms();
  static const int kOrientationRmsFieldNumber = 21;
  double orientation_rms() const;
  void set_orientation_rms(double value);

  // .calmpilot.fusion.Object.MeasuredSource measured_source = 24;
  void clear_measured_source();
  static const int kMeasuredSourceFieldNumber = 24;
  ::calmpilot::fusion::Object_MeasuredSource measured_source() const;
  void set_measured_source(::calmpilot::fusion::Object_MeasuredSource value);

  // .calmpilot.fusion.Object.MeasState meas_state = 25;
  void clear_meas_state();
  static const int kMeasStateFieldNumber = 25;
  ::calmpilot::fusion::Object_MeasState meas_state() const;
  void set_meas_state(::calmpilot::fusion::Object_MeasState value);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> motion_status_;
  mutable int _motion_status_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > motion_status_confidence_;
  mutable int _motion_status_confidence_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory > trajectories_;
  ::calmpilot::fusion::Vector3d* center_;
  ::calmpilot::fusion::Vector3d* center_rms_;
  ::calmpilot::fusion::Vector3d* vrel_;
  ::calmpilot::fusion::Vector3d* vrel_rms_;
  ::calmpilot::fusion::Vector3d* arel_;
  ::calmpilot::fusion::Vector3d* arel_rms_;
  ::calmpilot::fusion::Vector3d* abs_vel_;
  ::calmpilot::fusion::Vector3d* abs_vel_rms_;
  ::calmpilot::fusion::Vector3d* size_;
  ::calmpilot::fusion::Vector3d* size_rms_;
  ::calmpilot::fusion::Vector3d* corner_left_front_;
  ::calmpilot::fusion::Vector3d* corner_right_front_;
  ::calmpilot::fusion::Vector3d* corner_left_rear_;
  ::calmpilot::fusion::Vector3d* corner_right_rear_;
  ::google::protobuf::uint64 life_time_;
  ::google::protobuf::uint32 obj_id_;
  int class_type_;
  double confidence_;
  double class_type_confidence_;
  double orientation_angle_;
  double orientation_rms_;
  int measured_source_;
  int meas_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmpilot.fusion.ObjFrame) */ {
 public:
  ObjFrame();
  virtual ~ObjFrame();

  ObjFrame(const ObjFrame& from);

  inline ObjFrame& operator=(const ObjFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjFrame(ObjFrame&& from) noexcept
    : ObjFrame() {
    *this = ::std::move(from);
  }

  inline ObjFrame& operator=(ObjFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjFrame* internal_default_instance() {
    return reinterpret_cast<const ObjFrame*>(
               &_ObjFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ObjFrame* other);
  friend void swap(ObjFrame& a, ObjFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjFrame* New() const final {
    return CreateMaybeMessage<ObjFrame>(NULL);
  }

  ObjFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjFrame& from);
  void MergeFrom(const ObjFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmpilot.fusion.Object objects = 2;
  int objects_size() const;
  void clear_objects();
  static const int kObjectsFieldNumber = 2;
  ::calmpilot::fusion::Object* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::Object >*
      mutable_objects();
  const ::calmpilot::fusion::Object& objects(int index) const;
  ::calmpilot::fusion::Object* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::Object >&
      objects() const;

  // .calmpilot.fusion.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::calmpilot::fusion::Header& _internal_header() const;
  public:
  const ::calmpilot::fusion::Header& header() const;
  ::calmpilot::fusion::Header* release_header();
  ::calmpilot::fusion::Header* mutable_header();
  void set_allocated_header(::calmpilot::fusion::Header* header);

  // @@protoc_insertion_point(class_scope:calmpilot.fusion.ObjFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::Object > objects_;
  ::calmpilot::fusion::Header* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_fusion_5fod_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// uint64 timestamp = 1;
inline void Header::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Header::timestamp() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Header.timestamp)
  return timestamp_;
}
inline void Header::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Header.timestamp)
}

// uint32 rolling_counter = 2;
inline void Header::clear_rolling_counter() {
  rolling_counter_ = 0u;
}
inline ::google::protobuf::uint32 Header::rolling_counter() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Header.rolling_counter)
  return rolling_counter_;
}
inline void Header::set_rolling_counter(::google::protobuf::uint32 value) {
  
  rolling_counter_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Header.rolling_counter)
}

// uint32 obj_num = 3;
inline void Header::clear_obj_num() {
  obj_num_ = 0u;
}
inline ::google::protobuf::uint32 Header::obj_num() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Header.obj_num)
  return obj_num_;
}
inline void Header::set_obj_num(::google::protobuf::uint32 value) {
  
  obj_num_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Header.obj_num)
}

// -------------------------------------------------------------------

// Vector3d

// double x = 1;
inline void Vector3d::clear_x() {
  x_ = 0;
}
inline double Vector3d::x() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Vector3d.x)
  return x_;
}
inline void Vector3d::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Vector3d.x)
}

// double y = 2;
inline void Vector3d::clear_y() {
  y_ = 0;
}
inline double Vector3d::y() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Vector3d.y)
  return y_;
}
inline void Vector3d::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Vector3d.y)
}

// double z = 3;
inline void Vector3d::clear_z() {
  z_ = 0;
}
inline double Vector3d::z() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Vector3d.z)
  return z_;
}
inline void Vector3d::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Vector3d.z)
}

// -------------------------------------------------------------------

// PredictTrajectory_Intention

// .calmpilot.fusion.LatIntention lat_intention = 1;
inline void PredictTrajectory_Intention::clear_lat_intention() {
  lat_intention_ = 0;
}
inline ::calmpilot::fusion::LatIntention PredictTrajectory_Intention::lat_intention() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.Intention.lat_intention)
  return static_cast< ::calmpilot::fusion::LatIntention >(lat_intention_);
}
inline void PredictTrajectory_Intention::set_lat_intention(::calmpilot::fusion::LatIntention value) {
  
  lat_intention_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.PredictTrajectory.Intention.lat_intention)
}

// .calmpilot.fusion.LongIntention long_intention = 2;
inline void PredictTrajectory_Intention::clear_long_intention() {
  long_intention_ = 0;
}
inline ::calmpilot::fusion::LongIntention PredictTrajectory_Intention::long_intention() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.Intention.long_intention)
  return static_cast< ::calmpilot::fusion::LongIntention >(long_intention_);
}
inline void PredictTrajectory_Intention::set_long_intention(::calmpilot::fusion::LongIntention value) {
  
  long_intention_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.PredictTrajectory.Intention.long_intention)
}

// -------------------------------------------------------------------

// PredictTrajectory_TrajPoint

// double dist_long = 1;
inline void PredictTrajectory_TrajPoint::clear_dist_long() {
  dist_long_ = 0;
}
inline double PredictTrajectory_TrajPoint::dist_long() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.TrajPoint.dist_long)
  return dist_long_;
}
inline void PredictTrajectory_TrajPoint::set_dist_long(double value) {
  
  dist_long_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.PredictTrajectory.TrajPoint.dist_long)
}

// double dist_lat = 2;
inline void PredictTrajectory_TrajPoint::clear_dist_lat() {
  dist_lat_ = 0;
}
inline double PredictTrajectory_TrajPoint::dist_lat() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.TrajPoint.dist_lat)
  return dist_lat_;
}
inline void PredictTrajectory_TrajPoint::set_dist_lat(double value) {
  
  dist_lat_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.PredictTrajectory.TrajPoint.dist_lat)
}

// -------------------------------------------------------------------

// PredictTrajectory

// .calmpilot.fusion.PredictTrajectory.Intention intention = 1;
inline bool PredictTrajectory::has_intention() const {
  return this != internal_default_instance() && intention_ != NULL;
}
inline void PredictTrajectory::clear_intention() {
  if (GetArenaNoVirtual() == NULL && intention_ != NULL) {
    delete intention_;
  }
  intention_ = NULL;
}
inline const ::calmpilot::fusion::PredictTrajectory_Intention& PredictTrajectory::_internal_intention() const {
  return *intention_;
}
inline const ::calmpilot::fusion::PredictTrajectory_Intention& PredictTrajectory::intention() const {
  const ::calmpilot::fusion::PredictTrajectory_Intention* p = intention_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.intention)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::PredictTrajectory_Intention*>(
      &::calmpilot::fusion::_PredictTrajectory_Intention_default_instance_);
}
inline ::calmpilot::fusion::PredictTrajectory_Intention* PredictTrajectory::release_intention() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.PredictTrajectory.intention)
  
  ::calmpilot::fusion::PredictTrajectory_Intention* temp = intention_;
  intention_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::PredictTrajectory_Intention* PredictTrajectory::mutable_intention() {
  
  if (intention_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::PredictTrajectory_Intention>(GetArenaNoVirtual());
    intention_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.PredictTrajectory.intention)
  return intention_;
}
inline void PredictTrajectory::set_allocated_intention(::calmpilot::fusion::PredictTrajectory_Intention* intention) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete intention_;
  }
  if (intention) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intention = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intention, submessage_arena);
    }
    
  } else {
    
  }
  intention_ = intention;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.PredictTrajectory.intention)
}

// repeated .calmpilot.fusion.PredictTrajectory.TrajPoint traj_points = 2;
inline int PredictTrajectory::traj_points_size() const {
  return traj_points_.size();
}
inline void PredictTrajectory::clear_traj_points() {
  traj_points_.Clear();
}
inline ::calmpilot::fusion::PredictTrajectory_TrajPoint* PredictTrajectory::mutable_traj_points(int index) {
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.PredictTrajectory.traj_points)
  return traj_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory_TrajPoint >*
PredictTrajectory::mutable_traj_points() {
  // @@protoc_insertion_point(field_mutable_list:calmpilot.fusion.PredictTrajectory.traj_points)
  return &traj_points_;
}
inline const ::calmpilot::fusion::PredictTrajectory_TrajPoint& PredictTrajectory::traj_points(int index) const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.traj_points)
  return traj_points_.Get(index);
}
inline ::calmpilot::fusion::PredictTrajectory_TrajPoint* PredictTrajectory::add_traj_points() {
  // @@protoc_insertion_point(field_add:calmpilot.fusion.PredictTrajectory.traj_points)
  return traj_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory_TrajPoint >&
PredictTrajectory::traj_points() const {
  // @@protoc_insertion_point(field_list:calmpilot.fusion.PredictTrajectory.traj_points)
  return traj_points_;
}

// double prob = 3;
inline void PredictTrajectory::clear_prob() {
  prob_ = 0;
}
inline double PredictTrajectory::prob() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.PredictTrajectory.prob)
  return prob_;
}
inline void PredictTrajectory::set_prob(double value) {
  
  prob_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.PredictTrajectory.prob)
}

// -------------------------------------------------------------------

// Object

// uint32 obj_id = 1;
inline void Object::clear_obj_id() {
  obj_id_ = 0u;
}
inline ::google::protobuf::uint32 Object::obj_id() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.obj_id)
  return obj_id_;
}
inline void Object::set_obj_id(::google::protobuf::uint32 value) {
  
  obj_id_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.obj_id)
}

// uint64 life_time = 2;
inline void Object::clear_life_time() {
  life_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Object::life_time() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.life_time)
  return life_time_;
}
inline void Object::set_life_time(::google::protobuf::uint64 value) {
  
  life_time_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.life_time)
}

// double confidence = 3;
inline void Object::clear_confidence() {
  confidence_ = 0;
}
inline double Object::confidence() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.confidence)
}

// .calmpilot.fusion.Object.ClassType class_type = 4;
inline void Object::clear_class_type() {
  class_type_ = 0;
}
inline ::calmpilot::fusion::Object_ClassType Object::class_type() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.class_type)
  return static_cast< ::calmpilot::fusion::Object_ClassType >(class_type_);
}
inline void Object::set_class_type(::calmpilot::fusion::Object_ClassType value) {
  
  class_type_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.class_type)
}

// double class_type_confidence = 5;
inline void Object::clear_class_type_confidence() {
  class_type_confidence_ = 0;
}
inline double Object::class_type_confidence() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.class_type_confidence)
  return class_type_confidence_;
}
inline void Object::set_class_type_confidence(double value) {
  
  class_type_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.class_type_confidence)
}

// .calmpilot.fusion.Vector3d center = 6;
inline bool Object::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline void Object::clear_center() {
  if (GetArenaNoVirtual() == NULL && center_ != NULL) {
    delete center_;
  }
  center_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_center() const {
  return *center_;
}
inline const ::calmpilot::fusion::Vector3d& Object::center() const {
  const ::calmpilot::fusion::Vector3d* p = center_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.center)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_center() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.center)
  
  ::calmpilot::fusion::Vector3d* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_center() {
  
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.center)
  return center_;
}
inline void Object::set_allocated_center(::calmpilot::fusion::Vector3d* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.center)
}

// .calmpilot.fusion.Vector3d center_rms = 7;
inline bool Object::has_center_rms() const {
  return this != internal_default_instance() && center_rms_ != NULL;
}
inline void Object::clear_center_rms() {
  if (GetArenaNoVirtual() == NULL && center_rms_ != NULL) {
    delete center_rms_;
  }
  center_rms_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_center_rms() const {
  return *center_rms_;
}
inline const ::calmpilot::fusion::Vector3d& Object::center_rms() const {
  const ::calmpilot::fusion::Vector3d* p = center_rms_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.center_rms)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_center_rms() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.center_rms)
  
  ::calmpilot::fusion::Vector3d* temp = center_rms_;
  center_rms_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_center_rms() {
  
  if (center_rms_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    center_rms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.center_rms)
  return center_rms_;
}
inline void Object::set_allocated_center_rms(::calmpilot::fusion::Vector3d* center_rms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_rms_;
  }
  if (center_rms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center_rms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_rms, submessage_arena);
    }
    
  } else {
    
  }
  center_rms_ = center_rms;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.center_rms)
}

// .calmpilot.fusion.Vector3d vrel = 8;
inline bool Object::has_vrel() const {
  return this != internal_default_instance() && vrel_ != NULL;
}
inline void Object::clear_vrel() {
  if (GetArenaNoVirtual() == NULL && vrel_ != NULL) {
    delete vrel_;
  }
  vrel_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_vrel() const {
  return *vrel_;
}
inline const ::calmpilot::fusion::Vector3d& Object::vrel() const {
  const ::calmpilot::fusion::Vector3d* p = vrel_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.vrel)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_vrel() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.vrel)
  
  ::calmpilot::fusion::Vector3d* temp = vrel_;
  vrel_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_vrel() {
  
  if (vrel_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    vrel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.vrel)
  return vrel_;
}
inline void Object::set_allocated_vrel(::calmpilot::fusion::Vector3d* vrel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vrel_;
  }
  if (vrel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vrel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vrel, submessage_arena);
    }
    
  } else {
    
  }
  vrel_ = vrel;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.vrel)
}

// .calmpilot.fusion.Vector3d vrel_rms = 9;
inline bool Object::has_vrel_rms() const {
  return this != internal_default_instance() && vrel_rms_ != NULL;
}
inline void Object::clear_vrel_rms() {
  if (GetArenaNoVirtual() == NULL && vrel_rms_ != NULL) {
    delete vrel_rms_;
  }
  vrel_rms_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_vrel_rms() const {
  return *vrel_rms_;
}
inline const ::calmpilot::fusion::Vector3d& Object::vrel_rms() const {
  const ::calmpilot::fusion::Vector3d* p = vrel_rms_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.vrel_rms)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_vrel_rms() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.vrel_rms)
  
  ::calmpilot::fusion::Vector3d* temp = vrel_rms_;
  vrel_rms_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_vrel_rms() {
  
  if (vrel_rms_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    vrel_rms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.vrel_rms)
  return vrel_rms_;
}
inline void Object::set_allocated_vrel_rms(::calmpilot::fusion::Vector3d* vrel_rms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vrel_rms_;
  }
  if (vrel_rms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vrel_rms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vrel_rms, submessage_arena);
    }
    
  } else {
    
  }
  vrel_rms_ = vrel_rms;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.vrel_rms)
}

// .calmpilot.fusion.Vector3d arel = 10;
inline bool Object::has_arel() const {
  return this != internal_default_instance() && arel_ != NULL;
}
inline void Object::clear_arel() {
  if (GetArenaNoVirtual() == NULL && arel_ != NULL) {
    delete arel_;
  }
  arel_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_arel() const {
  return *arel_;
}
inline const ::calmpilot::fusion::Vector3d& Object::arel() const {
  const ::calmpilot::fusion::Vector3d* p = arel_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.arel)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_arel() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.arel)
  
  ::calmpilot::fusion::Vector3d* temp = arel_;
  arel_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_arel() {
  
  if (arel_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    arel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.arel)
  return arel_;
}
inline void Object::set_allocated_arel(::calmpilot::fusion::Vector3d* arel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete arel_;
  }
  if (arel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      arel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arel, submessage_arena);
    }
    
  } else {
    
  }
  arel_ = arel;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.arel)
}

// .calmpilot.fusion.Vector3d arel_rms = 11;
inline bool Object::has_arel_rms() const {
  return this != internal_default_instance() && arel_rms_ != NULL;
}
inline void Object::clear_arel_rms() {
  if (GetArenaNoVirtual() == NULL && arel_rms_ != NULL) {
    delete arel_rms_;
  }
  arel_rms_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_arel_rms() const {
  return *arel_rms_;
}
inline const ::calmpilot::fusion::Vector3d& Object::arel_rms() const {
  const ::calmpilot::fusion::Vector3d* p = arel_rms_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.arel_rms)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_arel_rms() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.arel_rms)
  
  ::calmpilot::fusion::Vector3d* temp = arel_rms_;
  arel_rms_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_arel_rms() {
  
  if (arel_rms_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    arel_rms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.arel_rms)
  return arel_rms_;
}
inline void Object::set_allocated_arel_rms(::calmpilot::fusion::Vector3d* arel_rms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete arel_rms_;
  }
  if (arel_rms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      arel_rms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, arel_rms, submessage_arena);
    }
    
  } else {
    
  }
  arel_rms_ = arel_rms;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.arel_rms)
}

// .calmpilot.fusion.Vector3d abs_vel = 12;
inline bool Object::has_abs_vel() const {
  return this != internal_default_instance() && abs_vel_ != NULL;
}
inline void Object::clear_abs_vel() {
  if (GetArenaNoVirtual() == NULL && abs_vel_ != NULL) {
    delete abs_vel_;
  }
  abs_vel_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_abs_vel() const {
  return *abs_vel_;
}
inline const ::calmpilot::fusion::Vector3d& Object::abs_vel() const {
  const ::calmpilot::fusion::Vector3d* p = abs_vel_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.abs_vel)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_abs_vel() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.abs_vel)
  
  ::calmpilot::fusion::Vector3d* temp = abs_vel_;
  abs_vel_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_abs_vel() {
  
  if (abs_vel_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    abs_vel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.abs_vel)
  return abs_vel_;
}
inline void Object::set_allocated_abs_vel(::calmpilot::fusion::Vector3d* abs_vel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete abs_vel_;
  }
  if (abs_vel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      abs_vel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, abs_vel, submessage_arena);
    }
    
  } else {
    
  }
  abs_vel_ = abs_vel;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.abs_vel)
}

// .calmpilot.fusion.Vector3d abs_vel_rms = 13;
inline bool Object::has_abs_vel_rms() const {
  return this != internal_default_instance() && abs_vel_rms_ != NULL;
}
inline void Object::clear_abs_vel_rms() {
  if (GetArenaNoVirtual() == NULL && abs_vel_rms_ != NULL) {
    delete abs_vel_rms_;
  }
  abs_vel_rms_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_abs_vel_rms() const {
  return *abs_vel_rms_;
}
inline const ::calmpilot::fusion::Vector3d& Object::abs_vel_rms() const {
  const ::calmpilot::fusion::Vector3d* p = abs_vel_rms_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.abs_vel_rms)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_abs_vel_rms() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.abs_vel_rms)
  
  ::calmpilot::fusion::Vector3d* temp = abs_vel_rms_;
  abs_vel_rms_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_abs_vel_rms() {
  
  if (abs_vel_rms_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    abs_vel_rms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.abs_vel_rms)
  return abs_vel_rms_;
}
inline void Object::set_allocated_abs_vel_rms(::calmpilot::fusion::Vector3d* abs_vel_rms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete abs_vel_rms_;
  }
  if (abs_vel_rms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      abs_vel_rms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, abs_vel_rms, submessage_arena);
    }
    
  } else {
    
  }
  abs_vel_rms_ = abs_vel_rms;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.abs_vel_rms)
}

// .calmpilot.fusion.Vector3d size = 14;
inline bool Object::has_size() const {
  return this != internal_default_instance() && size_ != NULL;
}
inline void Object::clear_size() {
  if (GetArenaNoVirtual() == NULL && size_ != NULL) {
    delete size_;
  }
  size_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_size() const {
  return *size_;
}
inline const ::calmpilot::fusion::Vector3d& Object::size() const {
  const ::calmpilot::fusion::Vector3d* p = size_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.size)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_size() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.size)
  
  ::calmpilot::fusion::Vector3d* temp = size_;
  size_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_size() {
  
  if (size_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.size)
  return size_;
}
inline void Object::set_allocated_size(::calmpilot::fusion::Vector3d* size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_;
  }
  if (size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.size)
}

// .calmpilot.fusion.Vector3d size_rms = 15;
inline bool Object::has_size_rms() const {
  return this != internal_default_instance() && size_rms_ != NULL;
}
inline void Object::clear_size_rms() {
  if (GetArenaNoVirtual() == NULL && size_rms_ != NULL) {
    delete size_rms_;
  }
  size_rms_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_size_rms() const {
  return *size_rms_;
}
inline const ::calmpilot::fusion::Vector3d& Object::size_rms() const {
  const ::calmpilot::fusion::Vector3d* p = size_rms_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.size_rms)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_size_rms() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.size_rms)
  
  ::calmpilot::fusion::Vector3d* temp = size_rms_;
  size_rms_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_size_rms() {
  
  if (size_rms_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    size_rms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.size_rms)
  return size_rms_;
}
inline void Object::set_allocated_size_rms(::calmpilot::fusion::Vector3d* size_rms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_rms_;
  }
  if (size_rms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      size_rms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size_rms, submessage_arena);
    }
    
  } else {
    
  }
  size_rms_ = size_rms;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.size_rms)
}

// .calmpilot.fusion.Vector3d corner_left_front = 16;
inline bool Object::has_corner_left_front() const {
  return this != internal_default_instance() && corner_left_front_ != NULL;
}
inline void Object::clear_corner_left_front() {
  if (GetArenaNoVirtual() == NULL && corner_left_front_ != NULL) {
    delete corner_left_front_;
  }
  corner_left_front_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_corner_left_front() const {
  return *corner_left_front_;
}
inline const ::calmpilot::fusion::Vector3d& Object::corner_left_front() const {
  const ::calmpilot::fusion::Vector3d* p = corner_left_front_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.corner_left_front)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_corner_left_front() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.corner_left_front)
  
  ::calmpilot::fusion::Vector3d* temp = corner_left_front_;
  corner_left_front_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_corner_left_front() {
  
  if (corner_left_front_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    corner_left_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.corner_left_front)
  return corner_left_front_;
}
inline void Object::set_allocated_corner_left_front(::calmpilot::fusion::Vector3d* corner_left_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete corner_left_front_;
  }
  if (corner_left_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner_left_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner_left_front, submessage_arena);
    }
    
  } else {
    
  }
  corner_left_front_ = corner_left_front;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.corner_left_front)
}

// .calmpilot.fusion.Vector3d corner_right_front = 17;
inline bool Object::has_corner_right_front() const {
  return this != internal_default_instance() && corner_right_front_ != NULL;
}
inline void Object::clear_corner_right_front() {
  if (GetArenaNoVirtual() == NULL && corner_right_front_ != NULL) {
    delete corner_right_front_;
  }
  corner_right_front_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_corner_right_front() const {
  return *corner_right_front_;
}
inline const ::calmpilot::fusion::Vector3d& Object::corner_right_front() const {
  const ::calmpilot::fusion::Vector3d* p = corner_right_front_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.corner_right_front)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_corner_right_front() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.corner_right_front)
  
  ::calmpilot::fusion::Vector3d* temp = corner_right_front_;
  corner_right_front_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_corner_right_front() {
  
  if (corner_right_front_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    corner_right_front_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.corner_right_front)
  return corner_right_front_;
}
inline void Object::set_allocated_corner_right_front(::calmpilot::fusion::Vector3d* corner_right_front) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete corner_right_front_;
  }
  if (corner_right_front) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner_right_front = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner_right_front, submessage_arena);
    }
    
  } else {
    
  }
  corner_right_front_ = corner_right_front;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.corner_right_front)
}

// .calmpilot.fusion.Vector3d corner_left_rear = 18;
inline bool Object::has_corner_left_rear() const {
  return this != internal_default_instance() && corner_left_rear_ != NULL;
}
inline void Object::clear_corner_left_rear() {
  if (GetArenaNoVirtual() == NULL && corner_left_rear_ != NULL) {
    delete corner_left_rear_;
  }
  corner_left_rear_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_corner_left_rear() const {
  return *corner_left_rear_;
}
inline const ::calmpilot::fusion::Vector3d& Object::corner_left_rear() const {
  const ::calmpilot::fusion::Vector3d* p = corner_left_rear_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.corner_left_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_corner_left_rear() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.corner_left_rear)
  
  ::calmpilot::fusion::Vector3d* temp = corner_left_rear_;
  corner_left_rear_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_corner_left_rear() {
  
  if (corner_left_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    corner_left_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.corner_left_rear)
  return corner_left_rear_;
}
inline void Object::set_allocated_corner_left_rear(::calmpilot::fusion::Vector3d* corner_left_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete corner_left_rear_;
  }
  if (corner_left_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner_left_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner_left_rear, submessage_arena);
    }
    
  } else {
    
  }
  corner_left_rear_ = corner_left_rear;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.corner_left_rear)
}

// .calmpilot.fusion.Vector3d corner_right_rear = 19;
inline bool Object::has_corner_right_rear() const {
  return this != internal_default_instance() && corner_right_rear_ != NULL;
}
inline void Object::clear_corner_right_rear() {
  if (GetArenaNoVirtual() == NULL && corner_right_rear_ != NULL) {
    delete corner_right_rear_;
  }
  corner_right_rear_ = NULL;
}
inline const ::calmpilot::fusion::Vector3d& Object::_internal_corner_right_rear() const {
  return *corner_right_rear_;
}
inline const ::calmpilot::fusion::Vector3d& Object::corner_right_rear() const {
  const ::calmpilot::fusion::Vector3d* p = corner_right_rear_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.corner_right_rear)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Vector3d*>(
      &::calmpilot::fusion::_Vector3d_default_instance_);
}
inline ::calmpilot::fusion::Vector3d* Object::release_corner_right_rear() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.Object.corner_right_rear)
  
  ::calmpilot::fusion::Vector3d* temp = corner_right_rear_;
  corner_right_rear_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Vector3d* Object::mutable_corner_right_rear() {
  
  if (corner_right_rear_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Vector3d>(GetArenaNoVirtual());
    corner_right_rear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.corner_right_rear)
  return corner_right_rear_;
}
inline void Object::set_allocated_corner_right_rear(::calmpilot::fusion::Vector3d* corner_right_rear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete corner_right_rear_;
  }
  if (corner_right_rear) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner_right_rear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner_right_rear, submessage_arena);
    }
    
  } else {
    
  }
  corner_right_rear_ = corner_right_rear;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.Object.corner_right_rear)
}

// double orientation_angle = 20;
inline void Object::clear_orientation_angle() {
  orientation_angle_ = 0;
}
inline double Object::orientation_angle() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.orientation_angle)
  return orientation_angle_;
}
inline void Object::set_orientation_angle(double value) {
  
  orientation_angle_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.orientation_angle)
}

// double orientation_rms = 21;
inline void Object::clear_orientation_rms() {
  orientation_rms_ = 0;
}
inline double Object::orientation_rms() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.orientation_rms)
  return orientation_rms_;
}
inline void Object::set_orientation_rms(double value) {
  
  orientation_rms_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.orientation_rms)
}

// repeated .calmpilot.fusion.Object.MotionStatus motion_status = 22;
inline int Object::motion_status_size() const {
  return motion_status_.size();
}
inline void Object::clear_motion_status() {
  motion_status_.Clear();
}
inline ::calmpilot::fusion::Object_MotionStatus Object::motion_status(int index) const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.motion_status)
  return static_cast< ::calmpilot::fusion::Object_MotionStatus >(motion_status_.Get(index));
}
inline void Object::set_motion_status(int index, ::calmpilot::fusion::Object_MotionStatus value) {
  motion_status_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.motion_status)
}
inline void Object::add_motion_status(::calmpilot::fusion::Object_MotionStatus value) {
  motion_status_.Add(value);
  // @@protoc_insertion_point(field_add:calmpilot.fusion.Object.motion_status)
}
inline const ::google::protobuf::RepeatedField<int>&
Object::motion_status() const {
  // @@protoc_insertion_point(field_list:calmpilot.fusion.Object.motion_status)
  return motion_status_;
}
inline ::google::protobuf::RepeatedField<int>*
Object::mutable_motion_status() {
  // @@protoc_insertion_point(field_mutable_list:calmpilot.fusion.Object.motion_status)
  return &motion_status_;
}

// repeated double motion_status_confidence = 23;
inline int Object::motion_status_confidence_size() const {
  return motion_status_confidence_.size();
}
inline void Object::clear_motion_status_confidence() {
  motion_status_confidence_.Clear();
}
inline double Object::motion_status_confidence(int index) const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.motion_status_confidence)
  return motion_status_confidence_.Get(index);
}
inline void Object::set_motion_status_confidence(int index, double value) {
  motion_status_confidence_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.motion_status_confidence)
}
inline void Object::add_motion_status_confidence(double value) {
  motion_status_confidence_.Add(value);
  // @@protoc_insertion_point(field_add:calmpilot.fusion.Object.motion_status_confidence)
}
inline const ::google::protobuf::RepeatedField< double >&
Object::motion_status_confidence() const {
  // @@protoc_insertion_point(field_list:calmpilot.fusion.Object.motion_status_confidence)
  return motion_status_confidence_;
}
inline ::google::protobuf::RepeatedField< double >*
Object::mutable_motion_status_confidence() {
  // @@protoc_insertion_point(field_mutable_list:calmpilot.fusion.Object.motion_status_confidence)
  return &motion_status_confidence_;
}

// .calmpilot.fusion.Object.MeasuredSource measured_source = 24;
inline void Object::clear_measured_source() {
  measured_source_ = 0;
}
inline ::calmpilot::fusion::Object_MeasuredSource Object::measured_source() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.measured_source)
  return static_cast< ::calmpilot::fusion::Object_MeasuredSource >(measured_source_);
}
inline void Object::set_measured_source(::calmpilot::fusion::Object_MeasuredSource value) {
  
  measured_source_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.measured_source)
}

// .calmpilot.fusion.Object.MeasState meas_state = 25;
inline void Object::clear_meas_state() {
  meas_state_ = 0;
}
inline ::calmpilot::fusion::Object_MeasState Object::meas_state() const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.meas_state)
  return static_cast< ::calmpilot::fusion::Object_MeasState >(meas_state_);
}
inline void Object::set_meas_state(::calmpilot::fusion::Object_MeasState value) {
  
  meas_state_ = value;
  // @@protoc_insertion_point(field_set:calmpilot.fusion.Object.meas_state)
}

// repeated .calmpilot.fusion.PredictTrajectory trajectories = 26;
inline int Object::trajectories_size() const {
  return trajectories_.size();
}
inline void Object::clear_trajectories() {
  trajectories_.Clear();
}
inline ::calmpilot::fusion::PredictTrajectory* Object::mutable_trajectories(int index) {
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.Object.trajectories)
  return trajectories_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory >*
Object::mutable_trajectories() {
  // @@protoc_insertion_point(field_mutable_list:calmpilot.fusion.Object.trajectories)
  return &trajectories_;
}
inline const ::calmpilot::fusion::PredictTrajectory& Object::trajectories(int index) const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.Object.trajectories)
  return trajectories_.Get(index);
}
inline ::calmpilot::fusion::PredictTrajectory* Object::add_trajectories() {
  // @@protoc_insertion_point(field_add:calmpilot.fusion.Object.trajectories)
  return trajectories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::PredictTrajectory >&
Object::trajectories() const {
  // @@protoc_insertion_point(field_list:calmpilot.fusion.Object.trajectories)
  return trajectories_;
}

// -------------------------------------------------------------------

// ObjFrame

// .calmpilot.fusion.Header header = 1;
inline bool ObjFrame::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void ObjFrame::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::calmpilot::fusion::Header& ObjFrame::_internal_header() const {
  return *header_;
}
inline const ::calmpilot::fusion::Header& ObjFrame::header() const {
  const ::calmpilot::fusion::Header* p = header_;
  // @@protoc_insertion_point(field_get:calmpilot.fusion.ObjFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::calmpilot::fusion::Header*>(
      &::calmpilot::fusion::_Header_default_instance_);
}
inline ::calmpilot::fusion::Header* ObjFrame::release_header() {
  // @@protoc_insertion_point(field_release:calmpilot.fusion.ObjFrame.header)
  
  ::calmpilot::fusion::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::calmpilot::fusion::Header* ObjFrame::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::calmpilot::fusion::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.ObjFrame.header)
  return header_;
}
inline void ObjFrame::set_allocated_header(::calmpilot::fusion::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:calmpilot.fusion.ObjFrame.header)
}

// repeated .calmpilot.fusion.Object objects = 2;
inline int ObjFrame::objects_size() const {
  return objects_.size();
}
inline void ObjFrame::clear_objects() {
  objects_.Clear();
}
inline ::calmpilot::fusion::Object* ObjFrame::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:calmpilot.fusion.ObjFrame.objects)
  return objects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::Object >*
ObjFrame::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:calmpilot.fusion.ObjFrame.objects)
  return &objects_;
}
inline const ::calmpilot::fusion::Object& ObjFrame::objects(int index) const {
  // @@protoc_insertion_point(field_get:calmpilot.fusion.ObjFrame.objects)
  return objects_.Get(index);
}
inline ::calmpilot::fusion::Object* ObjFrame::add_objects() {
  // @@protoc_insertion_point(field_add:calmpilot.fusion.ObjFrame.objects)
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmpilot::fusion::Object >&
ObjFrame::objects() const {
  // @@protoc_insertion_point(field_list:calmpilot.fusion.ObjFrame.objects)
  return objects_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fusion
}  // namespace calmpilot

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmpilot::fusion::Object_ClassType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::Object_ClassType>() {
  return ::calmpilot::fusion::Object_ClassType_descriptor();
}
template <> struct is_proto_enum< ::calmpilot::fusion::Object_MotionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::Object_MotionStatus>() {
  return ::calmpilot::fusion::Object_MotionStatus_descriptor();
}
template <> struct is_proto_enum< ::calmpilot::fusion::Object_MeasuredSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::Object_MeasuredSource>() {
  return ::calmpilot::fusion::Object_MeasuredSource_descriptor();
}
template <> struct is_proto_enum< ::calmpilot::fusion::Object_MeasState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::Object_MeasState>() {
  return ::calmpilot::fusion::Object_MeasState_descriptor();
}
template <> struct is_proto_enum< ::calmpilot::fusion::LatIntention> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::LatIntention>() {
  return ::calmpilot::fusion::LatIntention_descriptor();
}
template <> struct is_proto_enum< ::calmpilot::fusion::LongIntention> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmpilot::fusion::LongIntention>() {
  return ::calmpilot::fusion::LongIntention_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fusion_5fod_2eproto
