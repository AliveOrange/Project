// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.proto

#ifndef PROTOBUF_INCLUDED_map_2eproto
#define PROTOBUF_INCLUDED_map_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "geometry.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_map_2eproto 

namespace protobuf_map_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_map_2eproto
namespace calmcar_map {
namespace proto {
namespace map {
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class LandMark;
class LandMarkDefaultTypeInternal;
extern LandMarkDefaultTypeInternal _LandMark_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneLine;
class LaneLineDefaultTypeInternal;
extern LaneLineDefaultTypeInternal _LaneLine_default_instance_;
class MapFrame;
class MapFrameDefaultTypeInternal;
extern MapFrameDefaultTypeInternal _MapFrame_default_instance_;
class MapFrame_LandMarkEntry_DoNotUse;
class MapFrame_LandMarkEntry_DoNotUseDefaultTypeInternal;
extern MapFrame_LandMarkEntry_DoNotUseDefaultTypeInternal _MapFrame_LandMarkEntry_DoNotUse_default_instance_;
class MapFrame_LaneLinesEntry_DoNotUse;
class MapFrame_LaneLinesEntry_DoNotUseDefaultTypeInternal;
extern MapFrame_LaneLinesEntry_DoNotUseDefaultTypeInternal _MapFrame_LaneLinesEntry_DoNotUse_default_instance_;
class MapFrame_LanesEntry_DoNotUse;
class MapFrame_LanesEntry_DoNotUseDefaultTypeInternal;
extern MapFrame_LanesEntry_DoNotUseDefaultTypeInternal _MapFrame_LanesEntry_DoNotUse_default_instance_;
}  // namespace map
}  // namespace proto
}  // namespace calmcar_map
namespace google {
namespace protobuf {
template<> ::calmcar_map::proto::map::Header* Arena::CreateMaybeMessage<::calmcar_map::proto::map::Header>(Arena*);
template<> ::calmcar_map::proto::map::LandMark* Arena::CreateMaybeMessage<::calmcar_map::proto::map::LandMark>(Arena*);
template<> ::calmcar_map::proto::map::Lane* Arena::CreateMaybeMessage<::calmcar_map::proto::map::Lane>(Arena*);
template<> ::calmcar_map::proto::map::LaneLine* Arena::CreateMaybeMessage<::calmcar_map::proto::map::LaneLine>(Arena*);
template<> ::calmcar_map::proto::map::MapFrame* Arena::CreateMaybeMessage<::calmcar_map::proto::map::MapFrame>(Arena*);
template<> ::calmcar_map::proto::map::MapFrame_LandMarkEntry_DoNotUse* Arena::CreateMaybeMessage<::calmcar_map::proto::map::MapFrame_LandMarkEntry_DoNotUse>(Arena*);
template<> ::calmcar_map::proto::map::MapFrame_LaneLinesEntry_DoNotUse* Arena::CreateMaybeMessage<::calmcar_map::proto::map::MapFrame_LaneLinesEntry_DoNotUse>(Arena*);
template<> ::calmcar_map::proto::map::MapFrame_LanesEntry_DoNotUse* Arena::CreateMaybeMessage<::calmcar_map::proto::map::MapFrame_LanesEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace calmcar_map {
namespace proto {
namespace map {

enum Lane_LaneTurn {
  Lane_LaneTurn_TURN_UNKNOWN = 0,
  Lane_LaneTurn_STRAIGHT = 1,
  Lane_LaneTurn_LEFT = 2,
  Lane_LaneTurn_RIGHT = 3,
  Lane_LaneTurn_UTURN = 4,
  Lane_LaneTurn_FORBIDTURN = 5,
  Lane_LaneTurn_Lane_LaneTurn_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Lane_LaneTurn_Lane_LaneTurn_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Lane_LaneTurn_IsValid(int value);
const Lane_LaneTurn Lane_LaneTurn_LaneTurn_MIN = Lane_LaneTurn_TURN_UNKNOWN;
const Lane_LaneTurn Lane_LaneTurn_LaneTurn_MAX = Lane_LaneTurn_FORBIDTURN;
const int Lane_LaneTurn_LaneTurn_ARRAYSIZE = Lane_LaneTurn_LaneTurn_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneTurn_descriptor();
inline const ::std::string& Lane_LaneTurn_Name(Lane_LaneTurn value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneTurn_descriptor(), value);
}
inline bool Lane_LaneTurn_Parse(
    const ::std::string& name, Lane_LaneTurn* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneTurn>(
    Lane_LaneTurn_descriptor(), name, value);
}
enum LaneLine_LaneLineType {
  LaneLine_LaneLineType_NO_MARKING = 0,
  LaneLine_LaneLineType_LONG_DASHED_LINE = 1,
  LaneLine_LaneLineType_DOUBLE_SOLID_LINE = 2,
  LaneLine_LaneLineType_SINGLE_SOLID_LINE = 3,
  LaneLine_LaneLineType_SOLID_LINE_DASHED_LINE = 4,
  LaneLine_LaneLineType_DASHED_LINE_SOLID_LINE = 5,
  LaneLine_LaneLineType_SHORT_DASHED_LINE = 6,
  LaneLine_LaneLineType_SHADED_AREA_MARKING = 7,
  LaneLine_LaneLineType_DASHED_BLOCKS = 8,
  LaneLine_LaneLineType_DOUBLE_DASHED_LINE = 9,
  LaneLine_LaneLineType_CROSSING_ALERT = 10,
  LaneLine_LaneLineType_CURB = 11,
  LaneLine_LaneLineType_WALL_FLAT = 12,
  LaneLine_LaneLineType_WALL_TUNNEL = 13,
  LaneLine_LaneLineType_BARRIER_JERSEY = 14,
  LaneLine_LaneLineType_BARRIER_SOUND = 15,
  LaneLine_LaneLineType_BARRIER_CABLE = 16,
  LaneLine_LaneLineType_GUARDRAIL = 17,
  LaneLine_LaneLineType_FENCE = 18,
  LaneLine_LaneLineType_CURB_TRAVERSABLE = 19,
  LaneLine_LaneLineType_END_OF_ROAD = 20,
  LaneLine_LaneLineType_CLIFF = 21,
  LaneLine_LaneLineType_DITCH = 22,
  LaneLine_LaneLineType_OTHER_BARRIER = 30,
  LaneLine_LaneLineType_UNKNOWN = 31,
  LaneLine_LaneLineType_LaneLine_LaneLineType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneLine_LaneLineType_LaneLine_LaneLineType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneLine_LaneLineType_IsValid(int value);
const LaneLine_LaneLineType LaneLine_LaneLineType_LaneLineType_MIN = LaneLine_LaneLineType_NO_MARKING;
const LaneLine_LaneLineType LaneLine_LaneLineType_LaneLineType_MAX = LaneLine_LaneLineType_UNKNOWN;
const int LaneLine_LaneLineType_LaneLineType_ARRAYSIZE = LaneLine_LaneLineType_LaneLineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneLine_LaneLineType_descriptor();
inline const ::std::string& LaneLine_LaneLineType_Name(LaneLine_LaneLineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneLine_LaneLineType_descriptor(), value);
}
inline bool LaneLine_LaneLineType_Parse(
    const ::std::string& name, LaneLine_LaneLineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneLine_LaneLineType>(
    LaneLine_LaneLineType_descriptor(), name, value);
}
enum LandMark_LandMarkType {
  LandMark_LandMarkType_SIGN = 0,
  LandMark_LandMarkType_POLE = 1,
  LandMark_LandMarkType_MARKING = 2,
  LandMark_LandMarkType_TRAFFICLIGHT = 3,
  LandMark_LandMarkType_WALL = 4,
  LandMark_LandMarkType_PROTRUSION = 5,
  LandMark_LandMarkType_CHAIN = 6,
  LandMark_LandMarkType_INVALID = 7,
  LandMark_LandMarkType_LandMark_LandMarkType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LandMark_LandMarkType_LandMark_LandMarkType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LandMark_LandMarkType_IsValid(int value);
const LandMark_LandMarkType LandMark_LandMarkType_LandMarkType_MIN = LandMark_LandMarkType_SIGN;
const LandMark_LandMarkType LandMark_LandMarkType_LandMarkType_MAX = LandMark_LandMarkType_INVALID;
const int LandMark_LandMarkType_LandMarkType_ARRAYSIZE = LandMark_LandMarkType_LandMarkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LandMark_LandMarkType_descriptor();
inline const ::std::string& LandMark_LandMarkType_Name(LandMark_LandMarkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LandMark_LandMarkType_descriptor(), value);
}
inline bool LandMark_LandMarkType_Parse(
    const ::std::string& name, LandMark_LandMarkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LandMark_LandMarkType>(
    LandMark_LandMarkType_descriptor(), name, value);
}
// ===================================================================

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar_map.proto.map.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Lane_LaneTurn LaneTurn;
  static const LaneTurn TURN_UNKNOWN =
    Lane_LaneTurn_TURN_UNKNOWN;
  static const LaneTurn STRAIGHT =
    Lane_LaneTurn_STRAIGHT;
  static const LaneTurn LEFT =
    Lane_LaneTurn_LEFT;
  static const LaneTurn RIGHT =
    Lane_LaneTurn_RIGHT;
  static const LaneTurn UTURN =
    Lane_LaneTurn_UTURN;
  static const LaneTurn FORBIDTURN =
    Lane_LaneTurn_FORBIDTURN;
  static inline bool LaneTurn_IsValid(int value) {
    return Lane_LaneTurn_IsValid(value);
  }
  static const LaneTurn LaneTurn_MIN =
    Lane_LaneTurn_LaneTurn_MIN;
  static const LaneTurn LaneTurn_MAX =
    Lane_LaneTurn_LaneTurn_MAX;
  static const int LaneTurn_ARRAYSIZE =
    Lane_LaneTurn_LaneTurn_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneTurn_descriptor() {
    return Lane_LaneTurn_descriptor();
  }
  static inline const ::std::string& LaneTurn_Name(LaneTurn value) {
    return Lane_LaneTurn_Name(value);
  }
  static inline bool LaneTurn_Parse(const ::std::string& name,
      LaneTurn* value) {
    return Lane_LaneTurn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .calmcar_map.proto.geometry.Polyline waypoints = 3;
  bool has_waypoints() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 3;
  private:
  const ::calmcar_map::proto::geometry::Polyline& _internal_waypoints() const;
  public:
  const ::calmcar_map::proto::geometry::Polyline& waypoints() const;
  ::calmcar_map::proto::geometry::Polyline* release_waypoints();
  ::calmcar_map::proto::geometry::Polyline* mutable_waypoints();
  void set_allocated_waypoints(::calmcar_map::proto::geometry::Polyline* waypoints);

  // uint64 key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint64 key() const;
  void set_key(::google::protobuf::uint64 value);

  // uint64 lane_index = 2;
  void clear_lane_index();
  static const int kLaneIndexFieldNumber = 2;
  ::google::protobuf::uint64 lane_index() const;
  void set_lane_index(::google::protobuf::uint64 value);

  // uint64 left_lane_key = 4;
  void clear_left_lane_key();
  static const int kLeftLaneKeyFieldNumber = 4;
  ::google::protobuf::uint64 left_lane_key() const;
  void set_left_lane_key(::google::protobuf::uint64 value);

  // uint64 right_lane_key = 5;
  void clear_right_lane_key();
  static const int kRightLaneKeyFieldNumber = 5;
  ::google::protobuf::uint64 right_lane_key() const;
  void set_right_lane_key(::google::protobuf::uint64 value);

  // uint64 left_lane_line_key = 6;
  void clear_left_lane_line_key();
  static const int kLeftLaneLineKeyFieldNumber = 6;
  ::google::protobuf::uint64 left_lane_line_key() const;
  void set_left_lane_line_key(::google::protobuf::uint64 value);

  // uint64 right_lane_line_key = 7;
  void clear_right_lane_line_key();
  static const int kRightLaneLineKeyFieldNumber = 7;
  ::google::protobuf::uint64 right_lane_line_key() const;
  void set_right_lane_line_key(::google::protobuf::uint64 value);

  // .calmcar_map.proto.map.Lane.LaneTurn lane_turn = 8;
  void clear_lane_turn();
  static const int kLaneTurnFieldNumber = 8;
  ::calmcar_map::proto::map::Lane_LaneTurn lane_turn() const;
  void set_lane_turn(::calmcar_map::proto::map::Lane_LaneTurn value);

  // @@protoc_insertion_point(class_scope:calmcar_map.proto.map.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar_map::proto::geometry::Polyline* waypoints_;
  ::google::protobuf::uint64 key_;
  ::google::protobuf::uint64 lane_index_;
  ::google::protobuf::uint64 left_lane_key_;
  ::google::protobuf::uint64 right_lane_key_;
  ::google::protobuf::uint64 left_lane_line_key_;
  ::google::protobuf::uint64 right_lane_line_key_;
  int lane_turn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar_map.proto.map.LaneLine) */ {
 public:
  LaneLine();
  virtual ~LaneLine();

  LaneLine(const LaneLine& from);

  inline LaneLine& operator=(const LaneLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneLine(LaneLine&& from) noexcept
    : LaneLine() {
    *this = ::std::move(from);
  }

  inline LaneLine& operator=(LaneLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneLine* internal_default_instance() {
    return reinterpret_cast<const LaneLine*>(
               &_LaneLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LaneLine* other);
  friend void swap(LaneLine& a, LaneLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneLine* New() const final {
    return CreateMaybeMessage<LaneLine>(NULL);
  }

  LaneLine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneLine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneLine& from);
  void MergeFrom(const LaneLine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneLine_LaneLineType LaneLineType;
  static const LaneLineType NO_MARKING =
    LaneLine_LaneLineType_NO_MARKING;
  static const LaneLineType LONG_DASHED_LINE =
    LaneLine_LaneLineType_LONG_DASHED_LINE;
  static const LaneLineType DOUBLE_SOLID_LINE =
    LaneLine_LaneLineType_DOUBLE_SOLID_LINE;
  static const LaneLineType SINGLE_SOLID_LINE =
    LaneLine_LaneLineType_SINGLE_SOLID_LINE;
  static const LaneLineType SOLID_LINE_DASHED_LINE =
    LaneLine_LaneLineType_SOLID_LINE_DASHED_LINE;
  static const LaneLineType DASHED_LINE_SOLID_LINE =
    LaneLine_LaneLineType_DASHED_LINE_SOLID_LINE;
  static const LaneLineType SHORT_DASHED_LINE =
    LaneLine_LaneLineType_SHORT_DASHED_LINE;
  static const LaneLineType SHADED_AREA_MARKING =
    LaneLine_LaneLineType_SHADED_AREA_MARKING;
  static const LaneLineType DASHED_BLOCKS =
    LaneLine_LaneLineType_DASHED_BLOCKS;
  static const LaneLineType DOUBLE_DASHED_LINE =
    LaneLine_LaneLineType_DOUBLE_DASHED_LINE;
  static const LaneLineType CROSSING_ALERT =
    LaneLine_LaneLineType_CROSSING_ALERT;
  static const LaneLineType CURB =
    LaneLine_LaneLineType_CURB;
  static const LaneLineType WALL_FLAT =
    LaneLine_LaneLineType_WALL_FLAT;
  static const LaneLineType WALL_TUNNEL =
    LaneLine_LaneLineType_WALL_TUNNEL;
  static const LaneLineType BARRIER_JERSEY =
    LaneLine_LaneLineType_BARRIER_JERSEY;
  static const LaneLineType BARRIER_SOUND =
    LaneLine_LaneLineType_BARRIER_SOUND;
  static const LaneLineType BARRIER_CABLE =
    LaneLine_LaneLineType_BARRIER_CABLE;
  static const LaneLineType GUARDRAIL =
    LaneLine_LaneLineType_GUARDRAIL;
  static const LaneLineType FENCE =
    LaneLine_LaneLineType_FENCE;
  static const LaneLineType CURB_TRAVERSABLE =
    LaneLine_LaneLineType_CURB_TRAVERSABLE;
  static const LaneLineType END_OF_ROAD =
    LaneLine_LaneLineType_END_OF_ROAD;
  static const LaneLineType CLIFF =
    LaneLine_LaneLineType_CLIFF;
  static const LaneLineType DITCH =
    LaneLine_LaneLineType_DITCH;
  static const LaneLineType OTHER_BARRIER =
    LaneLine_LaneLineType_OTHER_BARRIER;
  static const LaneLineType UNKNOWN =
    LaneLine_LaneLineType_UNKNOWN;
  static inline bool LaneLineType_IsValid(int value) {
    return LaneLine_LaneLineType_IsValid(value);
  }
  static const LaneLineType LaneLineType_MIN =
    LaneLine_LaneLineType_LaneLineType_MIN;
  static const LaneLineType LaneLineType_MAX =
    LaneLine_LaneLineType_LaneLineType_MAX;
  static const int LaneLineType_ARRAYSIZE =
    LaneLine_LaneLineType_LaneLineType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneLineType_descriptor() {
    return LaneLine_LaneLineType_descriptor();
  }
  static inline const ::std::string& LaneLineType_Name(LaneLineType value) {
    return LaneLine_LaneLineType_Name(value);
  }
  static inline bool LaneLineType_Parse(const ::std::string& name,
      LaneLineType* value) {
    return LaneLine_LaneLineType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .calmcar_map.proto.geometry.Polyline points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  private:
  const ::calmcar_map::proto::geometry::Polyline& _internal_points() const;
  public:
  const ::calmcar_map::proto::geometry::Polyline& points() const;
  ::calmcar_map::proto::geometry::Polyline* release_points();
  ::calmcar_map::proto::geometry::Polyline* mutable_points();
  void set_allocated_points(::calmcar_map::proto::geometry::Polyline* points);

  // uint64 key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint64 key() const;
  void set_key(::google::protobuf::uint64 value);

  // uint64 lane_line_index = 2;
  void clear_lane_line_index();
  static const int kLaneLineIndexFieldNumber = 2;
  ::google::protobuf::uint64 lane_line_index() const;
  void set_lane_line_index(::google::protobuf::uint64 value);

  // .calmcar_map.proto.map.LaneLine.LaneLineType lane_line_type = 4;
  void clear_lane_line_type();
  static const int kLaneLineTypeFieldNumber = 4;
  ::calmcar_map::proto::map::LaneLine_LaneLineType lane_line_type() const;
  void set_lane_line_type(::calmcar_map::proto::map::LaneLine_LaneLineType value);

  // @@protoc_insertion_point(class_scope:calmcar_map.proto.map.LaneLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::calmcar_map::proto::geometry::Polyline* points_;
  ::google::protobuf::uint64 key_;
  ::google::protobuf::uint64 lane_line_index_;
  int lane_line_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LandMark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar_map.proto.map.LandMark) */ {
 public:
  LandMark();
  virtual ~LandMark();

  LandMark(const LandMark& from);

  inline LandMark& operator=(const LandMark& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LandMark(LandMark&& from) noexcept
    : LandMark() {
    *this = ::std::move(from);
  }

  inline LandMark& operator=(LandMark&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LandMark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LandMark* internal_default_instance() {
    return reinterpret_cast<const LandMark*>(
               &_LandMark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LandMark* other);
  friend void swap(LandMark& a, LandMark& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LandMark* New() const final {
    return CreateMaybeMessage<LandMark>(NULL);
  }

  LandMark* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LandMark>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LandMark& from);
  void MergeFrom(const LandMark& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LandMark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LandMark_LandMarkType LandMarkType;
  static const LandMarkType SIGN =
    LandMark_LandMarkType_SIGN;
  static const LandMarkType POLE =
    LandMark_LandMarkType_POLE;
  static const LandMarkType MARKING =
    LandMark_LandMarkType_MARKING;
  static const LandMarkType TRAFFICLIGHT =
    LandMark_LandMarkType_TRAFFICLIGHT;
  static const LandMarkType WALL =
    LandMark_LandMarkType_WALL;
  static const LandMarkType PROTRUSION =
    LandMark_LandMarkType_PROTRUSION;
  static const LandMarkType CHAIN =
    LandMark_LandMarkType_CHAIN;
  static const LandMarkType INVALID =
    LandMark_LandMarkType_INVALID;
  static inline bool LandMarkType_IsValid(int value) {
    return LandMark_LandMarkType_IsValid(value);
  }
  static const LandMarkType LandMarkType_MIN =
    LandMark_LandMarkType_LandMarkType_MIN;
  static const LandMarkType LandMarkType_MAX =
    LandMark_LandMarkType_LandMarkType_MAX;
  static const int LandMarkType_ARRAYSIZE =
    LandMark_LandMarkType_LandMarkType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LandMarkType_descriptor() {
    return LandMark_LandMarkType_descriptor();
  }
  static inline const ::std::string& LandMarkType_Name(LandMarkType value) {
    return LandMark_LandMarkType_Name(value);
  }
  static inline bool LandMarkType_Parse(const ::std::string& name,
      LandMarkType* value) {
    return LandMark_LandMarkType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint64 lane_keys = 5;
  int lane_keys_size() const;
  void clear_lane_keys();
  static const int kLaneKeysFieldNumber = 5;
  ::google::protobuf::uint64 lane_keys(int index) const;
  void set_lane_keys(int index, ::google::protobuf::uint64 value);
  void add_lane_keys(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      lane_keys() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_lane_keys();

  // .calmcar_map.proto.geometry.Polygon points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  private:
  const ::calmcar_map::proto::geometry::Polygon& _internal_points() const;
  public:
  const ::calmcar_map::proto::geometry::Polygon& points() const;
  ::calmcar_map::proto::geometry::Polygon* release_points();
  ::calmcar_map::proto::geometry::Polygon* mutable_points();
  void set_allocated_points(::calmcar_map::proto::geometry::Polygon* points);

  // .calmcar_map.proto.geometry.Polygon boundingBox = 4;
  bool has_boundingbox() const;
  void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 4;
  private:
  const ::calmcar_map::proto::geometry::Polygon& _internal_boundingbox() const;
  public:
  const ::calmcar_map::proto::geometry::Polygon& boundingbox() const;
  ::calmcar_map::proto::geometry::Polygon* release_boundingbox();
  ::calmcar_map::proto::geometry::Polygon* mutable_boundingbox();
  void set_allocated_boundingbox(::calmcar_map::proto::geometry::Polygon* boundingbox);

  // uint64 landmark_key = 1;
  void clear_landmark_key();
  static const int kLandmarkKeyFieldNumber = 1;
  ::google::protobuf::uint64 landmark_key() const;
  void set_landmark_key(::google::protobuf::uint64 value);

  // .calmcar_map.proto.map.LandMark.LandMarkType landmark_type = 2;
  void clear_landmark_type();
  static const int kLandmarkTypeFieldNumber = 2;
  ::calmcar_map::proto::map::LandMark_LandMarkType landmark_type() const;
  void set_landmark_type(::calmcar_map::proto::map::LandMark_LandMarkType value);

  // @@protoc_insertion_point(class_scope:calmcar_map.proto.map.LandMark)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > lane_keys_;
  mutable int _lane_keys_cached_byte_size_;
  ::calmcar_map::proto::geometry::Polygon* points_;
  ::calmcar_map::proto::geometry::Polygon* boundingbox_;
  ::google::protobuf::uint64 landmark_key_;
  int landmark_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar_map.proto.map.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 timestamp_in = 1;
  void clear_timestamp_in();
  static const int kTimestampInFieldNumber = 1;
  ::google::protobuf::uint64 timestamp_in() const;
  void set_timestamp_in(::google::protobuf::uint64 value);

  // uint64 timestamp_age = 2;
  void clear_timestamp_age();
  static const int kTimestampAgeFieldNumber = 2;
  ::google::protobuf::uint64 timestamp_age() const;
  void set_timestamp_age(::google::protobuf::uint64 value);

  // uint64 timestamp_last = 3;
  void clear_timestamp_last();
  static const int kTimestampLastFieldNumber = 3;
  ::google::protobuf::uint64 timestamp_last() const;
  void set_timestamp_last(::google::protobuf::uint64 value);

  // uint32 rolling_counter = 4;
  void clear_rolling_counter();
  static const int kRollingCounterFieldNumber = 4;
  ::google::protobuf::uint32 rolling_counter() const;
  void set_rolling_counter(::google::protobuf::uint32 value);

  // int32 angle_heading = 5;
  void clear_angle_heading();
  static const int kAngleHeadingFieldNumber = 5;
  ::google::protobuf::int32 angle_heading() const;
  void set_angle_heading(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calmcar_map.proto.map.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 timestamp_in_;
  ::google::protobuf::uint64 timestamp_age_;
  ::google::protobuf::uint64 timestamp_last_;
  ::google::protobuf::uint32 rolling_counter_;
  ::google::protobuf::int32 angle_heading_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapFrame_LanesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MapFrame_LanesEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MapFrame_LanesEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  MapFrame_LanesEntry_DoNotUse();
  MapFrame_LanesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MapFrame_LanesEntry_DoNotUse& other);
  static const MapFrame_LanesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapFrame_LanesEntry_DoNotUse*>(&_MapFrame_LanesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MapFrame_LaneLinesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MapFrame_LaneLinesEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MapFrame_LaneLinesEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  MapFrame_LaneLinesEntry_DoNotUse();
  MapFrame_LaneLinesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MapFrame_LaneLinesEntry_DoNotUse& other);
  static const MapFrame_LaneLinesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapFrame_LaneLinesEntry_DoNotUse*>(&_MapFrame_LaneLinesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MapFrame_LandMarkEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MapFrame_LandMarkEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MapFrame_LandMarkEntry_DoNotUse, 
    ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  MapFrame_LandMarkEntry_DoNotUse();
  MapFrame_LandMarkEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MapFrame_LandMarkEntry_DoNotUse& other);
  static const MapFrame_LandMarkEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapFrame_LandMarkEntry_DoNotUse*>(&_MapFrame_LandMarkEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MapFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar_map.proto.map.MapFrame) */ {
 public:
  MapFrame();
  virtual ~MapFrame();

  MapFrame(const MapFrame& from);

  inline MapFrame& operator=(const MapFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapFrame(MapFrame&& from) noexcept
    : MapFrame() {
    *this = ::std::move(from);
  }

  inline MapFrame& operator=(MapFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapFrame* internal_default_instance() {
    return reinterpret_cast<const MapFrame*>(
               &_MapFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MapFrame* other);
  friend void swap(MapFrame& a, MapFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapFrame* New() const final {
    return CreateMaybeMessage<MapFrame>(NULL);
  }

  MapFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapFrame& from);
  void MergeFrom(const MapFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint64, .calmcar_map.proto.map.Lane> lanes = 2;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane >&
      lanes() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane >*
      mutable_lanes();

  // map<uint64, .calmcar_map.proto.map.LaneLine> lane_lines = 3;
  int lane_lines_size() const;
  void clear_lane_lines();
  static const int kLaneLinesFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine >&
      lane_lines() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine >*
      mutable_lane_lines();

  // map<uint64, .calmcar_map.proto.map.LandMark> land_mark = 4;
  int land_mark_size() const;
  void clear_land_mark();
  static const int kLandMarkFieldNumber = 4;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark >&
      land_mark() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark >*
      mutable_land_mark();

  // .calmcar_map.proto.map.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::calmcar_map::proto::map::Header& _internal_header() const;
  public:
  const ::calmcar_map::proto::map::Header& header() const;
  ::calmcar_map::proto::map::Header* release_header();
  ::calmcar_map::proto::map::Header* mutable_header();
  void set_allocated_header(::calmcar_map::proto::map::Header* header);

  // @@protoc_insertion_point(class_scope:calmcar_map.proto.map.MapFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MapFrame_LanesEntry_DoNotUse,
      ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > lanes_;
  ::google::protobuf::internal::MapField<
      MapFrame_LaneLinesEntry_DoNotUse,
      ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > lane_lines_;
  ::google::protobuf::internal::MapField<
      MapFrame_LandMarkEntry_DoNotUse,
      ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > land_mark_;
  ::calmcar_map::proto::map::Header* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_map_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Lane

// uint64 key = 1;
inline void Lane::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.key)
  return key_;
}
inline void Lane::set_key(::google::protobuf::uint64 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.key)
}

// uint64 lane_index = 2;
inline void Lane::clear_lane_index() {
  lane_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::lane_index() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.lane_index)
  return lane_index_;
}
inline void Lane::set_lane_index(::google::protobuf::uint64 value) {
  
  lane_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.lane_index)
}

// .calmcar_map.proto.geometry.Polyline waypoints = 3;
inline bool Lane::has_waypoints() const {
  return this != internal_default_instance() && waypoints_ != NULL;
}
inline const ::calmcar_map::proto::geometry::Polyline& Lane::_internal_waypoints() const {
  return *waypoints_;
}
inline const ::calmcar_map::proto::geometry::Polyline& Lane::waypoints() const {
  const ::calmcar_map::proto::geometry::Polyline* p = waypoints_;
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.waypoints)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar_map::proto::geometry::Polyline*>(
      &::calmcar_map::proto::geometry::_Polyline_default_instance_);
}
inline ::calmcar_map::proto::geometry::Polyline* Lane::release_waypoints() {
  // @@protoc_insertion_point(field_release:calmcar_map.proto.map.Lane.waypoints)
  
  ::calmcar_map::proto::geometry::Polyline* temp = waypoints_;
  waypoints_ = NULL;
  return temp;
}
inline ::calmcar_map::proto::geometry::Polyline* Lane::mutable_waypoints() {
  
  if (waypoints_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar_map::proto::geometry::Polyline>(GetArenaNoVirtual());
    waypoints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar_map.proto.map.Lane.waypoints)
  return waypoints_;
}
inline void Lane::set_allocated_waypoints(::calmcar_map::proto::geometry::Polyline* waypoints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(waypoints_);
  }
  if (waypoints) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      waypoints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoints, submessage_arena);
    }
    
  } else {
    
  }
  waypoints_ = waypoints;
  // @@protoc_insertion_point(field_set_allocated:calmcar_map.proto.map.Lane.waypoints)
}

// uint64 left_lane_key = 4;
inline void Lane::clear_left_lane_key() {
  left_lane_key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::left_lane_key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.left_lane_key)
  return left_lane_key_;
}
inline void Lane::set_left_lane_key(::google::protobuf::uint64 value) {
  
  left_lane_key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.left_lane_key)
}

// uint64 right_lane_key = 5;
inline void Lane::clear_right_lane_key() {
  right_lane_key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::right_lane_key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.right_lane_key)
  return right_lane_key_;
}
inline void Lane::set_right_lane_key(::google::protobuf::uint64 value) {
  
  right_lane_key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.right_lane_key)
}

// uint64 left_lane_line_key = 6;
inline void Lane::clear_left_lane_line_key() {
  left_lane_line_key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::left_lane_line_key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.left_lane_line_key)
  return left_lane_line_key_;
}
inline void Lane::set_left_lane_line_key(::google::protobuf::uint64 value) {
  
  left_lane_line_key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.left_lane_line_key)
}

// uint64 right_lane_line_key = 7;
inline void Lane::clear_right_lane_line_key() {
  right_lane_line_key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Lane::right_lane_line_key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.right_lane_line_key)
  return right_lane_line_key_;
}
inline void Lane::set_right_lane_line_key(::google::protobuf::uint64 value) {
  
  right_lane_line_key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.right_lane_line_key)
}

// .calmcar_map.proto.map.Lane.LaneTurn lane_turn = 8;
inline void Lane::clear_lane_turn() {
  lane_turn_ = 0;
}
inline ::calmcar_map::proto::map::Lane_LaneTurn Lane::lane_turn() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Lane.lane_turn)
  return static_cast< ::calmcar_map::proto::map::Lane_LaneTurn >(lane_turn_);
}
inline void Lane::set_lane_turn(::calmcar_map::proto::map::Lane_LaneTurn value) {
  
  lane_turn_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Lane.lane_turn)
}

// -------------------------------------------------------------------

// LaneLine

// uint64 key = 1;
inline void LaneLine::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LaneLine::key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LaneLine.key)
  return key_;
}
inline void LaneLine::set_key(::google::protobuf::uint64 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LaneLine.key)
}

// uint64 lane_line_index = 2;
inline void LaneLine::clear_lane_line_index() {
  lane_line_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LaneLine::lane_line_index() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LaneLine.lane_line_index)
  return lane_line_index_;
}
inline void LaneLine::set_lane_line_index(::google::protobuf::uint64 value) {
  
  lane_line_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LaneLine.lane_line_index)
}

// .calmcar_map.proto.geometry.Polyline points = 3;
inline bool LaneLine::has_points() const {
  return this != internal_default_instance() && points_ != NULL;
}
inline const ::calmcar_map::proto::geometry::Polyline& LaneLine::_internal_points() const {
  return *points_;
}
inline const ::calmcar_map::proto::geometry::Polyline& LaneLine::points() const {
  const ::calmcar_map::proto::geometry::Polyline* p = points_;
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LaneLine.points)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar_map::proto::geometry::Polyline*>(
      &::calmcar_map::proto::geometry::_Polyline_default_instance_);
}
inline ::calmcar_map::proto::geometry::Polyline* LaneLine::release_points() {
  // @@protoc_insertion_point(field_release:calmcar_map.proto.map.LaneLine.points)
  
  ::calmcar_map::proto::geometry::Polyline* temp = points_;
  points_ = NULL;
  return temp;
}
inline ::calmcar_map::proto::geometry::Polyline* LaneLine::mutable_points() {
  
  if (points_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar_map::proto::geometry::Polyline>(GetArenaNoVirtual());
    points_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar_map.proto.map.LaneLine.points)
  return points_;
}
inline void LaneLine::set_allocated_points(::calmcar_map::proto::geometry::Polyline* points) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(points_);
  }
  if (points) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      points = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  points_ = points;
  // @@protoc_insertion_point(field_set_allocated:calmcar_map.proto.map.LaneLine.points)
}

// .calmcar_map.proto.map.LaneLine.LaneLineType lane_line_type = 4;
inline void LaneLine::clear_lane_line_type() {
  lane_line_type_ = 0;
}
inline ::calmcar_map::proto::map::LaneLine_LaneLineType LaneLine::lane_line_type() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LaneLine.lane_line_type)
  return static_cast< ::calmcar_map::proto::map::LaneLine_LaneLineType >(lane_line_type_);
}
inline void LaneLine::set_lane_line_type(::calmcar_map::proto::map::LaneLine_LaneLineType value) {
  
  lane_line_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LaneLine.lane_line_type)
}

// -------------------------------------------------------------------

// LandMark

// uint64 landmark_key = 1;
inline void LandMark::clear_landmark_key() {
  landmark_key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LandMark::landmark_key() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LandMark.landmark_key)
  return landmark_key_;
}
inline void LandMark::set_landmark_key(::google::protobuf::uint64 value) {
  
  landmark_key_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LandMark.landmark_key)
}

// .calmcar_map.proto.map.LandMark.LandMarkType landmark_type = 2;
inline void LandMark::clear_landmark_type() {
  landmark_type_ = 0;
}
inline ::calmcar_map::proto::map::LandMark_LandMarkType LandMark::landmark_type() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LandMark.landmark_type)
  return static_cast< ::calmcar_map::proto::map::LandMark_LandMarkType >(landmark_type_);
}
inline void LandMark::set_landmark_type(::calmcar_map::proto::map::LandMark_LandMarkType value) {
  
  landmark_type_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LandMark.landmark_type)
}

// .calmcar_map.proto.geometry.Polygon points = 3;
inline bool LandMark::has_points() const {
  return this != internal_default_instance() && points_ != NULL;
}
inline const ::calmcar_map::proto::geometry::Polygon& LandMark::_internal_points() const {
  return *points_;
}
inline const ::calmcar_map::proto::geometry::Polygon& LandMark::points() const {
  const ::calmcar_map::proto::geometry::Polygon* p = points_;
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LandMark.points)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar_map::proto::geometry::Polygon*>(
      &::calmcar_map::proto::geometry::_Polygon_default_instance_);
}
inline ::calmcar_map::proto::geometry::Polygon* LandMark::release_points() {
  // @@protoc_insertion_point(field_release:calmcar_map.proto.map.LandMark.points)
  
  ::calmcar_map::proto::geometry::Polygon* temp = points_;
  points_ = NULL;
  return temp;
}
inline ::calmcar_map::proto::geometry::Polygon* LandMark::mutable_points() {
  
  if (points_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar_map::proto::geometry::Polygon>(GetArenaNoVirtual());
    points_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar_map.proto.map.LandMark.points)
  return points_;
}
inline void LandMark::set_allocated_points(::calmcar_map::proto::geometry::Polygon* points) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(points_);
  }
  if (points) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      points = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  points_ = points;
  // @@protoc_insertion_point(field_set_allocated:calmcar_map.proto.map.LandMark.points)
}

// .calmcar_map.proto.geometry.Polygon boundingBox = 4;
inline bool LandMark::has_boundingbox() const {
  return this != internal_default_instance() && boundingbox_ != NULL;
}
inline const ::calmcar_map::proto::geometry::Polygon& LandMark::_internal_boundingbox() const {
  return *boundingbox_;
}
inline const ::calmcar_map::proto::geometry::Polygon& LandMark::boundingbox() const {
  const ::calmcar_map::proto::geometry::Polygon* p = boundingbox_;
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LandMark.boundingBox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar_map::proto::geometry::Polygon*>(
      &::calmcar_map::proto::geometry::_Polygon_default_instance_);
}
inline ::calmcar_map::proto::geometry::Polygon* LandMark::release_boundingbox() {
  // @@protoc_insertion_point(field_release:calmcar_map.proto.map.LandMark.boundingBox)
  
  ::calmcar_map::proto::geometry::Polygon* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}
inline ::calmcar_map::proto::geometry::Polygon* LandMark::mutable_boundingbox() {
  
  if (boundingbox_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar_map::proto::geometry::Polygon>(GetArenaNoVirtual());
    boundingbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar_map.proto.map.LandMark.boundingBox)
  return boundingbox_;
}
inline void LandMark::set_allocated_boundingbox(::calmcar_map::proto::geometry::Polygon* boundingbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(boundingbox_);
  }
  if (boundingbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boundingbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boundingbox, submessage_arena);
    }
    
  } else {
    
  }
  boundingbox_ = boundingbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar_map.proto.map.LandMark.boundingBox)
}

// repeated uint64 lane_keys = 5;
inline int LandMark::lane_keys_size() const {
  return lane_keys_.size();
}
inline void LandMark::clear_lane_keys() {
  lane_keys_.Clear();
}
inline ::google::protobuf::uint64 LandMark::lane_keys(int index) const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.LandMark.lane_keys)
  return lane_keys_.Get(index);
}
inline void LandMark::set_lane_keys(int index, ::google::protobuf::uint64 value) {
  lane_keys_.Set(index, value);
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.LandMark.lane_keys)
}
inline void LandMark::add_lane_keys(::google::protobuf::uint64 value) {
  lane_keys_.Add(value);
  // @@protoc_insertion_point(field_add:calmcar_map.proto.map.LandMark.lane_keys)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
LandMark::lane_keys() const {
  // @@protoc_insertion_point(field_list:calmcar_map.proto.map.LandMark.lane_keys)
  return lane_keys_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
LandMark::mutable_lane_keys() {
  // @@protoc_insertion_point(field_mutable_list:calmcar_map.proto.map.LandMark.lane_keys)
  return &lane_keys_;
}

// -------------------------------------------------------------------

// Header

// uint64 timestamp_in = 1;
inline void Header::clear_timestamp_in() {
  timestamp_in_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Header::timestamp_in() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Header.timestamp_in)
  return timestamp_in_;
}
inline void Header::set_timestamp_in(::google::protobuf::uint64 value) {
  
  timestamp_in_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Header.timestamp_in)
}

// uint64 timestamp_age = 2;
inline void Header::clear_timestamp_age() {
  timestamp_age_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Header::timestamp_age() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Header.timestamp_age)
  return timestamp_age_;
}
inline void Header::set_timestamp_age(::google::protobuf::uint64 value) {
  
  timestamp_age_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Header.timestamp_age)
}

// uint64 timestamp_last = 3;
inline void Header::clear_timestamp_last() {
  timestamp_last_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Header::timestamp_last() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Header.timestamp_last)
  return timestamp_last_;
}
inline void Header::set_timestamp_last(::google::protobuf::uint64 value) {
  
  timestamp_last_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Header.timestamp_last)
}

// uint32 rolling_counter = 4;
inline void Header::clear_rolling_counter() {
  rolling_counter_ = 0u;
}
inline ::google::protobuf::uint32 Header::rolling_counter() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Header.rolling_counter)
  return rolling_counter_;
}
inline void Header::set_rolling_counter(::google::protobuf::uint32 value) {
  
  rolling_counter_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Header.rolling_counter)
}

// int32 angle_heading = 5;
inline void Header::clear_angle_heading() {
  angle_heading_ = 0;
}
inline ::google::protobuf::int32 Header::angle_heading() const {
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.Header.angle_heading)
  return angle_heading_;
}
inline void Header::set_angle_heading(::google::protobuf::int32 value) {
  
  angle_heading_ = value;
  // @@protoc_insertion_point(field_set:calmcar_map.proto.map.Header.angle_heading)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapFrame

// .calmcar_map.proto.map.Header header = 1;
inline bool MapFrame::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void MapFrame::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::calmcar_map::proto::map::Header& MapFrame::_internal_header() const {
  return *header_;
}
inline const ::calmcar_map::proto::map::Header& MapFrame::header() const {
  const ::calmcar_map::proto::map::Header* p = header_;
  // @@protoc_insertion_point(field_get:calmcar_map.proto.map.MapFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar_map::proto::map::Header*>(
      &::calmcar_map::proto::map::_Header_default_instance_);
}
inline ::calmcar_map::proto::map::Header* MapFrame::release_header() {
  // @@protoc_insertion_point(field_release:calmcar_map.proto.map.MapFrame.header)
  
  ::calmcar_map::proto::map::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::calmcar_map::proto::map::Header* MapFrame::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar_map::proto::map::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar_map.proto.map.MapFrame.header)
  return header_;
}
inline void MapFrame::set_allocated_header(::calmcar_map::proto::map::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:calmcar_map.proto.map.MapFrame.header)
}

// map<uint64, .calmcar_map.proto.map.Lane> lanes = 2;
inline int MapFrame::lanes_size() const {
  return lanes_.size();
}
inline void MapFrame::clear_lanes() {
  lanes_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane >&
MapFrame::lanes() const {
  // @@protoc_insertion_point(field_map:calmcar_map.proto.map.MapFrame.lanes)
  return lanes_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::Lane >*
MapFrame::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_map:calmcar_map.proto.map.MapFrame.lanes)
  return lanes_.MutableMap();
}

// map<uint64, .calmcar_map.proto.map.LaneLine> lane_lines = 3;
inline int MapFrame::lane_lines_size() const {
  return lane_lines_.size();
}
inline void MapFrame::clear_lane_lines() {
  lane_lines_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine >&
MapFrame::lane_lines() const {
  // @@protoc_insertion_point(field_map:calmcar_map.proto.map.MapFrame.lane_lines)
  return lane_lines_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LaneLine >*
MapFrame::mutable_lane_lines() {
  // @@protoc_insertion_point(field_mutable_map:calmcar_map.proto.map.MapFrame.lane_lines)
  return lane_lines_.MutableMap();
}

// map<uint64, .calmcar_map.proto.map.LandMark> land_mark = 4;
inline int MapFrame::land_mark_size() const {
  return land_mark_.size();
}
inline void MapFrame::clear_land_mark() {
  land_mark_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark >&
MapFrame::land_mark() const {
  // @@protoc_insertion_point(field_map:calmcar_map.proto.map.MapFrame.land_mark)
  return land_mark_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::calmcar_map::proto::map::LandMark >*
MapFrame::mutable_land_mark() {
  // @@protoc_insertion_point(field_mutable_map:calmcar_map.proto.map.MapFrame.land_mark)
  return land_mark_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace proto
}  // namespace calmcar_map

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmcar_map::proto::map::Lane_LaneTurn> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar_map::proto::map::Lane_LaneTurn>() {
  return ::calmcar_map::proto::map::Lane_LaneTurn_descriptor();
}
template <> struct is_proto_enum< ::calmcar_map::proto::map::LaneLine_LaneLineType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar_map::proto::map::LaneLine_LaneLineType>() {
  return ::calmcar_map::proto::map::LaneLine_LaneLineType_descriptor();
}
template <> struct is_proto_enum< ::calmcar_map::proto::map::LandMark_LandMarkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar_map::proto::map::LandMark_LandMarkType>() {
  return ::calmcar_map::proto::map::LandMark_LandMarkType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_map_2eproto
