// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception.proto

#ifndef PROTOBUF_INCLUDED_perception_2eproto
#define PROTOBUF_INCLUDED_perception_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "perception_types.pb.h"
#include "perception_sensor_info.pb.h"
#include "perception_vehicle.pb.h"
#include "perception_road.pb.h"
#include "perception_barricade.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_perception_2eproto 

namespace protobuf_perception_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_perception_2eproto
namespace calmcar {
namespace perception {
class Failsafe;
class FailsafeDefaultTypeInternal;
extern FailsafeDefaultTypeInternal _Failsafe_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class MeasuringStatus;
class MeasuringStatusDefaultTypeInternal;
extern MeasuringStatusDefaultTypeInternal _MeasuringStatus_default_instance_;
class Object;
class ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class PerceptionFrame;
class PerceptionFrameDefaultTypeInternal;
extern PerceptionFrameDefaultTypeInternal _PerceptionFrame_default_instance_;
class TrafficLight;
class TrafficLightDefaultTypeInternal;
extern TrafficLightDefaultTypeInternal _TrafficLight_default_instance_;
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSignStatus;
class TrafficSignStatusDefaultTypeInternal;
extern TrafficSignStatusDefaultTypeInternal _TrafficSignStatus_default_instance_;
class TrafficSignType;
class TrafficSignTypeDefaultTypeInternal;
extern TrafficSignTypeDefaultTypeInternal _TrafficSignType_default_instance_;
}  // namespace perception
}  // namespace calmcar
namespace google {
namespace protobuf {
template<> ::calmcar::perception::Failsafe* Arena::CreateMaybeMessage<::calmcar::perception::Failsafe>(Arena*);
template<> ::calmcar::perception::Header* Arena::CreateMaybeMessage<::calmcar::perception::Header>(Arena*);
template<> ::calmcar::perception::MeasuringStatus* Arena::CreateMaybeMessage<::calmcar::perception::MeasuringStatus>(Arena*);
template<> ::calmcar::perception::Object* Arena::CreateMaybeMessage<::calmcar::perception::Object>(Arena*);
template<> ::calmcar::perception::PerceptionFrame* Arena::CreateMaybeMessage<::calmcar::perception::PerceptionFrame>(Arena*);
template<> ::calmcar::perception::TrafficLight* Arena::CreateMaybeMessage<::calmcar::perception::TrafficLight>(Arena*);
template<> ::calmcar::perception::TrafficSign* Arena::CreateMaybeMessage<::calmcar::perception::TrafficSign>(Arena*);
template<> ::calmcar::perception::TrafficSignStatus* Arena::CreateMaybeMessage<::calmcar::perception::TrafficSignStatus>(Arena*);
template<> ::calmcar::perception::TrafficSignType* Arena::CreateMaybeMessage<::calmcar::perception::TrafficSignType>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace calmcar {
namespace perception {

enum Header_ProtobufVersion {
  Header_ProtobufVersion_V_1_0_0 = 0,
  Header_ProtobufVersion_V_1_0_1 = 1,
  Header_ProtobufVersion_V_1_0_2 = 2,
  Header_ProtobufVersion_V_1_0_3 = 3,
  Header_ProtobufVersion_V_1_0_4 = 4,
  Header_ProtobufVersion_V_1_0_5 = 5,
  Header_ProtobufVersion_V_1_0_6 = 6,
  Header_ProtobufVersion_V_1_0_7 = 7,
  Header_ProtobufVersion_V_1_0_8 = 8,
  Header_ProtobufVersion_V_1_0_9 = 9,
  Header_ProtobufVersion_V_1_0_10 = 10,
  Header_ProtobufVersion_V_1_0_11 = 11,
  Header_ProtobufVersion_V_1_0_12 = 12,
  Header_ProtobufVersion_V_1_0_13 = 13,
  Header_ProtobufVersion_V_1_0_14 = 14,
  Header_ProtobufVersion_CURRENT_VERSION = 14,
  Header_ProtobufVersion_Header_ProtobufVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_ProtobufVersion_Header_ProtobufVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_ProtobufVersion_IsValid(int value);
const Header_ProtobufVersion Header_ProtobufVersion_ProtobufVersion_MIN = Header_ProtobufVersion_V_1_0_0;
const Header_ProtobufVersion Header_ProtobufVersion_ProtobufVersion_MAX = Header_ProtobufVersion_V_1_0_14;
const int Header_ProtobufVersion_ProtobufVersion_ARRAYSIZE = Header_ProtobufVersion_ProtobufVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_ProtobufVersion_descriptor();
inline const ::std::string& Header_ProtobufVersion_Name(Header_ProtobufVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_ProtobufVersion_descriptor(), value);
}
inline bool Header_ProtobufVersion_Parse(
    const ::std::string& name, Header_ProtobufVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ProtobufVersion>(
    Header_ProtobufVersion_descriptor(), name, value);
}
enum Header_ObjectVersion {
  Header_ObjectVersion_OD_V_1_0 = 0,
  Header_ObjectVersion_OD_V_1_1 = 1,
  Header_ObjectVersion_OD_CURRENT_VERSION = 1,
  Header_ObjectVersion_Header_ObjectVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_ObjectVersion_Header_ObjectVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_ObjectVersion_IsValid(int value);
const Header_ObjectVersion Header_ObjectVersion_ObjectVersion_MIN = Header_ObjectVersion_OD_V_1_0;
const Header_ObjectVersion Header_ObjectVersion_ObjectVersion_MAX = Header_ObjectVersion_OD_V_1_1;
const int Header_ObjectVersion_ObjectVersion_ARRAYSIZE = Header_ObjectVersion_ObjectVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_ObjectVersion_descriptor();
inline const ::std::string& Header_ObjectVersion_Name(Header_ObjectVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_ObjectVersion_descriptor(), value);
}
inline bool Header_ObjectVersion_Parse(
    const ::std::string& name, Header_ObjectVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ObjectVersion>(
    Header_ObjectVersion_descriptor(), name, value);
}
enum Header_TrafficLightStructVersion {
  Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0 = 0,
  Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1 = 1,
  Header_TrafficLightStructVersion_TFL_STRUCT_CURRENT_VERSION = 1,
  Header_TrafficLightStructVersion_Header_TrafficLightStructVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficLightStructVersion_Header_TrafficLightStructVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficLightStructVersion_IsValid(int value);
const Header_TrafficLightStructVersion Header_TrafficLightStructVersion_TrafficLightStructVersion_MIN = Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0;
const Header_TrafficLightStructVersion Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX = Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1;
const int Header_TrafficLightStructVersion_TrafficLightStructVersion_ARRAYSIZE = Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficLightStructVersion_descriptor();
inline const ::std::string& Header_TrafficLightStructVersion_Name(Header_TrafficLightStructVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficLightStructVersion_descriptor(), value);
}
inline bool Header_TrafficLightStructVersion_Parse(
    const ::std::string& name, Header_TrafficLightStructVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficLightStructVersion>(
    Header_TrafficLightStructVersion_descriptor(), name, value);
}
enum Header_TrafficLightSpotVersion {
  Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0 = 0,
  Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1 = 1,
  Header_TrafficLightSpotVersion_TFL_SPOT_CURRENT_VERSION = 1,
  Header_TrafficLightSpotVersion_Header_TrafficLightSpotVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficLightSpotVersion_Header_TrafficLightSpotVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficLightSpotVersion_IsValid(int value);
const Header_TrafficLightSpotVersion Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MIN = Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0;
const Header_TrafficLightSpotVersion Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX = Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1;
const int Header_TrafficLightSpotVersion_TrafficLightSpotVersion_ARRAYSIZE = Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficLightSpotVersion_descriptor();
inline const ::std::string& Header_TrafficLightSpotVersion_Name(Header_TrafficLightSpotVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficLightSpotVersion_descriptor(), value);
}
inline bool Header_TrafficLightSpotVersion_Parse(
    const ::std::string& name, Header_TrafficLightSpotVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficLightSpotVersion>(
    Header_TrafficLightSpotVersion_descriptor(), name, value);
}
enum Header_TrafficSignVersion {
  Header_TrafficSignVersion_TSR_V_1_0 = 0,
  Header_TrafficSignVersion_TSR_V_1_1 = 1,
  Header_TrafficSignVersion_TSR_CURRENT_VERSION = 1,
  Header_TrafficSignVersion_Header_TrafficSignVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_TrafficSignVersion_Header_TrafficSignVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_TrafficSignVersion_IsValid(int value);
const Header_TrafficSignVersion Header_TrafficSignVersion_TrafficSignVersion_MIN = Header_TrafficSignVersion_TSR_V_1_0;
const Header_TrafficSignVersion Header_TrafficSignVersion_TrafficSignVersion_MAX = Header_TrafficSignVersion_TSR_V_1_1;
const int Header_TrafficSignVersion_TrafficSignVersion_ARRAYSIZE = Header_TrafficSignVersion_TrafficSignVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_TrafficSignVersion_descriptor();
inline const ::std::string& Header_TrafficSignVersion_Name(Header_TrafficSignVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_TrafficSignVersion_descriptor(), value);
}
inline bool Header_TrafficSignVersion_Parse(
    const ::std::string& name, Header_TrafficSignVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_TrafficSignVersion>(
    Header_TrafficSignVersion_descriptor(), name, value);
}
enum Header_FailSafeVersion {
  Header_FailSafeVersion_FS_V_1_0 = 0,
  Header_FailSafeVersion_FS_V_1_1 = 1,
  Header_FailSafeVersion_FS_CURRENT_VERSION = 1,
  Header_FailSafeVersion_Header_FailSafeVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_FailSafeVersion_Header_FailSafeVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_FailSafeVersion_IsValid(int value);
const Header_FailSafeVersion Header_FailSafeVersion_FailSafeVersion_MIN = Header_FailSafeVersion_FS_V_1_0;
const Header_FailSafeVersion Header_FailSafeVersion_FailSafeVersion_MAX = Header_FailSafeVersion_FS_V_1_1;
const int Header_FailSafeVersion_FailSafeVersion_ARRAYSIZE = Header_FailSafeVersion_FailSafeVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_FailSafeVersion_descriptor();
inline const ::std::string& Header_FailSafeVersion_Name(Header_FailSafeVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_FailSafeVersion_descriptor(), value);
}
inline bool Header_FailSafeVersion_Parse(
    const ::std::string& name, Header_FailSafeVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_FailSafeVersion>(
    Header_FailSafeVersion_descriptor(), name, value);
}
enum Header_LaneVersion {
  Header_LaneVersion_LANE_V_1_0 = 0,
  Header_LaneVersion_LANE_V_1_1 = 1,
  Header_LaneVersion_LANE_CURRENT_VERSION = 1,
  Header_LaneVersion_Header_LaneVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_LaneVersion_Header_LaneVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_LaneVersion_IsValid(int value);
const Header_LaneVersion Header_LaneVersion_LaneVersion_MIN = Header_LaneVersion_LANE_V_1_0;
const Header_LaneVersion Header_LaneVersion_LaneVersion_MAX = Header_LaneVersion_LANE_V_1_1;
const int Header_LaneVersion_LaneVersion_ARRAYSIZE = Header_LaneVersion_LaneVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_LaneVersion_descriptor();
inline const ::std::string& Header_LaneVersion_Name(Header_LaneVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_LaneVersion_descriptor(), value);
}
inline bool Header_LaneVersion_Parse(
    const ::std::string& name, Header_LaneVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_LaneVersion>(
    Header_LaneVersion_descriptor(), name, value);
}
enum Header_RoadMarkVersion {
  Header_RoadMarkVersion_RM_V_1_0 = 0,
  Header_RoadMarkVersion_RM_V_1_1 = 1,
  Header_RoadMarkVersion_RM_CURRENT_VERSION = 1,
  Header_RoadMarkVersion_Header_RoadMarkVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_RoadMarkVersion_Header_RoadMarkVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_RoadMarkVersion_IsValid(int value);
const Header_RoadMarkVersion Header_RoadMarkVersion_RoadMarkVersion_MIN = Header_RoadMarkVersion_RM_V_1_0;
const Header_RoadMarkVersion Header_RoadMarkVersion_RoadMarkVersion_MAX = Header_RoadMarkVersion_RM_V_1_1;
const int Header_RoadMarkVersion_RoadMarkVersion_ARRAYSIZE = Header_RoadMarkVersion_RoadMarkVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_RoadMarkVersion_descriptor();
inline const ::std::string& Header_RoadMarkVersion_Name(Header_RoadMarkVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_RoadMarkVersion_descriptor(), value);
}
inline bool Header_RoadMarkVersion_Parse(
    const ::std::string& name, Header_RoadMarkVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_RoadMarkVersion>(
    Header_RoadMarkVersion_descriptor(), name, value);
}
enum Header_FreeSpaceVersion {
  Header_FreeSpaceVersion_FSP_V_1_0 = 0,
  Header_FreeSpaceVersion_FSP_V_1_1 = 1,
  Header_FreeSpaceVersion_FSP_CURRENT_VERSION = 1,
  Header_FreeSpaceVersion_Header_FreeSpaceVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_FreeSpaceVersion_Header_FreeSpaceVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_FreeSpaceVersion_IsValid(int value);
const Header_FreeSpaceVersion Header_FreeSpaceVersion_FreeSpaceVersion_MIN = Header_FreeSpaceVersion_FSP_V_1_0;
const Header_FreeSpaceVersion Header_FreeSpaceVersion_FreeSpaceVersion_MAX = Header_FreeSpaceVersion_FSP_V_1_1;
const int Header_FreeSpaceVersion_FreeSpaceVersion_ARRAYSIZE = Header_FreeSpaceVersion_FreeSpaceVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_FreeSpaceVersion_descriptor();
inline const ::std::string& Header_FreeSpaceVersion_Name(Header_FreeSpaceVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_FreeSpaceVersion_descriptor(), value);
}
inline bool Header_FreeSpaceVersion_Parse(
    const ::std::string& name, Header_FreeSpaceVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_FreeSpaceVersion>(
    Header_FreeSpaceVersion_descriptor(), name, value);
}
enum Header_BarricadeVersion {
  Header_BarricadeVersion_BA_V_1_0 = 0,
  Header_BarricadeVersion_BA_CURRENT_VERSION = 0,
  Header_BarricadeVersion_Header_BarricadeVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Header_BarricadeVersion_Header_BarricadeVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Header_BarricadeVersion_IsValid(int value);
const Header_BarricadeVersion Header_BarricadeVersion_BarricadeVersion_MIN = Header_BarricadeVersion_BA_V_1_0;
const Header_BarricadeVersion Header_BarricadeVersion_BarricadeVersion_MAX = Header_BarricadeVersion_BA_V_1_0;
const int Header_BarricadeVersion_BarricadeVersion_ARRAYSIZE = Header_BarricadeVersion_BarricadeVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_BarricadeVersion_descriptor();
inline const ::std::string& Header_BarricadeVersion_Name(Header_BarricadeVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_BarricadeVersion_descriptor(), value);
}
inline bool Header_BarricadeVersion_Parse(
    const ::std::string& name, Header_BarricadeVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_BarricadeVersion>(
    Header_BarricadeVersion_descriptor(), name, value);
}
enum TrafficLight_Color {
  TrafficLight_Color_COLOR_UNKNOWN = 0,
  TrafficLight_Color_COLOR_GREEN = 1,
  TrafficLight_Color_COLOR_RED = 2,
  TrafficLight_Color_COLOR_YELLOW = 3,
  TrafficLight_Color_TrafficLight_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Color_TrafficLight_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Color_IsValid(int value);
const TrafficLight_Color TrafficLight_Color_Color_MIN = TrafficLight_Color_COLOR_UNKNOWN;
const TrafficLight_Color TrafficLight_Color_Color_MAX = TrafficLight_Color_COLOR_YELLOW;
const int TrafficLight_Color_Color_ARRAYSIZE = TrafficLight_Color_Color_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Color_descriptor();
inline const ::std::string& TrafficLight_Color_Name(TrafficLight_Color value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Color_descriptor(), value);
}
inline bool TrafficLight_Color_Parse(
    const ::std::string& name, TrafficLight_Color* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Color>(
    TrafficLight_Color_descriptor(), name, value);
}
enum TrafficLight_Type {
  TrafficLight_Type_TYPE_UNKNOWN = 0,
  TrafficLight_Type_TYPE_ARROW_STRAIGHT = 1,
  TrafficLight_Type_TYPE_ARROW_LEFT = 2,
  TrafficLight_Type_TYPE_ARROW_RIGHT = 3,
  TrafficLight_Type_TYPE_ARROW_UTURN = 4,
  TrafficLight_Type_TYPE_CIRCLE = 5,
  TrafficLight_Type_TYPE_NUM = 6,
  TrafficLight_Type_TrafficLight_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Type_TrafficLight_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Type_IsValid(int value);
const TrafficLight_Type TrafficLight_Type_Type_MIN = TrafficLight_Type_TYPE_UNKNOWN;
const TrafficLight_Type TrafficLight_Type_Type_MAX = TrafficLight_Type_TYPE_NUM;
const int TrafficLight_Type_Type_ARRAYSIZE = TrafficLight_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Type_descriptor();
inline const ::std::string& TrafficLight_Type_Name(TrafficLight_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Type_descriptor(), value);
}
inline bool TrafficLight_Type_Parse(
    const ::std::string& name, TrafficLight_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Type>(
    TrafficLight_Type_descriptor(), name, value);
}
enum TrafficLight_Mode {
  TrafficLight_Mode_NO_BRIGHT = 0,
  TrafficLight_Mode_ALWAYS_BRIGHT = 1,
  TrafficLight_Mode_FLASH = 2,
  TrafficLight_Mode_TrafficLight_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLight_Mode_TrafficLight_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLight_Mode_IsValid(int value);
const TrafficLight_Mode TrafficLight_Mode_Mode_MIN = TrafficLight_Mode_NO_BRIGHT;
const TrafficLight_Mode TrafficLight_Mode_Mode_MAX = TrafficLight_Mode_FLASH;
const int TrafficLight_Mode_Mode_ARRAYSIZE = TrafficLight_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLight_Mode_descriptor();
inline const ::std::string& TrafficLight_Mode_Name(TrafficLight_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLight_Mode_descriptor(), value);
}
inline bool TrafficLight_Mode_Parse(
    const ::std::string& name, TrafficLight_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLight_Mode>(
    TrafficLight_Mode_descriptor(), name, value);
}
enum TrafficSign_TrafficSIgnRelevancy {
  TrafficSign_TrafficSIgnRelevancy_Unknow = 0,
  TrafficSign_TrafficSIgnRelevancy_RELEVANT = 1,
  TrafficSign_TrafficSIgnRelevancy_UNRELEVANT = 2,
  TrafficSign_TrafficSIgnRelevancy_TrafficSign_TrafficSIgnRelevancy_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_TrafficSIgnRelevancy_TrafficSign_TrafficSIgnRelevancy_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_TrafficSIgnRelevancy_IsValid(int value);
const TrafficSign_TrafficSIgnRelevancy TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MIN = TrafficSign_TrafficSIgnRelevancy_Unknow;
const TrafficSign_TrafficSIgnRelevancy TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX = TrafficSign_TrafficSIgnRelevancy_UNRELEVANT;
const int TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_ARRAYSIZE = TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_TrafficSIgnRelevancy_descriptor();
inline const ::std::string& TrafficSign_TrafficSIgnRelevancy_Name(TrafficSign_TrafficSIgnRelevancy value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_TrafficSIgnRelevancy_descriptor(), value);
}
inline bool TrafficSign_TrafficSIgnRelevancy_Parse(
    const ::std::string& name, TrafficSign_TrafficSIgnRelevancy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_TrafficSIgnRelevancy>(
    TrafficSign_TrafficSIgnRelevancy_descriptor(), name, value);
}
enum TrafficSignType_Type {
  TrafficSignType_Type_UNKNOWN = 0,
  TrafficSignType_Type_WARNING = 6,
  TrafficSignType_Type_PROHIBIT = 7,
  TrafficSignType_Type_ASSIST = 11,
  TrafficSignType_Type_TrafficSignType_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_Type_TrafficSignType_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_Type_IsValid(int value);
const TrafficSignType_Type TrafficSignType_Type_Type_MIN = TrafficSignType_Type_UNKNOWN;
const TrafficSignType_Type TrafficSignType_Type_Type_MAX = TrafficSignType_Type_ASSIST;
const int TrafficSignType_Type_Type_ARRAYSIZE = TrafficSignType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_Type_descriptor();
inline const ::std::string& TrafficSignType_Type_Name(TrafficSignType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_Type_descriptor(), value);
}
inline bool TrafficSignType_Type_Parse(
    const ::std::string& name, TrafficSignType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_Type>(
    TrafficSignType_Type_descriptor(), name, value);
}
enum TrafficSignType_ProhibitionSign {
  TrafficSignType_ProhibitionSign_SPEED_LIMIT5 = 0,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT10 = 1,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT15 = 2,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT20 = 3,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT30 = 4,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT35 = 5,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT40 = 6,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT50 = 7,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT60 = 8,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT70 = 9,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT80 = 10,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT90 = 11,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT100 = 12,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT110 = 13,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT120 = 14,
  TrafficSignType_ProhibitionSign_STOP = 15,
  TrafficSignType_ProhibitionSign_YIELD = 16,
  TrafficSignType_ProhibitionSign_NO_ENTRY = 17,
  TrafficSignType_ProhibitionSign_DONOT_ENTER = 18,
  TrafficSignType_ProhibitionSign_NO_MOTOR_VEHICLES = 19,
  TrafficSignType_ProhibitionSign_NO_TRUCKS = 20,
  TrafficSignType_ProhibitionSign_NO_LARGE_BUESE = 21,
  TrafficSignType_ProhibitionSign_NO_MOTORCYCLES = 22,
  TrafficSignType_ProhibitionSign_ONLY_MOTOR_VEHICLES = 23,
  TrafficSignType_ProhibitionSign_NO_PEDESTRIANS = 24,
  TrafficSignType_ProhibitionSign_NO_LEFT_TURN = 25,
  TrafficSignType_ProhibitionSign_NO_RIGHT_TURN = 26,
  TrafficSignType_ProhibitionSign_NO_U_TURN = 27,
  TrafficSignType_ProhibitionSign_NO_OVERTAKING = 28,
  TrafficSignType_ProhibitionSign_NO_STOPPING = 29,
  TrafficSignType_ProhibitionSign_NO_HONKING = 30,
  TrafficSignType_ProhibitionSign_MAX_CLEARANCE = 31,
  TrafficSignType_ProhibitionSign_WEIGHT_LIMIT = 32,
  TrafficSignType_ProhibitionSign_AXLE_WEIGHT_LIMIT = 33,
  TrafficSignType_ProhibitionSign_SPEED_LIMIT_END = 34,
  TrafficSignType_ProhibitionSign_NO_MINIBUSES = 35,
  TrafficSignType_ProhibitionSign_NO_TRACTOR = 36,
  TrafficSignType_ProhibitionSign_NO_STRAIGHT = 37,
  TrafficSignType_ProhibitionSign_NO_LEFT_RIGHT_TURN = 38,
  TrafficSignType_ProhibitionSign_NO_OVERTAKING_END = 39,
  TrafficSignType_ProhibitionSign_MAX_WIDTH = 40,
  TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES = 41,
  TrafficSignType_ProhibitionSign_TrafficSignType_ProhibitionSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_ProhibitionSign_TrafficSignType_ProhibitionSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_ProhibitionSign_IsValid(int value);
const TrafficSignType_ProhibitionSign TrafficSignType_ProhibitionSign_ProhibitionSign_MIN = TrafficSignType_ProhibitionSign_SPEED_LIMIT5;
const TrafficSignType_ProhibitionSign TrafficSignType_ProhibitionSign_ProhibitionSign_MAX = TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES;
const int TrafficSignType_ProhibitionSign_ProhibitionSign_ARRAYSIZE = TrafficSignType_ProhibitionSign_ProhibitionSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_ProhibitionSign_descriptor();
inline const ::std::string& TrafficSignType_ProhibitionSign_Name(TrafficSignType_ProhibitionSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_ProhibitionSign_descriptor(), value);
}
inline bool TrafficSignType_ProhibitionSign_Parse(
    const ::std::string& name, TrafficSignType_ProhibitionSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_ProhibitionSign>(
    TrafficSignType_ProhibitionSign_descriptor(), name, value);
}
enum TrafficSignType_WarningSign {
  TrafficSignType_WarningSign_CROSSROADS = 0,
  TrafficSignType_WarningSign_SHARP_CURVE = 1,
  TrafficSignType_WarningSign_REVERSE_CURVE = 2,
  TrafficSignType_WarningSign_WINDING_CURVES = 3,
  TrafficSignType_WarningSign_STEEP_DESCENT = 4,
  TrafficSignType_WarningSign_NARROW_ROAD = 5,
  TrafficSignType_WarningSign_NARROW_BRIDGE = 6,
  TrafficSignType_WarningSign_TWO_WAY_TRAFFIC = 7,
  TrafficSignType_WarningSign_WATCH_PEDESTRIANS = 8,
  TrafficSignType_WarningSign_WATCH_CHILDREN = 9,
  TrafficSignType_WarningSign_TRAFFIC_LIGHTS = 10,
  TrafficSignType_WarningSign_FALING_ROCKS = 11,
  TrafficSignType_WarningSign_CROSSWIND = 12,
  TrafficSignType_WarningSign_SLIPPERY_SURFACE = 13,
  TrafficSignType_WarningSign_STEEP_MOUNTAIN_ROAD = 14,
  TrafficSignType_WarningSign_EMBANKMENT_ROAD = 15,
  TrafficSignType_WarningSign_VILLAGE = 16,
  TrafficSignType_WarningSign_TUNNEL = 17,
  TrafficSignType_WarningSign_HUMP_BACK_BRIDGE = 18,
  TrafficSignType_WarningSign_BUMPY_ROAD = 19,
  TrafficSignType_WarningSign_GUARDED_RAILWAY_CROSSING = 20,
  TrafficSignType_WarningSign_UNGUARDED_RAILWAY_CROSSING = 21,
  TrafficSignType_WarningSign_NON_MOTOR_VEHICLES = 22,
  TrafficSignType_WarningSign_ACCIDENT_BLACK_SPOT = 23,
  TrafficSignType_WarningSign_SLOW_DOWN = 24,
  TrafficSignType_WarningSign_OBSTACLES = 25,
  TrafficSignType_WarningSign_CAUTION_DRIVE = 26,
  TrafficSignType_WarningSign_ROAD_WORK = 27,
  TrafficSignType_WarningSign_SUGGESTED_SPEED = 28,
  TrafficSignType_WarningSign_REVERSIBLE_LANE = 29,
  TrafficSignType_WarningSign_ROADS_MERGE = 30,
  TrafficSignType_WarningSign_ICY_ROAD = 31,
  TrafficSignType_WarningSign_QUEUES_LIKELY = 32,
  TrafficSignType_WarningSign_TrafficSignType_WarningSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_WarningSign_TrafficSignType_WarningSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_WarningSign_IsValid(int value);
const TrafficSignType_WarningSign TrafficSignType_WarningSign_WarningSign_MIN = TrafficSignType_WarningSign_CROSSROADS;
const TrafficSignType_WarningSign TrafficSignType_WarningSign_WarningSign_MAX = TrafficSignType_WarningSign_QUEUES_LIKELY;
const int TrafficSignType_WarningSign_WarningSign_ARRAYSIZE = TrafficSignType_WarningSign_WarningSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_WarningSign_descriptor();
inline const ::std::string& TrafficSignType_WarningSign_Name(TrafficSignType_WarningSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_WarningSign_descriptor(), value);
}
inline bool TrafficSignType_WarningSign_Parse(
    const ::std::string& name, TrafficSignType_WarningSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_WarningSign>(
    TrafficSignType_WarningSign_descriptor(), name, value);
}
enum TrafficSignType_AssistSign {
  TrafficSignType_AssistSign_TIME_LIMIT = 0,
  TrafficSignType_AssistSign_SCHOOL = 1,
  TrafficSignType_AssistSign_RAMP = 2,
  TrafficSignType_AssistSign_WHOLE_ROAD = 3,
  TrafficSignType_AssistSign_FULL_SPEED_MEASUREMENT = 4,
  TrafficSignType_AssistSign_TrafficSignType_AssistSign_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSignType_AssistSign_TrafficSignType_AssistSign_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSignType_AssistSign_IsValid(int value);
const TrafficSignType_AssistSign TrafficSignType_AssistSign_AssistSign_MIN = TrafficSignType_AssistSign_TIME_LIMIT;
const TrafficSignType_AssistSign TrafficSignType_AssistSign_AssistSign_MAX = TrafficSignType_AssistSign_FULL_SPEED_MEASUREMENT;
const int TrafficSignType_AssistSign_AssistSign_ARRAYSIZE = TrafficSignType_AssistSign_AssistSign_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignType_AssistSign_descriptor();
inline const ::std::string& TrafficSignType_AssistSign_Name(TrafficSignType_AssistSign value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignType_AssistSign_descriptor(), value);
}
inline bool TrafficSignType_AssistSign_Parse(
    const ::std::string& name, TrafficSignType_AssistSign* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignType_AssistSign>(
    TrafficSignType_AssistSign_descriptor(), name, value);
}
enum Failsafe_FailSafeBlockage {
  Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN = 0,
  Failsafe_FailSafeBlockage_BLOCKAGE_FULL = 1,
  Failsafe_FailSafeBlockage_BLOCKAGE_PARTICAL = 2,
  Failsafe_FailSafeBlockage_BLOCKAGE_NONE = 3,
  Failsafe_FailSafeBlockage_Failsafe_FailSafeBlockage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeBlockage_Failsafe_FailSafeBlockage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeBlockage_IsValid(int value);
const Failsafe_FailSafeBlockage Failsafe_FailSafeBlockage_FailSafeBlockage_MIN = Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN;
const Failsafe_FailSafeBlockage Failsafe_FailSafeBlockage_FailSafeBlockage_MAX = Failsafe_FailSafeBlockage_BLOCKAGE_NONE;
const int Failsafe_FailSafeBlockage_FailSafeBlockage_ARRAYSIZE = Failsafe_FailSafeBlockage_FailSafeBlockage_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeBlockage_descriptor();
inline const ::std::string& Failsafe_FailSafeBlockage_Name(Failsafe_FailSafeBlockage value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeBlockage_descriptor(), value);
}
inline bool Failsafe_FailSafeBlockage_Parse(
    const ::std::string& name, Failsafe_FailSafeBlockage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeBlockage>(
    Failsafe_FailSafeBlockage_descriptor(), name, value);
}
enum Failsafe_FailSafeWeather {
  Failsafe_FailSafeWeather_WEATHER_UNKNOWN = 0,
  Failsafe_FailSafeWeather_WEATHER_FOG = 1,
  Failsafe_FailSafeWeather_WEATHER_RAIN = 2,
  Failsafe_FailSafeWeather_WEATHER_SNOW = 3,
  Failsafe_FailSafeWeather_WEATHER_SUNNY = 4,
  Failsafe_FailSafeWeather_Failsafe_FailSafeWeather_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeWeather_Failsafe_FailSafeWeather_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeWeather_IsValid(int value);
const Failsafe_FailSafeWeather Failsafe_FailSafeWeather_FailSafeWeather_MIN = Failsafe_FailSafeWeather_WEATHER_UNKNOWN;
const Failsafe_FailSafeWeather Failsafe_FailSafeWeather_FailSafeWeather_MAX = Failsafe_FailSafeWeather_WEATHER_SUNNY;
const int Failsafe_FailSafeWeather_FailSafeWeather_ARRAYSIZE = Failsafe_FailSafeWeather_FailSafeWeather_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeWeather_descriptor();
inline const ::std::string& Failsafe_FailSafeWeather_Name(Failsafe_FailSafeWeather value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeWeather_descriptor(), value);
}
inline bool Failsafe_FailSafeWeather_Parse(
    const ::std::string& name, Failsafe_FailSafeWeather* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeWeather>(
    Failsafe_FailSafeWeather_descriptor(), name, value);
}
enum Failsafe_FailSafeIllumination {
  Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN = 0,
  Failsafe_FailSafeIllumination_ILLUMINATION_DAY = 1,
  Failsafe_FailSafeIllumination_ILLUMINATION_DUSK = 2,
  Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT = 3,
  Failsafe_FailSafeIllumination_Failsafe_FailSafeIllumination_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeIllumination_Failsafe_FailSafeIllumination_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeIllumination_IsValid(int value);
const Failsafe_FailSafeIllumination Failsafe_FailSafeIllumination_FailSafeIllumination_MIN = Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN;
const Failsafe_FailSafeIllumination Failsafe_FailSafeIllumination_FailSafeIllumination_MAX = Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT;
const int Failsafe_FailSafeIllumination_FailSafeIllumination_ARRAYSIZE = Failsafe_FailSafeIllumination_FailSafeIllumination_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeIllumination_descriptor();
inline const ::std::string& Failsafe_FailSafeIllumination_Name(Failsafe_FailSafeIllumination value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeIllumination_descriptor(), value);
}
inline bool Failsafe_FailSafeIllumination_Parse(
    const ::std::string& name, Failsafe_FailSafeIllumination* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeIllumination>(
    Failsafe_FailSafeIllumination_descriptor(), name, value);
}
enum Failsafe_FailSafeImageLimited {
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN = 0,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_NORMAL = 1,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_LOWSUN = 2,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SPALSHES = 3,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_BLUR = 4,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SUNRAY = 5,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_FROZEN = 6,
  Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER = 7,
  Failsafe_FailSafeImageLimited_Failsafe_FailSafeImageLimited_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Failsafe_FailSafeImageLimited_Failsafe_FailSafeImageLimited_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Failsafe_FailSafeImageLimited_IsValid(int value);
const Failsafe_FailSafeImageLimited Failsafe_FailSafeImageLimited_FailSafeImageLimited_MIN = Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN;
const Failsafe_FailSafeImageLimited Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX = Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER;
const int Failsafe_FailSafeImageLimited_FailSafeImageLimited_ARRAYSIZE = Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX + 1;

const ::google::protobuf::EnumDescriptor* Failsafe_FailSafeImageLimited_descriptor();
inline const ::std::string& Failsafe_FailSafeImageLimited_Name(Failsafe_FailSafeImageLimited value) {
  return ::google::protobuf::internal::NameOfEnum(
    Failsafe_FailSafeImageLimited_descriptor(), value);
}
inline bool Failsafe_FailSafeImageLimited_Parse(
    const ::std::string& name, Failsafe_FailSafeImageLimited* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Failsafe_FailSafeImageLimited>(
    Failsafe_FailSafeImageLimited_descriptor(), name, value);
}
enum MeasuringStatus0 {
  MS_OLD = 0,
  MS_NEW = 1,
  MeasuringStatus0_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus0_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus0_IsValid(int value);
const MeasuringStatus0 MeasuringStatus0_MIN = MS_OLD;
const MeasuringStatus0 MeasuringStatus0_MAX = MS_NEW;
const int MeasuringStatus0_ARRAYSIZE = MeasuringStatus0_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus0_descriptor();
inline const ::std::string& MeasuringStatus0_Name(MeasuringStatus0 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus0_descriptor(), value);
}
inline bool MeasuringStatus0_Parse(
    const ::std::string& name, MeasuringStatus0* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus0>(
    MeasuringStatus0_descriptor(), name, value);
}
enum MeasuringStatus1 {
  MS_PREDICTED = 0,
  MS_MEASURED = 1,
  MeasuringStatus1_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus1_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus1_IsValid(int value);
const MeasuringStatus1 MeasuringStatus1_MIN = MS_PREDICTED;
const MeasuringStatus1 MeasuringStatus1_MAX = MS_MEASURED;
const int MeasuringStatus1_ARRAYSIZE = MeasuringStatus1_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus1_descriptor();
inline const ::std::string& MeasuringStatus1_Name(MeasuringStatus1 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus1_descriptor(), value);
}
inline bool MeasuringStatus1_Parse(
    const ::std::string& name, MeasuringStatus1* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus1>(
    MeasuringStatus1_descriptor(), name, value);
}
enum MeasuringStatus2 {
  MS_INVALID = 0,
  MS_VALID = 1,
  MeasuringStatus2_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MeasuringStatus2_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MeasuringStatus2_IsValid(int value);
const MeasuringStatus2 MeasuringStatus2_MIN = MS_INVALID;
const MeasuringStatus2 MeasuringStatus2_MAX = MS_VALID;
const int MeasuringStatus2_ARRAYSIZE = MeasuringStatus2_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeasuringStatus2_descriptor();
inline const ::std::string& MeasuringStatus2_Name(MeasuringStatus2 value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeasuringStatus2_descriptor(), value);
}
inline bool MeasuringStatus2_Parse(
    const ::std::string& name, MeasuringStatus2* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeasuringStatus2>(
    MeasuringStatus2_descriptor(), name, value);
}
enum MotionCategory {
  MC_UNFILLED = 0,
  MC_UNDEFINED = 1,
  MC_PASSING = 2,
  MC_PASSING_IN = 3,
  MC_PASSING_OUT = 4,
  MC_CLOSE_CUT_IN = 5,
  MC_MOVING_IN = 6,
  MC_MOVING_OUT = 7,
  MC_CROSSING = 8,
  MC_LTAP = 9,
  MC_RTAP = 10,
  MC_MOVING = 11,
  MC_PRECEEDING = 12,
  MC_ONCOMING = 13,
  MotionCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionCategory_IsValid(int value);
const MotionCategory MotionCategory_MIN = MC_UNFILLED;
const MotionCategory MotionCategory_MAX = MC_ONCOMING;
const int MotionCategory_ARRAYSIZE = MotionCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionCategory_descriptor();
inline const ::std::string& MotionCategory_Name(MotionCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionCategory_descriptor(), value);
}
inline bool MotionCategory_Parse(
    const ::std::string& name, MotionCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionCategory>(
    MotionCategory_descriptor(), name, value);
}
enum MotionOrientation {
  MO_INVALID = 0,
  MO_DRIFTING_RIGHT = 1,
  MO_CROSSING_RIGHT = 3,
  MO_OC_DRIFTING_RIGHT = 5,
  MO_ONCOMING = 6,
  MO_OC_DRIFTING_LEFT = 7,
  MO_CROSSING_LEFT = 9,
  MO_DRIFTING_LEFT = 11,
  MO_PRECEEDING = 12,
  MO_UNKNOWN = 13,
  MotionOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionOrientation_IsValid(int value);
const MotionOrientation MotionOrientation_MIN = MO_INVALID;
const MotionOrientation MotionOrientation_MAX = MO_UNKNOWN;
const int MotionOrientation_ARRAYSIZE = MotionOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionOrientation_descriptor();
inline const ::std::string& MotionOrientation_Name(MotionOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionOrientation_descriptor(), value);
}
inline bool MotionOrientation_Parse(
    const ::std::string& name, MotionOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionOrientation>(
    MotionOrientation_descriptor(), name, value);
}
enum VisibilitySide {
  VS_NOT_VISIBLE = 0,
  VS_FRONT = 1,
  VS_REAR = 2,
  VisibilitySide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VisibilitySide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VisibilitySide_IsValid(int value);
const VisibilitySide VisibilitySide_MIN = VS_NOT_VISIBLE;
const VisibilitySide VisibilitySide_MAX = VS_REAR;
const int VisibilitySide_ARRAYSIZE = VisibilitySide_MAX + 1;

const ::google::protobuf::EnumDescriptor* VisibilitySide_descriptor();
inline const ::std::string& VisibilitySide_Name(VisibilitySide value) {
  return ::google::protobuf::internal::NameOfEnum(
    VisibilitySide_descriptor(), value);
}
inline bool VisibilitySide_Parse(
    const ::std::string& name, VisibilitySide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisibilitySide>(
    VisibilitySide_descriptor(), name, value);
}
enum MotionStatus {
  MOTION_STATUS_UNKNOWN = 0,
  MOTION_STATUS_PARKED = 1,
  MOTION_STATUS_STOPPED = 2,
  MOTION_STATUS_MOVING = 3,
  MOTION_STATUS_ONCOMING = 4,
  MOTION_STATUS_CROSSING = 5,
  MotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionStatus_IsValid(int value);
const MotionStatus MotionStatus_MIN = MOTION_STATUS_UNKNOWN;
const MotionStatus MotionStatus_MAX = MOTION_STATUS_CROSSING;
const int MotionStatus_ARRAYSIZE = MotionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionStatus_descriptor();
inline const ::std::string& MotionStatus_Name(MotionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionStatus_descriptor(), value);
}
inline bool MotionStatus_Parse(
    const ::std::string& name, MotionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionStatus>(
    MotionStatus_descriptor(), name, value);
}
enum CutInCutOut {
  CUT_IN_CUT_OUT_UNKNOWN = 0,
  CUT_IN_CUT_OUT_HOST_CUT_IN_LEFT = 1,
  CUT_IN_CUT_OUT_HOST_CUT_IN_RIGHT = 2,
  CUT_IN_CUT_OUT_HOST_CUT_OUT_LEFT = 3,
  CUT_IN_CUT_OUT_HOST_CUT_OUT_RIGHT = 4,
  CUT_IN_CUT_OUT_NO_CUT_IN_OUT = 5,
  CutInCutOut_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CutInCutOut_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CutInCutOut_IsValid(int value);
const CutInCutOut CutInCutOut_MIN = CUT_IN_CUT_OUT_UNKNOWN;
const CutInCutOut CutInCutOut_MAX = CUT_IN_CUT_OUT_NO_CUT_IN_OUT;
const int CutInCutOut_ARRAYSIZE = CutInCutOut_MAX + 1;

const ::google::protobuf::EnumDescriptor* CutInCutOut_descriptor();
inline const ::std::string& CutInCutOut_Name(CutInCutOut value) {
  return ::google::protobuf::internal::NameOfEnum(
    CutInCutOut_descriptor(), value);
}
inline bool CutInCutOut_Parse(
    const ::std::string& name, CutInCutOut* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CutInCutOut>(
    CutInCutOut_descriptor(), name, value);
}
enum CipvLost {
  CipvLost_NO_LOSS = 0,
  CipvLost_LOST_TARGET_FOV_OUT = 1,
  CipvLost_LOST_TARGET_FOV_IN = 2,
  CipvLost_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CipvLost_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CipvLost_IsValid(int value);
const CipvLost CipvLost_MIN = CipvLost_NO_LOSS;
const CipvLost CipvLost_MAX = CipvLost_LOST_TARGET_FOV_IN;
const int CipvLost_ARRAYSIZE = CipvLost_MAX + 1;

const ::google::protobuf::EnumDescriptor* CipvLost_descriptor();
inline const ::std::string& CipvLost_Name(CipvLost value) {
  return ::google::protobuf::internal::NameOfEnum(
    CipvLost_descriptor(), value);
}
inline bool CipvLost_Parse(
    const ::std::string& name, CipvLost* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CipvLost>(
    CipvLost_descriptor(), name, value);
}
enum AllowAcc {
  AllowAcc_FREE_SPACE = 0,
  AllowAcc_SPACE_NOT_FREE = 1,
  AllowAcc_FREE_SPACE_UNKNOWN = 2,
  AllowAcc_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AllowAcc_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AllowAcc_IsValid(int value);
const AllowAcc AllowAcc_MIN = AllowAcc_FREE_SPACE;
const AllowAcc AllowAcc_MAX = AllowAcc_FREE_SPACE_UNKNOWN;
const int AllowAcc_ARRAYSIZE = AllowAcc_MAX + 1;

const ::google::protobuf::EnumDescriptor* AllowAcc_descriptor();
inline const ::std::string& AllowAcc_Name(AllowAcc value) {
  return ::google::protobuf::internal::NameOfEnum(
    AllowAcc_descriptor(), value);
}
inline bool AllowAcc_Parse(
    const ::std::string& name, AllowAcc* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AllowAcc>(
    AllowAcc_descriptor(), name, value);
}
// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Header_ProtobufVersion ProtobufVersion;
  static const ProtobufVersion V_1_0_0 =
    Header_ProtobufVersion_V_1_0_0;
  static const ProtobufVersion V_1_0_1 =
    Header_ProtobufVersion_V_1_0_1;
  static const ProtobufVersion V_1_0_2 =
    Header_ProtobufVersion_V_1_0_2;
  static const ProtobufVersion V_1_0_3 =
    Header_ProtobufVersion_V_1_0_3;
  static const ProtobufVersion V_1_0_4 =
    Header_ProtobufVersion_V_1_0_4;
  static const ProtobufVersion V_1_0_5 =
    Header_ProtobufVersion_V_1_0_5;
  static const ProtobufVersion V_1_0_6 =
    Header_ProtobufVersion_V_1_0_6;
  static const ProtobufVersion V_1_0_7 =
    Header_ProtobufVersion_V_1_0_7;
  static const ProtobufVersion V_1_0_8 =
    Header_ProtobufVersion_V_1_0_8;
  static const ProtobufVersion V_1_0_9 =
    Header_ProtobufVersion_V_1_0_9;
  static const ProtobufVersion V_1_0_10 =
    Header_ProtobufVersion_V_1_0_10;
  static const ProtobufVersion V_1_0_11 =
    Header_ProtobufVersion_V_1_0_11;
  static const ProtobufVersion V_1_0_12 =
    Header_ProtobufVersion_V_1_0_12;
  static const ProtobufVersion V_1_0_13 =
    Header_ProtobufVersion_V_1_0_13;
  static const ProtobufVersion V_1_0_14 =
    Header_ProtobufVersion_V_1_0_14;
  static const ProtobufVersion CURRENT_VERSION =
    Header_ProtobufVersion_CURRENT_VERSION;
  static inline bool ProtobufVersion_IsValid(int value) {
    return Header_ProtobufVersion_IsValid(value);
  }
  static const ProtobufVersion ProtobufVersion_MIN =
    Header_ProtobufVersion_ProtobufVersion_MIN;
  static const ProtobufVersion ProtobufVersion_MAX =
    Header_ProtobufVersion_ProtobufVersion_MAX;
  static const int ProtobufVersion_ARRAYSIZE =
    Header_ProtobufVersion_ProtobufVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtobufVersion_descriptor() {
    return Header_ProtobufVersion_descriptor();
  }
  static inline const ::std::string& ProtobufVersion_Name(ProtobufVersion value) {
    return Header_ProtobufVersion_Name(value);
  }
  static inline bool ProtobufVersion_Parse(const ::std::string& name,
      ProtobufVersion* value) {
    return Header_ProtobufVersion_Parse(name, value);
  }

  typedef Header_ObjectVersion ObjectVersion;
  static const ObjectVersion OD_V_1_0 =
    Header_ObjectVersion_OD_V_1_0;
  static const ObjectVersion OD_V_1_1 =
    Header_ObjectVersion_OD_V_1_1;
  static const ObjectVersion OD_CURRENT_VERSION =
    Header_ObjectVersion_OD_CURRENT_VERSION;
  static inline bool ObjectVersion_IsValid(int value) {
    return Header_ObjectVersion_IsValid(value);
  }
  static const ObjectVersion ObjectVersion_MIN =
    Header_ObjectVersion_ObjectVersion_MIN;
  static const ObjectVersion ObjectVersion_MAX =
    Header_ObjectVersion_ObjectVersion_MAX;
  static const int ObjectVersion_ARRAYSIZE =
    Header_ObjectVersion_ObjectVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectVersion_descriptor() {
    return Header_ObjectVersion_descriptor();
  }
  static inline const ::std::string& ObjectVersion_Name(ObjectVersion value) {
    return Header_ObjectVersion_Name(value);
  }
  static inline bool ObjectVersion_Parse(const ::std::string& name,
      ObjectVersion* value) {
    return Header_ObjectVersion_Parse(name, value);
  }

  typedef Header_TrafficLightStructVersion TrafficLightStructVersion;
  static const TrafficLightStructVersion TFL_STRUCT_V_1_0 =
    Header_TrafficLightStructVersion_TFL_STRUCT_V_1_0;
  static const TrafficLightStructVersion TFL_STRUCT_V_1_1 =
    Header_TrafficLightStructVersion_TFL_STRUCT_V_1_1;
  static const TrafficLightStructVersion TFL_STRUCT_CURRENT_VERSION =
    Header_TrafficLightStructVersion_TFL_STRUCT_CURRENT_VERSION;
  static inline bool TrafficLightStructVersion_IsValid(int value) {
    return Header_TrafficLightStructVersion_IsValid(value);
  }
  static const TrafficLightStructVersion TrafficLightStructVersion_MIN =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_MIN;
  static const TrafficLightStructVersion TrafficLightStructVersion_MAX =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_MAX;
  static const int TrafficLightStructVersion_ARRAYSIZE =
    Header_TrafficLightStructVersion_TrafficLightStructVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficLightStructVersion_descriptor() {
    return Header_TrafficLightStructVersion_descriptor();
  }
  static inline const ::std::string& TrafficLightStructVersion_Name(TrafficLightStructVersion value) {
    return Header_TrafficLightStructVersion_Name(value);
  }
  static inline bool TrafficLightStructVersion_Parse(const ::std::string& name,
      TrafficLightStructVersion* value) {
    return Header_TrafficLightStructVersion_Parse(name, value);
  }

  typedef Header_TrafficLightSpotVersion TrafficLightSpotVersion;
  static const TrafficLightSpotVersion TFL_SPOT_V_1_0 =
    Header_TrafficLightSpotVersion_TFL_SPOT_V_1_0;
  static const TrafficLightSpotVersion TFL_SPOT_V_1_1 =
    Header_TrafficLightSpotVersion_TFL_SPOT_V_1_1;
  static const TrafficLightSpotVersion TFL_SPOT_CURRENT_VERSION =
    Header_TrafficLightSpotVersion_TFL_SPOT_CURRENT_VERSION;
  static inline bool TrafficLightSpotVersion_IsValid(int value) {
    return Header_TrafficLightSpotVersion_IsValid(value);
  }
  static const TrafficLightSpotVersion TrafficLightSpotVersion_MIN =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MIN;
  static const TrafficLightSpotVersion TrafficLightSpotVersion_MAX =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_MAX;
  static const int TrafficLightSpotVersion_ARRAYSIZE =
    Header_TrafficLightSpotVersion_TrafficLightSpotVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficLightSpotVersion_descriptor() {
    return Header_TrafficLightSpotVersion_descriptor();
  }
  static inline const ::std::string& TrafficLightSpotVersion_Name(TrafficLightSpotVersion value) {
    return Header_TrafficLightSpotVersion_Name(value);
  }
  static inline bool TrafficLightSpotVersion_Parse(const ::std::string& name,
      TrafficLightSpotVersion* value) {
    return Header_TrafficLightSpotVersion_Parse(name, value);
  }

  typedef Header_TrafficSignVersion TrafficSignVersion;
  static const TrafficSignVersion TSR_V_1_0 =
    Header_TrafficSignVersion_TSR_V_1_0;
  static const TrafficSignVersion TSR_V_1_1 =
    Header_TrafficSignVersion_TSR_V_1_1;
  static const TrafficSignVersion TSR_CURRENT_VERSION =
    Header_TrafficSignVersion_TSR_CURRENT_VERSION;
  static inline bool TrafficSignVersion_IsValid(int value) {
    return Header_TrafficSignVersion_IsValid(value);
  }
  static const TrafficSignVersion TrafficSignVersion_MIN =
    Header_TrafficSignVersion_TrafficSignVersion_MIN;
  static const TrafficSignVersion TrafficSignVersion_MAX =
    Header_TrafficSignVersion_TrafficSignVersion_MAX;
  static const int TrafficSignVersion_ARRAYSIZE =
    Header_TrafficSignVersion_TrafficSignVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSignVersion_descriptor() {
    return Header_TrafficSignVersion_descriptor();
  }
  static inline const ::std::string& TrafficSignVersion_Name(TrafficSignVersion value) {
    return Header_TrafficSignVersion_Name(value);
  }
  static inline bool TrafficSignVersion_Parse(const ::std::string& name,
      TrafficSignVersion* value) {
    return Header_TrafficSignVersion_Parse(name, value);
  }

  typedef Header_FailSafeVersion FailSafeVersion;
  static const FailSafeVersion FS_V_1_0 =
    Header_FailSafeVersion_FS_V_1_0;
  static const FailSafeVersion FS_V_1_1 =
    Header_FailSafeVersion_FS_V_1_1;
  static const FailSafeVersion FS_CURRENT_VERSION =
    Header_FailSafeVersion_FS_CURRENT_VERSION;
  static inline bool FailSafeVersion_IsValid(int value) {
    return Header_FailSafeVersion_IsValid(value);
  }
  static const FailSafeVersion FailSafeVersion_MIN =
    Header_FailSafeVersion_FailSafeVersion_MIN;
  static const FailSafeVersion FailSafeVersion_MAX =
    Header_FailSafeVersion_FailSafeVersion_MAX;
  static const int FailSafeVersion_ARRAYSIZE =
    Header_FailSafeVersion_FailSafeVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeVersion_descriptor() {
    return Header_FailSafeVersion_descriptor();
  }
  static inline const ::std::string& FailSafeVersion_Name(FailSafeVersion value) {
    return Header_FailSafeVersion_Name(value);
  }
  static inline bool FailSafeVersion_Parse(const ::std::string& name,
      FailSafeVersion* value) {
    return Header_FailSafeVersion_Parse(name, value);
  }

  typedef Header_LaneVersion LaneVersion;
  static const LaneVersion LANE_V_1_0 =
    Header_LaneVersion_LANE_V_1_0;
  static const LaneVersion LANE_V_1_1 =
    Header_LaneVersion_LANE_V_1_1;
  static const LaneVersion LANE_CURRENT_VERSION =
    Header_LaneVersion_LANE_CURRENT_VERSION;
  static inline bool LaneVersion_IsValid(int value) {
    return Header_LaneVersion_IsValid(value);
  }
  static const LaneVersion LaneVersion_MIN =
    Header_LaneVersion_LaneVersion_MIN;
  static const LaneVersion LaneVersion_MAX =
    Header_LaneVersion_LaneVersion_MAX;
  static const int LaneVersion_ARRAYSIZE =
    Header_LaneVersion_LaneVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneVersion_descriptor() {
    return Header_LaneVersion_descriptor();
  }
  static inline const ::std::string& LaneVersion_Name(LaneVersion value) {
    return Header_LaneVersion_Name(value);
  }
  static inline bool LaneVersion_Parse(const ::std::string& name,
      LaneVersion* value) {
    return Header_LaneVersion_Parse(name, value);
  }

  typedef Header_RoadMarkVersion RoadMarkVersion;
  static const RoadMarkVersion RM_V_1_0 =
    Header_RoadMarkVersion_RM_V_1_0;
  static const RoadMarkVersion RM_V_1_1 =
    Header_RoadMarkVersion_RM_V_1_1;
  static const RoadMarkVersion RM_CURRENT_VERSION =
    Header_RoadMarkVersion_RM_CURRENT_VERSION;
  static inline bool RoadMarkVersion_IsValid(int value) {
    return Header_RoadMarkVersion_IsValid(value);
  }
  static const RoadMarkVersion RoadMarkVersion_MIN =
    Header_RoadMarkVersion_RoadMarkVersion_MIN;
  static const RoadMarkVersion RoadMarkVersion_MAX =
    Header_RoadMarkVersion_RoadMarkVersion_MAX;
  static const int RoadMarkVersion_ARRAYSIZE =
    Header_RoadMarkVersion_RoadMarkVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadMarkVersion_descriptor() {
    return Header_RoadMarkVersion_descriptor();
  }
  static inline const ::std::string& RoadMarkVersion_Name(RoadMarkVersion value) {
    return Header_RoadMarkVersion_Name(value);
  }
  static inline bool RoadMarkVersion_Parse(const ::std::string& name,
      RoadMarkVersion* value) {
    return Header_RoadMarkVersion_Parse(name, value);
  }

  typedef Header_FreeSpaceVersion FreeSpaceVersion;
  static const FreeSpaceVersion FSP_V_1_0 =
    Header_FreeSpaceVersion_FSP_V_1_0;
  static const FreeSpaceVersion FSP_V_1_1 =
    Header_FreeSpaceVersion_FSP_V_1_1;
  static const FreeSpaceVersion FSP_CURRENT_VERSION =
    Header_FreeSpaceVersion_FSP_CURRENT_VERSION;
  static inline bool FreeSpaceVersion_IsValid(int value) {
    return Header_FreeSpaceVersion_IsValid(value);
  }
  static const FreeSpaceVersion FreeSpaceVersion_MIN =
    Header_FreeSpaceVersion_FreeSpaceVersion_MIN;
  static const FreeSpaceVersion FreeSpaceVersion_MAX =
    Header_FreeSpaceVersion_FreeSpaceVersion_MAX;
  static const int FreeSpaceVersion_ARRAYSIZE =
    Header_FreeSpaceVersion_FreeSpaceVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FreeSpaceVersion_descriptor() {
    return Header_FreeSpaceVersion_descriptor();
  }
  static inline const ::std::string& FreeSpaceVersion_Name(FreeSpaceVersion value) {
    return Header_FreeSpaceVersion_Name(value);
  }
  static inline bool FreeSpaceVersion_Parse(const ::std::string& name,
      FreeSpaceVersion* value) {
    return Header_FreeSpaceVersion_Parse(name, value);
  }

  typedef Header_BarricadeVersion BarricadeVersion;
  static const BarricadeVersion BA_V_1_0 =
    Header_BarricadeVersion_BA_V_1_0;
  static const BarricadeVersion BA_CURRENT_VERSION =
    Header_BarricadeVersion_BA_CURRENT_VERSION;
  static inline bool BarricadeVersion_IsValid(int value) {
    return Header_BarricadeVersion_IsValid(value);
  }
  static const BarricadeVersion BarricadeVersion_MIN =
    Header_BarricadeVersion_BarricadeVersion_MIN;
  static const BarricadeVersion BarricadeVersion_MAX =
    Header_BarricadeVersion_BarricadeVersion_MAX;
  static const int BarricadeVersion_ARRAYSIZE =
    Header_BarricadeVersion_BarricadeVersion_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BarricadeVersion_descriptor() {
    return Header_BarricadeVersion_descriptor();
  }
  static inline const ::std::string& BarricadeVersion_Name(BarricadeVersion value) {
    return Header_BarricadeVersion_Name(value);
  }
  static inline bool BarricadeVersion_Parse(const ::std::string& name,
      BarricadeVersion* value) {
    return Header_BarricadeVersion_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string perception_version = 3;
  void clear_perception_version();
  static const int kPerceptionVersionFieldNumber = 3;
  const ::std::string& perception_version() const;
  void set_perception_version(const ::std::string& value);
  #if LANG_CXX11
  void set_perception_version(::std::string&& value);
  #endif
  void set_perception_version(const char* value);
  void set_perception_version(const char* value, size_t size);
  ::std::string* mutable_perception_version();
  ::std::string* release_perception_version();
  void set_allocated_perception_version(::std::string* perception_version);

  // int64 frame_index = 1;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.Header.ProtobufVersion protobuf_version = 4;
  void clear_protobuf_version();
  static const int kProtobufVersionFieldNumber = 4;
  ::calmcar::perception::Header_ProtobufVersion protobuf_version() const;
  void set_protobuf_version(::calmcar::perception::Header_ProtobufVersion value);

  // .calmcar.perception.Header.ObjectVersion object_version = 5;
  void clear_object_version();
  static const int kObjectVersionFieldNumber = 5;
  ::calmcar::perception::Header_ObjectVersion object_version() const;
  void set_object_version(::calmcar::perception::Header_ObjectVersion value);

  // .calmcar.perception.Header.TrafficLightStructVersion tfl_struct_version = 6;
  void clear_tfl_struct_version();
  static const int kTflStructVersionFieldNumber = 6;
  ::calmcar::perception::Header_TrafficLightStructVersion tfl_struct_version() const;
  void set_tfl_struct_version(::calmcar::perception::Header_TrafficLightStructVersion value);

  // .calmcar.perception.Header.TrafficLightSpotVersion tfl_spot_version = 7;
  void clear_tfl_spot_version();
  static const int kTflSpotVersionFieldNumber = 7;
  ::calmcar::perception::Header_TrafficLightSpotVersion tfl_spot_version() const;
  void set_tfl_spot_version(::calmcar::perception::Header_TrafficLightSpotVersion value);

  // .calmcar.perception.Header.TrafficSignVersion traffic_sign_version = 8;
  void clear_traffic_sign_version();
  static const int kTrafficSignVersionFieldNumber = 8;
  ::calmcar::perception::Header_TrafficSignVersion traffic_sign_version() const;
  void set_traffic_sign_version(::calmcar::perception::Header_TrafficSignVersion value);

  // .calmcar.perception.Header.FailSafeVersion fail_safe_version = 9;
  void clear_fail_safe_version();
  static const int kFailSafeVersionFieldNumber = 9;
  ::calmcar::perception::Header_FailSafeVersion fail_safe_version() const;
  void set_fail_safe_version(::calmcar::perception::Header_FailSafeVersion value);

  // .calmcar.perception.Header.LaneVersion lane_version = 10;
  void clear_lane_version();
  static const int kLaneVersionFieldNumber = 10;
  ::calmcar::perception::Header_LaneVersion lane_version() const;
  void set_lane_version(::calmcar::perception::Header_LaneVersion value);

  // .calmcar.perception.Header.RoadMarkVersion road_mark_version = 11;
  void clear_road_mark_version();
  static const int kRoadMarkVersionFieldNumber = 11;
  ::calmcar::perception::Header_RoadMarkVersion road_mark_version() const;
  void set_road_mark_version(::calmcar::perception::Header_RoadMarkVersion value);

  // .calmcar.perception.Header.FreeSpaceVersion free_space_version = 12;
  void clear_free_space_version();
  static const int kFreeSpaceVersionFieldNumber = 12;
  ::calmcar::perception::Header_FreeSpaceVersion free_space_version() const;
  void set_free_space_version(::calmcar::perception::Header_FreeSpaceVersion value);

  // .calmcar.perception.Header.BarricadeVersion barricade_version = 13;
  void clear_barricade_version();
  static const int kBarricadeVersionFieldNumber = 13;
  ::calmcar::perception::Header_BarricadeVersion barricade_version() const;
  void set_barricade_version(::calmcar::perception::Header_BarricadeVersion value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr perception_version_;
  ::google::protobuf::int64 frame_index_;
  ::google::protobuf::int64 timestamp_;
  int protobuf_version_;
  int object_version_;
  int tfl_struct_version_;
  int tfl_spot_version_;
  int traffic_sign_version_;
  int fail_safe_version_;
  int lane_version_;
  int road_mark_version_;
  int free_space_version_;
  int barricade_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeasuringStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.MeasuringStatus) */ {
 public:
  MeasuringStatus();
  virtual ~MeasuringStatus();

  MeasuringStatus(const MeasuringStatus& from);

  inline MeasuringStatus& operator=(const MeasuringStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasuringStatus(MeasuringStatus&& from) noexcept
    : MeasuringStatus() {
    *this = ::std::move(from);
  }

  inline MeasuringStatus& operator=(MeasuringStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasuringStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeasuringStatus* internal_default_instance() {
    return reinterpret_cast<const MeasuringStatus*>(
               &_MeasuringStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MeasuringStatus* other);
  friend void swap(MeasuringStatus& a, MeasuringStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasuringStatus* New() const final {
    return CreateMaybeMessage<MeasuringStatus>(NULL);
  }

  MeasuringStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MeasuringStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MeasuringStatus& from);
  void MergeFrom(const MeasuringStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeasuringStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .calmcar.perception.MeasuringStatus0 measuring_status_0 = 1;
  void clear_measuring_status_0();
  static const int kMeasuringStatus0FieldNumber = 1;
  ::calmcar::perception::MeasuringStatus0 measuring_status_0() const;
  void set_measuring_status_0(::calmcar::perception::MeasuringStatus0 value);

  // .calmcar.perception.MeasuringStatus1 measuring_status_1 = 2;
  void clear_measuring_status_1();
  static const int kMeasuringStatus1FieldNumber = 2;
  ::calmcar::perception::MeasuringStatus1 measuring_status_1() const;
  void set_measuring_status_1(::calmcar::perception::MeasuringStatus1 value);

  // .calmcar.perception.MeasuringStatus2 measuring_status_2 = 3;
  void clear_measuring_status_2();
  static const int kMeasuringStatus2FieldNumber = 3;
  ::calmcar::perception::MeasuringStatus2 measuring_status_2() const;
  void set_measuring_status_2(::calmcar::perception::MeasuringStatus2 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.MeasuringStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int measuring_status_0_;
  int measuring_status_1_;
  int measuring_status_2_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Object) */ {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(Object&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Object* other);
  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Object* New() const final {
    return CreateMaybeMessage<Object>(NULL);
  }

  Object* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // string subclass_name = 8;
  void clear_subclass_name();
  static const int kSubclassNameFieldNumber = 8;
  const ::std::string& subclass_name() const;
  void set_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subclass_name(::std::string&& value);
  #endif
  void set_subclass_name(const char* value);
  void set_subclass_name(const char* value, size_t size);
  ::std::string* mutable_subclass_name();
  ::std::string* release_subclass_name();
  void set_allocated_subclass_name(::std::string* subclass_name);

  // .calmcar.perception.Rect bbox = 10;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 10;
  private:
  const ::calmcar::perception::Rect& _internal_bbox() const;
  public:
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // .calmcar.perception.MeasuringStatus measuring_status = 59;
  bool has_measuring_status() const;
  void clear_measuring_status();
  static const int kMeasuringStatusFieldNumber = 59;
  private:
  const ::calmcar::perception::MeasuringStatus& _internal_measuring_status() const;
  public:
  const ::calmcar::perception::MeasuringStatus& measuring_status() const;
  ::calmcar::perception::MeasuringStatus* release_measuring_status();
  ::calmcar::perception::MeasuringStatus* mutable_measuring_status();
  void set_allocated_measuring_status(::calmcar::perception::MeasuringStatus* measuring_status);

  // int64 frame_index = 1;
  void clear_frame_index();
  static const int kFrameIndexFieldNumber = 1;
  ::google::protobuf::int64 frame_index() const;
  void set_frame_index(::google::protobuf::int64 value);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 class_ = 5;
  void clear_class_();
  static const int kClassFieldNumber = 5;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 3;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 3;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float confidence = 9;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 9;
  float confidence() const;
  void set_confidence(float value);

  // int64 subclass = 7;
  void clear_subclass();
  static const int kSubclassFieldNumber = 7;
  ::google::protobuf::int64 subclass() const;
  void set_subclass(::google::protobuf::int64 value);

  // float length = 11;
  void clear_length();
  static const int kLengthFieldNumber = 11;
  float length() const;
  void set_length(float value);

  // float length_std = 12;
  void clear_length_std();
  static const int kLengthStdFieldNumber = 12;
  float length_std() const;
  void set_length_std(float value);

  // float width = 13;
  void clear_width();
  static const int kWidthFieldNumber = 13;
  float width() const;
  void set_width(float value);

  // float width_std = 14;
  void clear_width_std();
  static const int kWidthStdFieldNumber = 14;
  float width_std() const;
  void set_width_std(float value);

  // float height = 15;
  void clear_height();
  static const int kHeightFieldNumber = 15;
  float height() const;
  void set_height(float value);

  // float height_std = 16;
  void clear_height_std();
  static const int kHeightStdFieldNumber = 16;
  float height_std() const;
  void set_height_std(float value);

  // int64 age_count = 17;
  void clear_age_count();
  static const int kAgeCountFieldNumber = 17;
  ::google::protobuf::int64 age_count() const;
  void set_age_count(::google::protobuf::int64 value);

  // float age_seconds = 18;
  void clear_age_seconds();
  static const int kAgeSecondsFieldNumber = 18;
  float age_seconds() const;
  void set_age_seconds(float value);

  // .calmcar.perception.VisibilitySide visibility_side = 19;
  void clear_visibility_side();
  static const int kVisibilitySideFieldNumber = 19;
  ::calmcar::perception::VisibilitySide visibility_side() const;
  void set_visibility_side(::calmcar::perception::VisibilitySide value);

  // float lat_distance = 20;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 20;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float lat_distance_std = 21;
  void clear_lat_distance_std();
  static const int kLatDistanceStdFieldNumber = 21;
  float lat_distance_std() const;
  void set_lat_distance_std(float value);

  // float long_distance = 22;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 22;
  float long_distance() const;
  void set_long_distance(float value);

  // float long_distance_std = 23;
  void clear_long_distance_std();
  static const int kLongDistanceStdFieldNumber = 23;
  float long_distance_std() const;
  void set_long_distance_std(float value);

  // float relative_lat_velocity = 24;
  void clear_relative_lat_velocity();
  static const int kRelativeLatVelocityFieldNumber = 24;
  float relative_lat_velocity() const;
  void set_relative_lat_velocity(float value);

  // float relative_lat_velocity_std = 25;
  void clear_relative_lat_velocity_std();
  static const int kRelativeLatVelocityStdFieldNumber = 25;
  float relative_lat_velocity_std() const;
  void set_relative_lat_velocity_std(float value);

  // float relative_long_velocity = 26;
  void clear_relative_long_velocity();
  static const int kRelativeLongVelocityFieldNumber = 26;
  float relative_long_velocity() const;
  void set_relative_long_velocity(float value);

  // float relative_long_velocity_std = 27;
  void clear_relative_long_velocity_std();
  static const int kRelativeLongVelocityStdFieldNumber = 27;
  float relative_long_velocity_std() const;
  void set_relative_long_velocity_std(float value);

  // float abs_lat_velocity = 28;
  void clear_abs_lat_velocity();
  static const int kAbsLatVelocityFieldNumber = 28;
  float abs_lat_velocity() const;
  void set_abs_lat_velocity(float value);

  // float abs_lat_velocity_std = 29;
  void clear_abs_lat_velocity_std();
  static const int kAbsLatVelocityStdFieldNumber = 29;
  float abs_lat_velocity_std() const;
  void set_abs_lat_velocity_std(float value);

  // float abs_long_velocity = 30;
  void clear_abs_long_velocity();
  static const int kAbsLongVelocityFieldNumber = 30;
  float abs_long_velocity() const;
  void set_abs_long_velocity(float value);

  // float abs_long_velocity_std = 31;
  void clear_abs_long_velocity_std();
  static const int kAbsLongVelocityStdFieldNumber = 31;
  float abs_long_velocity_std() const;
  void set_abs_long_velocity_std(float value);

  // float relative_lat_acc = 32;
  void clear_relative_lat_acc();
  static const int kRelativeLatAccFieldNumber = 32;
  float relative_lat_acc() const;
  void set_relative_lat_acc(float value);

  // float relative_lat_acc_std = 33;
  void clear_relative_lat_acc_std();
  static const int kRelativeLatAccStdFieldNumber = 33;
  float relative_lat_acc_std() const;
  void set_relative_lat_acc_std(float value);

  // float relative_long_acc = 34;
  void clear_relative_long_acc();
  static const int kRelativeLongAccFieldNumber = 34;
  float relative_long_acc() const;
  void set_relative_long_acc(float value);

  // float relative_long_acc_std = 35;
  void clear_relative_long_acc_std();
  static const int kRelativeLongAccStdFieldNumber = 35;
  float relative_long_acc_std() const;
  void set_relative_long_acc_std(float value);

  // float abs_lat_acc = 36;
  void clear_abs_lat_acc();
  static const int kAbsLatAccFieldNumber = 36;
  float abs_lat_acc() const;
  void set_abs_lat_acc(float value);

  // float abs_lat_acc_std = 37;
  void clear_abs_lat_acc_std();
  static const int kAbsLatAccStdFieldNumber = 37;
  float abs_lat_acc_std() const;
  void set_abs_lat_acc_std(float value);

  // float abs_long_acc = 38;
  void clear_abs_long_acc();
  static const int kAbsLongAccFieldNumber = 38;
  float abs_long_acc() const;
  void set_abs_long_acc(float value);

  // float abs_long_acc_std = 39;
  void clear_abs_long_acc_std();
  static const int kAbsLongAccStdFieldNumber = 39;
  float abs_long_acc_std() const;
  void set_abs_long_acc_std(float value);

  // float abs_speed = 40;
  void clear_abs_speed();
  static const int kAbsSpeedFieldNumber = 40;
  float abs_speed() const;
  void set_abs_speed(float value);

  // float abs_speed_std = 41;
  void clear_abs_speed_std();
  static const int kAbsSpeedStdFieldNumber = 41;
  float abs_speed_std() const;
  void set_abs_speed_std(float value);

  // float abs_acceleration = 42;
  void clear_abs_acceleration();
  static const int kAbsAccelerationFieldNumber = 42;
  float abs_acceleration() const;
  void set_abs_acceleration(float value);

  // float abs_acceleration_std = 43;
  void clear_abs_acceleration_std();
  static const int kAbsAccelerationStdFieldNumber = 43;
  float abs_acceleration_std() const;
  void set_abs_acceleration_std(float value);

  // float heading = 44;
  void clear_heading();
  static const int kHeadingFieldNumber = 44;
  float heading() const;
  void set_heading(float value);

  // float heading_std = 45;
  void clear_heading_std();
  static const int kHeadingStdFieldNumber = 45;
  float heading_std() const;
  void set_heading_std(float value);

  // float inverse_ttc = 46;
  void clear_inverse_ttc();
  static const int kInverseTtcFieldNumber = 46;
  float inverse_ttc() const;
  void set_inverse_ttc(float value);

  // float inverse_ttc_std = 47;
  void clear_inverse_ttc_std();
  static const int kInverseTtcStdFieldNumber = 47;
  float inverse_ttc_std() const;
  void set_inverse_ttc_std(float value);

  // float angle_left = 48;
  void clear_angle_left();
  static const int kAngleLeftFieldNumber = 48;
  float angle_left() const;
  void set_angle_left(float value);

  // float angle_right = 49;
  void clear_angle_right();
  static const int kAngleRightFieldNumber = 49;
  float angle_right() const;
  void set_angle_right(float value);

  // float angle_rate = 50;
  void clear_angle_rate();
  static const int kAngleRateFieldNumber = 50;
  float angle_rate() const;
  void set_angle_rate(float value);

  // float angle_side = 51;
  void clear_angle_side();
  static const int kAngleSideFieldNumber = 51;
  float angle_side() const;
  void set_angle_side(float value);

  // bool top_out_of_image = 52;
  void clear_top_out_of_image();
  static const int kTopOutOfImageFieldNumber = 52;
  bool top_out_of_image() const;
  void set_top_out_of_image(bool value);

  // bool bottom_out_of_image = 53;
  void clear_bottom_out_of_image();
  static const int kBottomOutOfImageFieldNumber = 53;
  bool bottom_out_of_image() const;
  void set_bottom_out_of_image(bool value);

  // bool left_out_of_image = 54;
  void clear_left_out_of_image();
  static const int kLeftOutOfImageFieldNumber = 54;
  bool left_out_of_image() const;
  void set_left_out_of_image(bool value);

  // bool right_out_of_image = 55;
  void clear_right_out_of_image();
  static const int kRightOutOfImageFieldNumber = 55;
  bool right_out_of_image() const;
  void set_right_out_of_image(bool value);

  // bool brake_light = 56;
  void clear_brake_light();
  static const int kBrakeLightFieldNumber = 56;
  bool brake_light() const;
  void set_brake_light(bool value);

  // bool turn_indicator_left = 57;
  void clear_turn_indicator_left();
  static const int kTurnIndicatorLeftFieldNumber = 57;
  bool turn_indicator_left() const;
  void set_turn_indicator_left(bool value);

  // bool turn_indicator_right = 58;
  void clear_turn_indicator_right();
  static const int kTurnIndicatorRightFieldNumber = 58;
  bool turn_indicator_right() const;
  void set_turn_indicator_right(bool value);

  // .calmcar.perception.MotionOrientation motion_orientation = 60;
  void clear_motion_orientation();
  static const int kMotionOrientationFieldNumber = 60;
  ::calmcar::perception::MotionOrientation motion_orientation() const;
  void set_motion_orientation(::calmcar::perception::MotionOrientation value);

  // .calmcar.perception.MotionCategory motion_category = 61;
  void clear_motion_category();
  static const int kMotionCategoryFieldNumber = 61;
  ::calmcar::perception::MotionCategory motion_category() const;
  void set_motion_category(::calmcar::perception::MotionCategory value);

  // .calmcar.perception.MotionStatus motion_status = 62;
  void clear_motion_status();
  static const int kMotionStatusFieldNumber = 62;
  ::calmcar::perception::MotionStatus motion_status() const;
  void set_motion_status(::calmcar::perception::MotionStatus value);

  // .calmcar.perception.CutInCutOut cutin_cutout = 63;
  void clear_cutin_cutout();
  static const int kCutinCutoutFieldNumber = 63;
  ::calmcar::perception::CutInCutOut cutin_cutout() const;
  void set_cutin_cutout(::calmcar::perception::CutInCutOut value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Object)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::internal::ArenaStringPtr subclass_name_;
  ::calmcar::perception::Rect* bbox_;
  ::calmcar::perception::MeasuringStatus* measuring_status_;
  ::google::protobuf::int64 frame_index_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 class__;
  int camera_position_;
  float confidence_;
  ::google::protobuf::int64 subclass_;
  float length_;
  float length_std_;
  float width_;
  float width_std_;
  float height_;
  float height_std_;
  ::google::protobuf::int64 age_count_;
  float age_seconds_;
  int visibility_side_;
  float lat_distance_;
  float lat_distance_std_;
  float long_distance_;
  float long_distance_std_;
  float relative_lat_velocity_;
  float relative_lat_velocity_std_;
  float relative_long_velocity_;
  float relative_long_velocity_std_;
  float abs_lat_velocity_;
  float abs_lat_velocity_std_;
  float abs_long_velocity_;
  float abs_long_velocity_std_;
  float relative_lat_acc_;
  float relative_lat_acc_std_;
  float relative_long_acc_;
  float relative_long_acc_std_;
  float abs_lat_acc_;
  float abs_lat_acc_std_;
  float abs_long_acc_;
  float abs_long_acc_std_;
  float abs_speed_;
  float abs_speed_std_;
  float abs_acceleration_;
  float abs_acceleration_std_;
  float heading_;
  float heading_std_;
  float inverse_ttc_;
  float inverse_ttc_std_;
  float angle_left_;
  float angle_right_;
  float angle_rate_;
  float angle_side_;
  bool top_out_of_image_;
  bool bottom_out_of_image_;
  bool left_out_of_image_;
  bool right_out_of_image_;
  bool brake_light_;
  bool turn_indicator_left_;
  bool turn_indicator_right_;
  int motion_orientation_;
  int motion_category_;
  int motion_status_;
  int cutin_cutout_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficLight) */ {
 public:
  TrafficLight();
  virtual ~TrafficLight();

  TrafficLight(const TrafficLight& from);

  inline TrafficLight& operator=(const TrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLight(TrafficLight&& from) noexcept
    : TrafficLight() {
    *this = ::std::move(from);
  }

  inline TrafficLight& operator=(TrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLight* internal_default_instance() {
    return reinterpret_cast<const TrafficLight*>(
               &_TrafficLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TrafficLight* other);
  friend void swap(TrafficLight& a, TrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLight* New() const final {
    return CreateMaybeMessage<TrafficLight>(NULL);
  }

  TrafficLight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficLight& from);
  void MergeFrom(const TrafficLight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficLight_Color Color;
  static const Color COLOR_UNKNOWN =
    TrafficLight_Color_COLOR_UNKNOWN;
  static const Color COLOR_GREEN =
    TrafficLight_Color_COLOR_GREEN;
  static const Color COLOR_RED =
    TrafficLight_Color_COLOR_RED;
  static const Color COLOR_YELLOW =
    TrafficLight_Color_COLOR_YELLOW;
  static inline bool Color_IsValid(int value) {
    return TrafficLight_Color_IsValid(value);
  }
  static const Color Color_MIN =
    TrafficLight_Color_Color_MIN;
  static const Color Color_MAX =
    TrafficLight_Color_Color_MAX;
  static const int Color_ARRAYSIZE =
    TrafficLight_Color_Color_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Color_descriptor() {
    return TrafficLight_Color_descriptor();
  }
  static inline const ::std::string& Color_Name(Color value) {
    return TrafficLight_Color_Name(value);
  }
  static inline bool Color_Parse(const ::std::string& name,
      Color* value) {
    return TrafficLight_Color_Parse(name, value);
  }

  typedef TrafficLight_Type Type;
  static const Type TYPE_UNKNOWN =
    TrafficLight_Type_TYPE_UNKNOWN;
  static const Type TYPE_ARROW_STRAIGHT =
    TrafficLight_Type_TYPE_ARROW_STRAIGHT;
  static const Type TYPE_ARROW_LEFT =
    TrafficLight_Type_TYPE_ARROW_LEFT;
  static const Type TYPE_ARROW_RIGHT =
    TrafficLight_Type_TYPE_ARROW_RIGHT;
  static const Type TYPE_ARROW_UTURN =
    TrafficLight_Type_TYPE_ARROW_UTURN;
  static const Type TYPE_CIRCLE =
    TrafficLight_Type_TYPE_CIRCLE;
  static const Type TYPE_NUM =
    TrafficLight_Type_TYPE_NUM;
  static inline bool Type_IsValid(int value) {
    return TrafficLight_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficLight_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficLight_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficLight_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficLight_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficLight_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficLight_Type_Parse(name, value);
  }

  typedef TrafficLight_Mode Mode;
  static const Mode NO_BRIGHT =
    TrafficLight_Mode_NO_BRIGHT;
  static const Mode ALWAYS_BRIGHT =
    TrafficLight_Mode_ALWAYS_BRIGHT;
  static const Mode FLASH =
    TrafficLight_Mode_FLASH;
  static inline bool Mode_IsValid(int value) {
    return TrafficLight_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    TrafficLight_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    TrafficLight_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    TrafficLight_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return TrafficLight_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return TrafficLight_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return TrafficLight_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // .calmcar.perception.Rect bbox = 8;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 8;
  private:
  const ::calmcar::perception::Rect& _internal_bbox() const;
  public:
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 struct_id = 3;
  void clear_struct_id();
  static const int kStructIdFieldNumber = 3;
  ::google::protobuf::int64 struct_id() const;
  void set_struct_id(::google::protobuf::int64 value);

  // int64 spot_id = 4;
  void clear_spot_id();
  static const int kSpotIdFieldNumber = 4;
  ::google::protobuf::int64 spot_id() const;
  void set_spot_id(::google::protobuf::int64 value);

  // int64 class_ = 5;
  void clear_class_();
  static const int kClassFieldNumber = 5;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  float height() const;
  void set_height(float value);

  // int64 tracking_age = 7;
  void clear_tracking_age();
  static const int kTrackingAgeFieldNumber = 7;
  ::google::protobuf::int64 tracking_age() const;
  void set_tracking_age(::google::protobuf::int64 value);

  // float width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  float width() const;
  void set_width(float value);

  // float lat_distance = 11;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 11;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float lat_distance_std = 12;
  void clear_lat_distance_std();
  static const int kLatDistanceStdFieldNumber = 12;
  float lat_distance_std() const;
  void set_lat_distance_std(float value);

  // float long_distance = 13;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 13;
  float long_distance() const;
  void set_long_distance(float value);

  // float long_distance_std = 14;
  void clear_long_distance_std();
  static const int kLongDistanceStdFieldNumber = 14;
  float long_distance_std() const;
  void set_long_distance_std(float value);

  // float rel_height = 15;
  void clear_rel_height();
  static const int kRelHeightFieldNumber = 15;
  float rel_height() const;
  void set_rel_height(float value);

  // float rel_height_std = 16;
  void clear_rel_height_std();
  static const int kRelHeightStdFieldNumber = 16;
  float rel_height_std() const;
  void set_rel_height_std(float value);

  // .calmcar.perception.TrafficLight.Color color = 17;
  void clear_color();
  static const int kColorFieldNumber = 17;
  ::calmcar::perception::TrafficLight_Color color() const;
  void set_color(::calmcar::perception::TrafficLight_Color value);

  // float color_confidence = 18;
  void clear_color_confidence();
  static const int kColorConfidenceFieldNumber = 18;
  float color_confidence() const;
  void set_color_confidence(float value);

  // .calmcar.perception.TrafficLight.Type type = 19;
  void clear_type();
  static const int kTypeFieldNumber = 19;
  ::calmcar::perception::TrafficLight_Type type() const;
  void set_type(::calmcar::perception::TrafficLight_Type value);

  // float type_confidence = 20;
  void clear_type_confidence();
  static const int kTypeConfidenceFieldNumber = 20;
  float type_confidence() const;
  void set_type_confidence(float value);

  // .calmcar.perception.TrafficLight.Mode mode = 21;
  void clear_mode();
  static const int kModeFieldNumber = 21;
  ::calmcar::perception::TrafficLight_Mode mode() const;
  void set_mode(::calmcar::perception::TrafficLight_Mode value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 struct_id_;
  ::google::protobuf::int64 spot_id_;
  ::google::protobuf::int64 class__;
  int camera_position_;
  float height_;
  ::google::protobuf::int64 tracking_age_;
  float width_;
  float lat_distance_;
  float lat_distance_std_;
  float long_distance_;
  float long_distance_std_;
  float rel_height_;
  float rel_height_std_;
  int color_;
  float color_confidence_;
  int type_;
  float type_confidence_;
  int mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSign) */ {
 public:
  TrafficSign();
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TrafficSign* other);
  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const final {
    return CreateMaybeMessage<TrafficSign>(NULL);
  }

  TrafficSign* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_TrafficSIgnRelevancy TrafficSIgnRelevancy;
  static const TrafficSIgnRelevancy Unknow =
    TrafficSign_TrafficSIgnRelevancy_Unknow;
  static const TrafficSIgnRelevancy RELEVANT =
    TrafficSign_TrafficSIgnRelevancy_RELEVANT;
  static const TrafficSIgnRelevancy UNRELEVANT =
    TrafficSign_TrafficSIgnRelevancy_UNRELEVANT;
  static inline bool TrafficSIgnRelevancy_IsValid(int value) {
    return TrafficSign_TrafficSIgnRelevancy_IsValid(value);
  }
  static const TrafficSIgnRelevancy TrafficSIgnRelevancy_MIN =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MIN;
  static const TrafficSIgnRelevancy TrafficSIgnRelevancy_MAX =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_MAX;
  static const int TrafficSIgnRelevancy_ARRAYSIZE =
    TrafficSign_TrafficSIgnRelevancy_TrafficSIgnRelevancy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSIgnRelevancy_descriptor() {
    return TrafficSign_TrafficSIgnRelevancy_descriptor();
  }
  static inline const ::std::string& TrafficSIgnRelevancy_Name(TrafficSIgnRelevancy value) {
    return TrafficSign_TrafficSIgnRelevancy_Name(value);
  }
  static inline bool TrafficSIgnRelevancy_Parse(const ::std::string& name,
      TrafficSIgnRelevancy* value) {
    return TrafficSign_TrafficSIgnRelevancy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string class_name = 6;
  void clear_class_name();
  static const int kClassNameFieldNumber = 6;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // string subclass_name = 7;
  void clear_subclass_name();
  static const int kSubclassNameFieldNumber = 7;
  const ::std::string& subclass_name() const;
  void set_subclass_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subclass_name(::std::string&& value);
  #endif
  void set_subclass_name(const char* value);
  void set_subclass_name(const char* value, size_t size);
  ::std::string* mutable_subclass_name();
  ::std::string* release_subclass_name();
  void set_allocated_subclass_name(::std::string* subclass_name);

  // .calmcar.perception.Rect bbox = 8;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 8;
  private:
  const ::calmcar::perception::Rect& _internal_bbox() const;
  public:
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 class_ = 4;
  void clear_class_();
  static const int kClassFieldNumber = 4;
  ::google::protobuf::int64 class_() const;
  void set_class_(::google::protobuf::int64 value);

  // int64 subclass = 5;
  void clear_subclass();
  static const int kSubclassFieldNumber = 5;
  ::google::protobuf::int64 subclass() const;
  void set_subclass(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // float height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  float height() const;
  void set_height(float value);

  // float width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  float width() const;
  void set_width(float value);

  // float lat_distance = 11;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 11;
  float lat_distance() const;
  void set_lat_distance(float value);

  // int64 tracking_age = 13;
  void clear_tracking_age();
  static const int kTrackingAgeFieldNumber = 13;
  ::google::protobuf::int64 tracking_age() const;
  void set_tracking_age(::google::protobuf::int64 value);

  // float long_distance = 12;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 12;
  float long_distance() const;
  void set_long_distance(float value);

  // .calmcar.perception.TrafficSign.TrafficSIgnRelevancy relevance = 14;
  void clear_relevance();
  static const int kRelevanceFieldNumber = 14;
  ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy relevance() const;
  void set_relevance(::calmcar::perception::TrafficSign_TrafficSIgnRelevancy value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  ::google::protobuf::internal::ArenaStringPtr subclass_name_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 class__;
  ::google::protobuf::int64 subclass_;
  int camera_position_;
  float height_;
  float width_;
  float lat_distance_;
  ::google::protobuf::int64 tracking_age_;
  float long_distance_;
  int relevance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSignType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSignType) */ {
 public:
  TrafficSignType();
  virtual ~TrafficSignType();

  TrafficSignType(const TrafficSignType& from);

  inline TrafficSignType& operator=(const TrafficSignType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignType(TrafficSignType&& from) noexcept
    : TrafficSignType() {
    *this = ::std::move(from);
  }

  inline TrafficSignType& operator=(TrafficSignType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignType* internal_default_instance() {
    return reinterpret_cast<const TrafficSignType*>(
               &_TrafficSignType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TrafficSignType* other);
  friend void swap(TrafficSignType& a, TrafficSignType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignType* New() const final {
    return CreateMaybeMessage<TrafficSignType>(NULL);
  }

  TrafficSignType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSignType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSignType& from);
  void MergeFrom(const TrafficSignType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSignType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSignType_Type Type;
  static const Type UNKNOWN =
    TrafficSignType_Type_UNKNOWN;
  static const Type WARNING =
    TrafficSignType_Type_WARNING;
  static const Type PROHIBIT =
    TrafficSignType_Type_PROHIBIT;
  static const Type ASSIST =
    TrafficSignType_Type_ASSIST;
  static inline bool Type_IsValid(int value) {
    return TrafficSignType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSignType_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSignType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSignType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSignType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSignType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSignType_Type_Parse(name, value);
  }

  typedef TrafficSignType_ProhibitionSign ProhibitionSign;
  static const ProhibitionSign SPEED_LIMIT5 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT5;
  static const ProhibitionSign SPEED_LIMIT10 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT10;
  static const ProhibitionSign SPEED_LIMIT15 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT15;
  static const ProhibitionSign SPEED_LIMIT20 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT20;
  static const ProhibitionSign SPEED_LIMIT30 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT30;
  static const ProhibitionSign SPEED_LIMIT35 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT35;
  static const ProhibitionSign SPEED_LIMIT40 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT40;
  static const ProhibitionSign SPEED_LIMIT50 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT50;
  static const ProhibitionSign SPEED_LIMIT60 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT60;
  static const ProhibitionSign SPEED_LIMIT70 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT70;
  static const ProhibitionSign SPEED_LIMIT80 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT80;
  static const ProhibitionSign SPEED_LIMIT90 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT90;
  static const ProhibitionSign SPEED_LIMIT100 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT100;
  static const ProhibitionSign SPEED_LIMIT110 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT110;
  static const ProhibitionSign SPEED_LIMIT120 =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT120;
  static const ProhibitionSign STOP =
    TrafficSignType_ProhibitionSign_STOP;
  static const ProhibitionSign YIELD =
    TrafficSignType_ProhibitionSign_YIELD;
  static const ProhibitionSign NO_ENTRY =
    TrafficSignType_ProhibitionSign_NO_ENTRY;
  static const ProhibitionSign DONOT_ENTER =
    TrafficSignType_ProhibitionSign_DONOT_ENTER;
  static const ProhibitionSign NO_MOTOR_VEHICLES =
    TrafficSignType_ProhibitionSign_NO_MOTOR_VEHICLES;
  static const ProhibitionSign NO_TRUCKS =
    TrafficSignType_ProhibitionSign_NO_TRUCKS;
  static const ProhibitionSign NO_LARGE_BUESE =
    TrafficSignType_ProhibitionSign_NO_LARGE_BUESE;
  static const ProhibitionSign NO_MOTORCYCLES =
    TrafficSignType_ProhibitionSign_NO_MOTORCYCLES;
  static const ProhibitionSign ONLY_MOTOR_VEHICLES =
    TrafficSignType_ProhibitionSign_ONLY_MOTOR_VEHICLES;
  static const ProhibitionSign NO_PEDESTRIANS =
    TrafficSignType_ProhibitionSign_NO_PEDESTRIANS;
  static const ProhibitionSign NO_LEFT_TURN =
    TrafficSignType_ProhibitionSign_NO_LEFT_TURN;
  static const ProhibitionSign NO_RIGHT_TURN =
    TrafficSignType_ProhibitionSign_NO_RIGHT_TURN;
  static const ProhibitionSign NO_U_TURN =
    TrafficSignType_ProhibitionSign_NO_U_TURN;
  static const ProhibitionSign NO_OVERTAKING =
    TrafficSignType_ProhibitionSign_NO_OVERTAKING;
  static const ProhibitionSign NO_STOPPING =
    TrafficSignType_ProhibitionSign_NO_STOPPING;
  static const ProhibitionSign NO_HONKING =
    TrafficSignType_ProhibitionSign_NO_HONKING;
  static const ProhibitionSign MAX_CLEARANCE =
    TrafficSignType_ProhibitionSign_MAX_CLEARANCE;
  static const ProhibitionSign WEIGHT_LIMIT =
    TrafficSignType_ProhibitionSign_WEIGHT_LIMIT;
  static const ProhibitionSign AXLE_WEIGHT_LIMIT =
    TrafficSignType_ProhibitionSign_AXLE_WEIGHT_LIMIT;
  static const ProhibitionSign SPEED_LIMIT_END =
    TrafficSignType_ProhibitionSign_SPEED_LIMIT_END;
  static const ProhibitionSign NO_MINIBUSES =
    TrafficSignType_ProhibitionSign_NO_MINIBUSES;
  static const ProhibitionSign NO_TRACTOR =
    TrafficSignType_ProhibitionSign_NO_TRACTOR;
  static const ProhibitionSign NO_STRAIGHT =
    TrafficSignType_ProhibitionSign_NO_STRAIGHT;
  static const ProhibitionSign NO_LEFT_RIGHT_TURN =
    TrafficSignType_ProhibitionSign_NO_LEFT_RIGHT_TURN;
  static const ProhibitionSign NO_OVERTAKING_END =
    TrafficSignType_ProhibitionSign_NO_OVERTAKING_END;
  static const ProhibitionSign MAX_WIDTH =
    TrafficSignType_ProhibitionSign_MAX_WIDTH;
  static const ProhibitionSign HAZARDOUS_VEHICLES =
    TrafficSignType_ProhibitionSign_HAZARDOUS_VEHICLES;
  static inline bool ProhibitionSign_IsValid(int value) {
    return TrafficSignType_ProhibitionSign_IsValid(value);
  }
  static const ProhibitionSign ProhibitionSign_MIN =
    TrafficSignType_ProhibitionSign_ProhibitionSign_MIN;
  static const ProhibitionSign ProhibitionSign_MAX =
    TrafficSignType_ProhibitionSign_ProhibitionSign_MAX;
  static const int ProhibitionSign_ARRAYSIZE =
    TrafficSignType_ProhibitionSign_ProhibitionSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProhibitionSign_descriptor() {
    return TrafficSignType_ProhibitionSign_descriptor();
  }
  static inline const ::std::string& ProhibitionSign_Name(ProhibitionSign value) {
    return TrafficSignType_ProhibitionSign_Name(value);
  }
  static inline bool ProhibitionSign_Parse(const ::std::string& name,
      ProhibitionSign* value) {
    return TrafficSignType_ProhibitionSign_Parse(name, value);
  }

  typedef TrafficSignType_WarningSign WarningSign;
  static const WarningSign CROSSROADS =
    TrafficSignType_WarningSign_CROSSROADS;
  static const WarningSign SHARP_CURVE =
    TrafficSignType_WarningSign_SHARP_CURVE;
  static const WarningSign REVERSE_CURVE =
    TrafficSignType_WarningSign_REVERSE_CURVE;
  static const WarningSign WINDING_CURVES =
    TrafficSignType_WarningSign_WINDING_CURVES;
  static const WarningSign STEEP_DESCENT =
    TrafficSignType_WarningSign_STEEP_DESCENT;
  static const WarningSign NARROW_ROAD =
    TrafficSignType_WarningSign_NARROW_ROAD;
  static const WarningSign NARROW_BRIDGE =
    TrafficSignType_WarningSign_NARROW_BRIDGE;
  static const WarningSign TWO_WAY_TRAFFIC =
    TrafficSignType_WarningSign_TWO_WAY_TRAFFIC;
  static const WarningSign WATCH_PEDESTRIANS =
    TrafficSignType_WarningSign_WATCH_PEDESTRIANS;
  static const WarningSign WATCH_CHILDREN =
    TrafficSignType_WarningSign_WATCH_CHILDREN;
  static const WarningSign TRAFFIC_LIGHTS =
    TrafficSignType_WarningSign_TRAFFIC_LIGHTS;
  static const WarningSign FALING_ROCKS =
    TrafficSignType_WarningSign_FALING_ROCKS;
  static const WarningSign CROSSWIND =
    TrafficSignType_WarningSign_CROSSWIND;
  static const WarningSign SLIPPERY_SURFACE =
    TrafficSignType_WarningSign_SLIPPERY_SURFACE;
  static const WarningSign STEEP_MOUNTAIN_ROAD =
    TrafficSignType_WarningSign_STEEP_MOUNTAIN_ROAD;
  static const WarningSign EMBANKMENT_ROAD =
    TrafficSignType_WarningSign_EMBANKMENT_ROAD;
  static const WarningSign VILLAGE =
    TrafficSignType_WarningSign_VILLAGE;
  static const WarningSign TUNNEL =
    TrafficSignType_WarningSign_TUNNEL;
  static const WarningSign HUMP_BACK_BRIDGE =
    TrafficSignType_WarningSign_HUMP_BACK_BRIDGE;
  static const WarningSign BUMPY_ROAD =
    TrafficSignType_WarningSign_BUMPY_ROAD;
  static const WarningSign GUARDED_RAILWAY_CROSSING =
    TrafficSignType_WarningSign_GUARDED_RAILWAY_CROSSING;
  static const WarningSign UNGUARDED_RAILWAY_CROSSING =
    TrafficSignType_WarningSign_UNGUARDED_RAILWAY_CROSSING;
  static const WarningSign NON_MOTOR_VEHICLES =
    TrafficSignType_WarningSign_NON_MOTOR_VEHICLES;
  static const WarningSign ACCIDENT_BLACK_SPOT =
    TrafficSignType_WarningSign_ACCIDENT_BLACK_SPOT;
  static const WarningSign SLOW_DOWN =
    TrafficSignType_WarningSign_SLOW_DOWN;
  static const WarningSign OBSTACLES =
    TrafficSignType_WarningSign_OBSTACLES;
  static const WarningSign CAUTION_DRIVE =
    TrafficSignType_WarningSign_CAUTION_DRIVE;
  static const WarningSign ROAD_WORK =
    TrafficSignType_WarningSign_ROAD_WORK;
  static const WarningSign SUGGESTED_SPEED =
    TrafficSignType_WarningSign_SUGGESTED_SPEED;
  static const WarningSign REVERSIBLE_LANE =
    TrafficSignType_WarningSign_REVERSIBLE_LANE;
  static const WarningSign ROADS_MERGE =
    TrafficSignType_WarningSign_ROADS_MERGE;
  static const WarningSign ICY_ROAD =
    TrafficSignType_WarningSign_ICY_ROAD;
  static const WarningSign QUEUES_LIKELY =
    TrafficSignType_WarningSign_QUEUES_LIKELY;
  static inline bool WarningSign_IsValid(int value) {
    return TrafficSignType_WarningSign_IsValid(value);
  }
  static const WarningSign WarningSign_MIN =
    TrafficSignType_WarningSign_WarningSign_MIN;
  static const WarningSign WarningSign_MAX =
    TrafficSignType_WarningSign_WarningSign_MAX;
  static const int WarningSign_ARRAYSIZE =
    TrafficSignType_WarningSign_WarningSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WarningSign_descriptor() {
    return TrafficSignType_WarningSign_descriptor();
  }
  static inline const ::std::string& WarningSign_Name(WarningSign value) {
    return TrafficSignType_WarningSign_Name(value);
  }
  static inline bool WarningSign_Parse(const ::std::string& name,
      WarningSign* value) {
    return TrafficSignType_WarningSign_Parse(name, value);
  }

  typedef TrafficSignType_AssistSign AssistSign;
  static const AssistSign TIME_LIMIT =
    TrafficSignType_AssistSign_TIME_LIMIT;
  static const AssistSign SCHOOL =
    TrafficSignType_AssistSign_SCHOOL;
  static const AssistSign RAMP =
    TrafficSignType_AssistSign_RAMP;
  static const AssistSign WHOLE_ROAD =
    TrafficSignType_AssistSign_WHOLE_ROAD;
  static const AssistSign FULL_SPEED_MEASUREMENT =
    TrafficSignType_AssistSign_FULL_SPEED_MEASUREMENT;
  static inline bool AssistSign_IsValid(int value) {
    return TrafficSignType_AssistSign_IsValid(value);
  }
  static const AssistSign AssistSign_MIN =
    TrafficSignType_AssistSign_AssistSign_MIN;
  static const AssistSign AssistSign_MAX =
    TrafficSignType_AssistSign_AssistSign_MAX;
  static const int AssistSign_ARRAYSIZE =
    TrafficSignType_AssistSign_AssistSign_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AssistSign_descriptor() {
    return TrafficSignType_AssistSign_descriptor();
  }
  static inline const ::std::string& AssistSign_Name(AssistSign value) {
    return TrafficSignType_AssistSign_Name(value);
  }
  static inline bool AssistSign_Parse(const ::std::string& name,
      AssistSign* value) {
    return TrafficSignType_AssistSign_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value sign = 2;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_sign() const;
  public:
  const ::google::protobuf::Int32Value& sign() const;
  ::google::protobuf::Int32Value* release_sign();
  ::google::protobuf::Int32Value* mutable_sign();
  void set_allocated_sign(::google::protobuf::Int32Value* sign);

  // .calmcar.perception.TrafficSignType.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::calmcar::perception::TrafficSignType_Type type() const;
  void set_type(::calmcar::perception::TrafficSignType_Type value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSignType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* sign_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSignStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.TrafficSignStatus) */ {
 public:
  TrafficSignStatus();
  virtual ~TrafficSignStatus();

  TrafficSignStatus(const TrafficSignStatus& from);

  inline TrafficSignStatus& operator=(const TrafficSignStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignStatus(TrafficSignStatus&& from) noexcept
    : TrafficSignStatus() {
    *this = ::std::move(from);
  }

  inline TrafficSignStatus& operator=(TrafficSignStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignStatus* internal_default_instance() {
    return reinterpret_cast<const TrafficSignStatus*>(
               &_TrafficSignStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TrafficSignStatus* other);
  friend void swap(TrafficSignStatus& a, TrafficSignStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignStatus* New() const final {
    return CreateMaybeMessage<TrafficSignStatus>(NULL);
  }

  TrafficSignStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSignStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSignStatus& from);
  void MergeFrom(const TrafficSignStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSignStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.TrafficSignType derived_signs = 2;
  int derived_signs_size() const;
  void clear_derived_signs();
  static const int kDerivedSignsFieldNumber = 2;
  ::calmcar::perception::TrafficSignType* mutable_derived_signs(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >*
      mutable_derived_signs();
  const ::calmcar::perception::TrafficSignType& derived_signs(int index) const;
  ::calmcar::perception::TrafficSignType* add_derived_signs();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >&
      derived_signs() const;

  // .calmcar.perception.TrafficSignType sign = 1;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 1;
  private:
  const ::calmcar::perception::TrafficSignType& _internal_sign() const;
  public:
  const ::calmcar::perception::TrafficSignType& sign() const;
  ::calmcar::perception::TrafficSignType* release_sign();
  ::calmcar::perception::TrafficSignType* mutable_sign();
  void set_allocated_sign(::calmcar::perception::TrafficSignType* sign);

  // .calmcar.perception.Rect bbox = 3;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 3;
  private:
  const ::calmcar::perception::Rect& _internal_bbox() const;
  public:
  const ::calmcar::perception::Rect& bbox() const;
  ::calmcar::perception::Rect* release_bbox();
  ::calmcar::perception::Rect* mutable_bbox();
  void set_allocated_bbox(::calmcar::perception::Rect* bbox);

  // .google.protobuf.FloatValue speed_limit = 9;
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 9;
  private:
  const ::google::protobuf::FloatValue& _internal_speed_limit() const;
  public:
  const ::google::protobuf::FloatValue& speed_limit() const;
  ::google::protobuf::FloatValue* release_speed_limit();
  ::google::protobuf::FloatValue* mutable_speed_limit();
  void set_allocated_speed_limit(::google::protobuf::FloatValue* speed_limit);

  // .google.protobuf.FloatValue height_limit = 10;
  bool has_height_limit() const;
  void clear_height_limit();
  static const int kHeightLimitFieldNumber = 10;
  private:
  const ::google::protobuf::FloatValue& _internal_height_limit() const;
  public:
  const ::google::protobuf::FloatValue& height_limit() const;
  ::google::protobuf::FloatValue* release_height_limit();
  ::google::protobuf::FloatValue* mutable_height_limit();
  void set_allocated_height_limit(::google::protobuf::FloatValue* height_limit);

  // .google.protobuf.FloatValue weight_limit = 11;
  bool has_weight_limit() const;
  void clear_weight_limit();
  static const int kWeightLimitFieldNumber = 11;
  private:
  const ::google::protobuf::FloatValue& _internal_weight_limit() const;
  public:
  const ::google::protobuf::FloatValue& weight_limit() const;
  ::google::protobuf::FloatValue* release_weight_limit();
  ::google::protobuf::FloatValue* mutable_weight_limit();
  void set_allocated_weight_limit(::google::protobuf::FloatValue* weight_limit);

  // float lat_distance = 4;
  void clear_lat_distance();
  static const int kLatDistanceFieldNumber = 4;
  float lat_distance() const;
  void set_lat_distance(float value);

  // float long_distance = 5;
  void clear_long_distance();
  static const int kLongDistanceFieldNumber = 5;
  float long_distance() const;
  void set_long_distance(float value);

  // float panel_width = 6;
  void clear_panel_width();
  static const int kPanelWidthFieldNumber = 6;
  float panel_width() const;
  void set_panel_width(float value);

  // float panel_height = 7;
  void clear_panel_height();
  static const int kPanelHeightFieldNumber = 7;
  float panel_height() const;
  void set_panel_height(float value);

  // float height = 8;
  void clear_height();
  static const int kHeightFieldNumber = 8;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.TrafficSignStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType > derived_signs_;
  ::calmcar::perception::TrafficSignType* sign_;
  ::calmcar::perception::Rect* bbox_;
  ::google::protobuf::FloatValue* speed_limit_;
  ::google::protobuf::FloatValue* height_limit_;
  ::google::protobuf::FloatValue* weight_limit_;
  float lat_distance_;
  float long_distance_;
  float panel_width_;
  float panel_height_;
  float height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Failsafe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.Failsafe) */ {
 public:
  Failsafe();
  virtual ~Failsafe();

  Failsafe(const Failsafe& from);

  inline Failsafe& operator=(const Failsafe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Failsafe(Failsafe&& from) noexcept
    : Failsafe() {
    *this = ::std::move(from);
  }

  inline Failsafe& operator=(Failsafe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Failsafe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Failsafe* internal_default_instance() {
    return reinterpret_cast<const Failsafe*>(
               &_Failsafe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Failsafe* other);
  friend void swap(Failsafe& a, Failsafe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Failsafe* New() const final {
    return CreateMaybeMessage<Failsafe>(NULL);
  }

  Failsafe* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Failsafe>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Failsafe& from);
  void MergeFrom(const Failsafe& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Failsafe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Failsafe_FailSafeBlockage FailSafeBlockage;
  static const FailSafeBlockage BLOCKAGE_UNKNOWN =
    Failsafe_FailSafeBlockage_BLOCKAGE_UNKNOWN;
  static const FailSafeBlockage BLOCKAGE_FULL =
    Failsafe_FailSafeBlockage_BLOCKAGE_FULL;
  static const FailSafeBlockage BLOCKAGE_PARTICAL =
    Failsafe_FailSafeBlockage_BLOCKAGE_PARTICAL;
  static const FailSafeBlockage BLOCKAGE_NONE =
    Failsafe_FailSafeBlockage_BLOCKAGE_NONE;
  static inline bool FailSafeBlockage_IsValid(int value) {
    return Failsafe_FailSafeBlockage_IsValid(value);
  }
  static const FailSafeBlockage FailSafeBlockage_MIN =
    Failsafe_FailSafeBlockage_FailSafeBlockage_MIN;
  static const FailSafeBlockage FailSafeBlockage_MAX =
    Failsafe_FailSafeBlockage_FailSafeBlockage_MAX;
  static const int FailSafeBlockage_ARRAYSIZE =
    Failsafe_FailSafeBlockage_FailSafeBlockage_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeBlockage_descriptor() {
    return Failsafe_FailSafeBlockage_descriptor();
  }
  static inline const ::std::string& FailSafeBlockage_Name(FailSafeBlockage value) {
    return Failsafe_FailSafeBlockage_Name(value);
  }
  static inline bool FailSafeBlockage_Parse(const ::std::string& name,
      FailSafeBlockage* value) {
    return Failsafe_FailSafeBlockage_Parse(name, value);
  }

  typedef Failsafe_FailSafeWeather FailSafeWeather;
  static const FailSafeWeather WEATHER_UNKNOWN =
    Failsafe_FailSafeWeather_WEATHER_UNKNOWN;
  static const FailSafeWeather WEATHER_FOG =
    Failsafe_FailSafeWeather_WEATHER_FOG;
  static const FailSafeWeather WEATHER_RAIN =
    Failsafe_FailSafeWeather_WEATHER_RAIN;
  static const FailSafeWeather WEATHER_SNOW =
    Failsafe_FailSafeWeather_WEATHER_SNOW;
  static const FailSafeWeather WEATHER_SUNNY =
    Failsafe_FailSafeWeather_WEATHER_SUNNY;
  static inline bool FailSafeWeather_IsValid(int value) {
    return Failsafe_FailSafeWeather_IsValid(value);
  }
  static const FailSafeWeather FailSafeWeather_MIN =
    Failsafe_FailSafeWeather_FailSafeWeather_MIN;
  static const FailSafeWeather FailSafeWeather_MAX =
    Failsafe_FailSafeWeather_FailSafeWeather_MAX;
  static const int FailSafeWeather_ARRAYSIZE =
    Failsafe_FailSafeWeather_FailSafeWeather_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeWeather_descriptor() {
    return Failsafe_FailSafeWeather_descriptor();
  }
  static inline const ::std::string& FailSafeWeather_Name(FailSafeWeather value) {
    return Failsafe_FailSafeWeather_Name(value);
  }
  static inline bool FailSafeWeather_Parse(const ::std::string& name,
      FailSafeWeather* value) {
    return Failsafe_FailSafeWeather_Parse(name, value);
  }

  typedef Failsafe_FailSafeIllumination FailSafeIllumination;
  static const FailSafeIllumination ILLUMINATION_UNKNOWN =
    Failsafe_FailSafeIllumination_ILLUMINATION_UNKNOWN;
  static const FailSafeIllumination ILLUMINATION_DAY =
    Failsafe_FailSafeIllumination_ILLUMINATION_DAY;
  static const FailSafeIllumination ILLUMINATION_DUSK =
    Failsafe_FailSafeIllumination_ILLUMINATION_DUSK;
  static const FailSafeIllumination ILLUMINATION_NIGHT =
    Failsafe_FailSafeIllumination_ILLUMINATION_NIGHT;
  static inline bool FailSafeIllumination_IsValid(int value) {
    return Failsafe_FailSafeIllumination_IsValid(value);
  }
  static const FailSafeIllumination FailSafeIllumination_MIN =
    Failsafe_FailSafeIllumination_FailSafeIllumination_MIN;
  static const FailSafeIllumination FailSafeIllumination_MAX =
    Failsafe_FailSafeIllumination_FailSafeIllumination_MAX;
  static const int FailSafeIllumination_ARRAYSIZE =
    Failsafe_FailSafeIllumination_FailSafeIllumination_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeIllumination_descriptor() {
    return Failsafe_FailSafeIllumination_descriptor();
  }
  static inline const ::std::string& FailSafeIllumination_Name(FailSafeIllumination value) {
    return Failsafe_FailSafeIllumination_Name(value);
  }
  static inline bool FailSafeIllumination_Parse(const ::std::string& name,
      FailSafeIllumination* value) {
    return Failsafe_FailSafeIllumination_Parse(name, value);
  }

  typedef Failsafe_FailSafeImageLimited FailSafeImageLimited;
  static const FailSafeImageLimited IMAGE_LIMITED_UNKNOWN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_UNKNOWN;
  static const FailSafeImageLimited IMAGE_LIMITED_NORMAL =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_NORMAL;
  static const FailSafeImageLimited IMAGE_LIMITED_LOWSUN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_LOWSUN;
  static const FailSafeImageLimited IMAGE_LIMITED_SPALSHES =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SPALSHES;
  static const FailSafeImageLimited IMAGE_LIMITED_BLUR =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_BLUR;
  static const FailSafeImageLimited IMAGE_LIMITED_SUNRAY =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_SUNRAY;
  static const FailSafeImageLimited IMAGE_LIMITED_FROZEN =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_FROZEN;
  static const FailSafeImageLimited IMAGE_LIMITED_OTHER =
    Failsafe_FailSafeImageLimited_IMAGE_LIMITED_OTHER;
  static inline bool FailSafeImageLimited_IsValid(int value) {
    return Failsafe_FailSafeImageLimited_IsValid(value);
  }
  static const FailSafeImageLimited FailSafeImageLimited_MIN =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_MIN;
  static const FailSafeImageLimited FailSafeImageLimited_MAX =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_MAX;
  static const int FailSafeImageLimited_ARRAYSIZE =
    Failsafe_FailSafeImageLimited_FailSafeImageLimited_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailSafeImageLimited_descriptor() {
    return Failsafe_FailSafeImageLimited_descriptor();
  }
  static inline const ::std::string& FailSafeImageLimited_Name(FailSafeImageLimited value) {
    return Failsafe_FailSafeImageLimited_Name(value);
  }
  static inline bool FailSafeImageLimited_Parse(const ::std::string& name,
      FailSafeImageLimited* value) {
    return Failsafe_FailSafeImageLimited_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string blockage_name = 4;
  void clear_blockage_name();
  static const int kBlockageNameFieldNumber = 4;
  const ::std::string& blockage_name() const;
  void set_blockage_name(const ::std::string& value);
  #if LANG_CXX11
  void set_blockage_name(::std::string&& value);
  #endif
  void set_blockage_name(const char* value);
  void set_blockage_name(const char* value, size_t size);
  ::std::string* mutable_blockage_name();
  ::std::string* release_blockage_name();
  void set_allocated_blockage_name(::std::string* blockage_name);

  // string weather_name = 6;
  void clear_weather_name();
  static const int kWeatherNameFieldNumber = 6;
  const ::std::string& weather_name() const;
  void set_weather_name(const ::std::string& value);
  #if LANG_CXX11
  void set_weather_name(::std::string&& value);
  #endif
  void set_weather_name(const char* value);
  void set_weather_name(const char* value, size_t size);
  ::std::string* mutable_weather_name();
  ::std::string* release_weather_name();
  void set_allocated_weather_name(::std::string* weather_name);

  // string illumination_name = 8;
  void clear_illumination_name();
  static const int kIlluminationNameFieldNumber = 8;
  const ::std::string& illumination_name() const;
  void set_illumination_name(const ::std::string& value);
  #if LANG_CXX11
  void set_illumination_name(::std::string&& value);
  #endif
  void set_illumination_name(const char* value);
  void set_illumination_name(const char* value, size_t size);
  ::std::string* mutable_illumination_name();
  ::std::string* release_illumination_name();
  void set_allocated_illumination_name(::std::string* illumination_name);

  // string image_limited_name = 10;
  void clear_image_limited_name();
  static const int kImageLimitedNameFieldNumber = 10;
  const ::std::string& image_limited_name() const;
  void set_image_limited_name(const ::std::string& value);
  #if LANG_CXX11
  void set_image_limited_name(::std::string&& value);
  #endif
  void set_image_limited_name(const char* value);
  void set_image_limited_name(const char* value, size_t size);
  ::std::string* mutable_image_limited_name();
  ::std::string* release_image_limited_name();
  void set_allocated_image_limited_name(::std::string* image_limited_name);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // .calmcar.perception.CameraInfo.Position camera_position = 1;
  void clear_camera_position();
  static const int kCameraPositionFieldNumber = 1;
  ::calmcar::perception::CameraInfo_Position camera_position() const;
  void set_camera_position(::calmcar::perception::CameraInfo_Position value);

  // .calmcar.perception.Failsafe.FailSafeBlockage blockage_status = 3;
  void clear_blockage_status();
  static const int kBlockageStatusFieldNumber = 3;
  ::calmcar::perception::Failsafe_FailSafeBlockage blockage_status() const;
  void set_blockage_status(::calmcar::perception::Failsafe_FailSafeBlockage value);

  // .calmcar.perception.Failsafe.FailSafeWeather weather_status = 5;
  void clear_weather_status();
  static const int kWeatherStatusFieldNumber = 5;
  ::calmcar::perception::Failsafe_FailSafeWeather weather_status() const;
  void set_weather_status(::calmcar::perception::Failsafe_FailSafeWeather value);

  // .calmcar.perception.Failsafe.FailSafeIllumination illumination_status = 7;
  void clear_illumination_status();
  static const int kIlluminationStatusFieldNumber = 7;
  ::calmcar::perception::Failsafe_FailSafeIllumination illumination_status() const;
  void set_illumination_status(::calmcar::perception::Failsafe_FailSafeIllumination value);

  // .calmcar.perception.Failsafe.FailSafeImageLimited image_limited_status = 9;
  void clear_image_limited_status();
  static const int kImageLimitedStatusFieldNumber = 9;
  ::calmcar::perception::Failsafe_FailSafeImageLimited image_limited_status() const;
  void set_image_limited_status(::calmcar::perception::Failsafe_FailSafeImageLimited value);

  // bool out_of_focus = 11;
  void clear_out_of_focus();
  static const int kOutOfFocusFieldNumber = 11;
  bool out_of_focus() const;
  void set_out_of_focus(bool value);

  // int32 impacted_technologies = 12;
  void clear_impacted_technologies();
  static const int kImpactedTechnologiesFieldNumber = 12;
  ::google::protobuf::int32 impacted_technologies() const;
  void set_impacted_technologies(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.Failsafe)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr blockage_name_;
  ::google::protobuf::internal::ArenaStringPtr weather_name_;
  ::google::protobuf::internal::ArenaStringPtr illumination_name_;
  ::google::protobuf::internal::ArenaStringPtr image_limited_name_;
  ::google::protobuf::int64 timestamp_;
  int camera_position_;
  int blockage_status_;
  int weather_status_;
  int illumination_status_;
  int image_limited_status_;
  bool out_of_focus_;
  ::google::protobuf::int32 impacted_technologies_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceptionFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calmcar.perception.PerceptionFrame) */ {
 public:
  PerceptionFrame();
  virtual ~PerceptionFrame();

  PerceptionFrame(const PerceptionFrame& from);

  inline PerceptionFrame& operator=(const PerceptionFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionFrame(PerceptionFrame&& from) noexcept
    : PerceptionFrame() {
    *this = ::std::move(from);
  }

  inline PerceptionFrame& operator=(PerceptionFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionFrame* internal_default_instance() {
    return reinterpret_cast<const PerceptionFrame*>(
               &_PerceptionFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PerceptionFrame* other);
  friend void swap(PerceptionFrame& a, PerceptionFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionFrame* New() const final {
    return CreateMaybeMessage<PerceptionFrame>(NULL);
  }

  PerceptionFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceptionFrame& from);
  void MergeFrom(const PerceptionFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .calmcar.perception.Object object = 10;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 10;
  ::calmcar::perception::Object* mutable_object(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >*
      mutable_object();
  const ::calmcar::perception::Object& object(int index) const;
  ::calmcar::perception::Object* add_object();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >&
      object() const;

  // repeated .calmcar.perception.RoadMark road_mark = 11;
  int road_mark_size() const;
  void clear_road_mark();
  static const int kRoadMarkFieldNumber = 11;
  ::calmcar::perception::RoadMark* mutable_road_mark(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >*
      mutable_road_mark();
  const ::calmcar::perception::RoadMark& road_mark(int index) const;
  ::calmcar::perception::RoadMark* add_road_mark();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >&
      road_mark() const;

  // repeated .calmcar.perception.TrafficLight tfl_structure = 14;
  int tfl_structure_size() const;
  void clear_tfl_structure();
  static const int kTflStructureFieldNumber = 14;
  ::calmcar::perception::TrafficLight* mutable_tfl_structure(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
      mutable_tfl_structure();
  const ::calmcar::perception::TrafficLight& tfl_structure(int index) const;
  ::calmcar::perception::TrafficLight* add_tfl_structure();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
      tfl_structure() const;

  // repeated .calmcar.perception.TrafficLight tfl_struct_state = 15;
  int tfl_struct_state_size() const;
  void clear_tfl_struct_state();
  static const int kTflStructStateFieldNumber = 15;
  ::calmcar::perception::TrafficLight* mutable_tfl_struct_state(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
      mutable_tfl_struct_state();
  const ::calmcar::perception::TrafficLight& tfl_struct_state(int index) const;
  ::calmcar::perception::TrafficLight* add_tfl_struct_state();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
      tfl_struct_state() const;

  // repeated .calmcar.perception.TrafficSign traffic_sign = 18;
  int traffic_sign_size() const;
  void clear_traffic_sign();
  static const int kTrafficSignFieldNumber = 18;
  ::calmcar::perception::TrafficSign* mutable_traffic_sign(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >*
      mutable_traffic_sign();
  const ::calmcar::perception::TrafficSign& traffic_sign(int index) const;
  ::calmcar::perception::TrafficSign* add_traffic_sign();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >&
      traffic_sign() const;

  // repeated .calmcar.perception.TrafficSignStatus traffic_sign_status = 19;
  int traffic_sign_status_size() const;
  void clear_traffic_sign_status();
  static const int kTrafficSignStatusFieldNumber = 19;
  ::calmcar::perception::TrafficSignStatus* mutable_traffic_sign_status(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >*
      mutable_traffic_sign_status();
  const ::calmcar::perception::TrafficSignStatus& traffic_sign_status(int index) const;
  ::calmcar::perception::TrafficSignStatus* add_traffic_sign_status();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >&
      traffic_sign_status() const;

  // repeated .calmcar.perception.Failsafe failsafe = 20;
  int failsafe_size() const;
  void clear_failsafe();
  static const int kFailsafeFieldNumber = 20;
  ::calmcar::perception::Failsafe* mutable_failsafe(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >*
      mutable_failsafe();
  const ::calmcar::perception::Failsafe& failsafe(int index) const;
  ::calmcar::perception::Failsafe* add_failsafe();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >&
      failsafe() const;

  // repeated .calmcar.perception.Vehicle vehicle_info = 21;
  int vehicle_info_size() const;
  void clear_vehicle_info();
  static const int kVehicleInfoFieldNumber = 21;
  ::calmcar::perception::Vehicle* mutable_vehicle_info(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >*
      mutable_vehicle_info();
  const ::calmcar::perception::Vehicle& vehicle_info(int index) const;
  ::calmcar::perception::Vehicle* add_vehicle_info();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >&
      vehicle_info() const;

  // repeated .calmcar.perception.Barricade barricade_object = 23;
  int barricade_object_size() const;
  void clear_barricade_object();
  static const int kBarricadeObjectFieldNumber = 23;
  ::calmcar::perception::Barricade* mutable_barricade_object(int index);
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >*
      mutable_barricade_object();
  const ::calmcar::perception::Barricade& barricade_object(int index) const;
  ::calmcar::perception::Barricade* add_barricade_object();
  const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >&
      barricade_object() const;

  // .calmcar.perception.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::calmcar::perception::Header& _internal_header() const;
  public:
  const ::calmcar::perception::Header& header() const;
  ::calmcar::perception::Header* release_header();
  ::calmcar::perception::Header* mutable_header();
  void set_allocated_header(::calmcar::perception::Header* header);

  // .calmcar.perception.Lane lane = 12;
  bool has_lane() const;
  void clear_lane();
  static const int kLaneFieldNumber = 12;
  private:
  const ::calmcar::perception::Lane& _internal_lane() const;
  public:
  const ::calmcar::perception::Lane& lane() const;
  ::calmcar::perception::Lane* release_lane();
  ::calmcar::perception::Lane* mutable_lane();
  void set_allocated_lane(::calmcar::perception::Lane* lane);

  // .calmcar.perception.FreeSpace free_space = 13;
  bool has_free_space() const;
  void clear_free_space();
  static const int kFreeSpaceFieldNumber = 13;
  private:
  const ::calmcar::perception::FreeSpace& _internal_free_space() const;
  public:
  const ::calmcar::perception::FreeSpace& free_space() const;
  ::calmcar::perception::FreeSpace* release_free_space();
  ::calmcar::perception::FreeSpace* mutable_free_space();
  void set_allocated_free_space(::calmcar::perception::FreeSpace* free_space);

  // int64 vd_count = 2;
  void clear_vd_count();
  static const int kVdCountFieldNumber = 2;
  ::google::protobuf::int64 vd_count() const;
  void set_vd_count(::google::protobuf::int64 value);

  // int64 vru_count = 3;
  void clear_vru_count();
  static const int kVruCountFieldNumber = 3;
  ::google::protobuf::int64 vru_count() const;
  void set_vru_count(::google::protobuf::int64 value);

  // int64 num_of_objects = 4;
  void clear_num_of_objects();
  static const int kNumOfObjectsFieldNumber = 4;
  ::google::protobuf::int64 num_of_objects() const;
  void set_num_of_objects(::google::protobuf::int64 value);

  // int64 cipv_id = 5;
  void clear_cipv_id();
  static const int kCipvIdFieldNumber = 5;
  ::google::protobuf::int64 cipv_id() const;
  void set_cipv_id(::google::protobuf::int64 value);

  // int64 vd_niv_left = 6;
  void clear_vd_niv_left();
  static const int kVdNivLeftFieldNumber = 6;
  ::google::protobuf::int64 vd_niv_left() const;
  void set_vd_niv_left(::google::protobuf::int64 value);

  // int64 vd_niv_right = 7;
  void clear_vd_niv_right();
  static const int kVdNivRightFieldNumber = 7;
  ::google::protobuf::int64 vd_niv_right() const;
  void set_vd_niv_right(::google::protobuf::int64 value);

  // .calmcar.perception.CipvLost cipv_lost = 8;
  void clear_cipv_lost();
  static const int kCipvLostFieldNumber = 8;
  ::calmcar::perception::CipvLost cipv_lost() const;
  void set_cipv_lost(::calmcar::perception::CipvLost value);

  // .calmcar.perception.AllowAcc allow_acc = 9;
  void clear_allow_acc();
  static const int kAllowAccFieldNumber = 9;
  ::calmcar::perception::AllowAcc allow_acc() const;
  void set_allow_acc(::calmcar::perception::AllowAcc value);

  // int64 tfl_struct_count = 16;
  void clear_tfl_struct_count();
  static const int kTflStructCountFieldNumber = 16;
  ::google::protobuf::int64 tfl_struct_count() const;
  void set_tfl_struct_count(::google::protobuf::int64 value);

  // int64 tfl_spot_count = 17;
  void clear_tfl_spot_count();
  static const int kTflSpotCountFieldNumber = 17;
  ::google::protobuf::int64 tfl_spot_count() const;
  void set_tfl_spot_count(::google::protobuf::int64 value);

  // int64 barricade_count = 22;
  void clear_barricade_count();
  static const int kBarricadeCountFieldNumber = 22;
  ::google::protobuf::int64 barricade_count() const;
  void set_barricade_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:calmcar.perception.PerceptionFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object > object_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark > road_mark_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight > tfl_structure_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight > tfl_struct_state_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign > traffic_sign_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus > traffic_sign_status_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe > failsafe_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle > vehicle_info_;
  ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade > barricade_object_;
  ::calmcar::perception::Header* header_;
  ::calmcar::perception::Lane* lane_;
  ::calmcar::perception::FreeSpace* free_space_;
  ::google::protobuf::int64 vd_count_;
  ::google::protobuf::int64 vru_count_;
  ::google::protobuf::int64 num_of_objects_;
  ::google::protobuf::int64 cipv_id_;
  ::google::protobuf::int64 vd_niv_left_;
  ::google::protobuf::int64 vd_niv_right_;
  int cipv_lost_;
  int allow_acc_;
  ::google::protobuf::int64 tfl_struct_count_;
  ::google::protobuf::int64 tfl_spot_count_;
  ::google::protobuf::int64 barricade_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_perception_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// int64 frame_index = 1;
inline void Header::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.frame_index)
  return frame_index_;
}
inline void Header::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.frame_index)
}

// int64 timestamp = 2;
inline void Header::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.timestamp)
  return timestamp_;
}
inline void Header::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.timestamp)
}

// string perception_version = 3;
inline void Header::clear_perception_version() {
  perception_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::perception_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.perception_version)
  return perception_version_.GetNoArena();
}
inline void Header::set_perception_version(const ::std::string& value) {
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.perception_version)
}
#if LANG_CXX11
inline void Header::set_perception_version(::std::string&& value) {
  
  perception_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Header.perception_version)
}
#endif
inline void Header::set_perception_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Header.perception_version)
}
inline void Header::set_perception_version(const char* value, size_t size) {
  
  perception_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Header.perception_version)
}
inline ::std::string* Header::mutable_perception_version() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Header.perception_version)
  return perception_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_perception_version() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Header.perception_version)
  
  return perception_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_perception_version(::std::string* perception_version) {
  if (perception_version != NULL) {
    
  } else {
    
  }
  perception_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), perception_version);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Header.perception_version)
}

// .calmcar.perception.Header.ProtobufVersion protobuf_version = 4;
inline void Header::clear_protobuf_version() {
  protobuf_version_ = 0;
}
inline ::calmcar::perception::Header_ProtobufVersion Header::protobuf_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.protobuf_version)
  return static_cast< ::calmcar::perception::Header_ProtobufVersion >(protobuf_version_);
}
inline void Header::set_protobuf_version(::calmcar::perception::Header_ProtobufVersion value) {
  
  protobuf_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.protobuf_version)
}

// .calmcar.perception.Header.ObjectVersion object_version = 5;
inline void Header::clear_object_version() {
  object_version_ = 0;
}
inline ::calmcar::perception::Header_ObjectVersion Header::object_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.object_version)
  return static_cast< ::calmcar::perception::Header_ObjectVersion >(object_version_);
}
inline void Header::set_object_version(::calmcar::perception::Header_ObjectVersion value) {
  
  object_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.object_version)
}

// .calmcar.perception.Header.TrafficLightStructVersion tfl_struct_version = 6;
inline void Header::clear_tfl_struct_version() {
  tfl_struct_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficLightStructVersion Header::tfl_struct_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.tfl_struct_version)
  return static_cast< ::calmcar::perception::Header_TrafficLightStructVersion >(tfl_struct_version_);
}
inline void Header::set_tfl_struct_version(::calmcar::perception::Header_TrafficLightStructVersion value) {
  
  tfl_struct_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.tfl_struct_version)
}

// .calmcar.perception.Header.TrafficLightSpotVersion tfl_spot_version = 7;
inline void Header::clear_tfl_spot_version() {
  tfl_spot_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficLightSpotVersion Header::tfl_spot_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.tfl_spot_version)
  return static_cast< ::calmcar::perception::Header_TrafficLightSpotVersion >(tfl_spot_version_);
}
inline void Header::set_tfl_spot_version(::calmcar::perception::Header_TrafficLightSpotVersion value) {
  
  tfl_spot_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.tfl_spot_version)
}

// .calmcar.perception.Header.TrafficSignVersion traffic_sign_version = 8;
inline void Header::clear_traffic_sign_version() {
  traffic_sign_version_ = 0;
}
inline ::calmcar::perception::Header_TrafficSignVersion Header::traffic_sign_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.traffic_sign_version)
  return static_cast< ::calmcar::perception::Header_TrafficSignVersion >(traffic_sign_version_);
}
inline void Header::set_traffic_sign_version(::calmcar::perception::Header_TrafficSignVersion value) {
  
  traffic_sign_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.traffic_sign_version)
}

// .calmcar.perception.Header.FailSafeVersion fail_safe_version = 9;
inline void Header::clear_fail_safe_version() {
  fail_safe_version_ = 0;
}
inline ::calmcar::perception::Header_FailSafeVersion Header::fail_safe_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.fail_safe_version)
  return static_cast< ::calmcar::perception::Header_FailSafeVersion >(fail_safe_version_);
}
inline void Header::set_fail_safe_version(::calmcar::perception::Header_FailSafeVersion value) {
  
  fail_safe_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.fail_safe_version)
}

// .calmcar.perception.Header.LaneVersion lane_version = 10;
inline void Header::clear_lane_version() {
  lane_version_ = 0;
}
inline ::calmcar::perception::Header_LaneVersion Header::lane_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.lane_version)
  return static_cast< ::calmcar::perception::Header_LaneVersion >(lane_version_);
}
inline void Header::set_lane_version(::calmcar::perception::Header_LaneVersion value) {
  
  lane_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.lane_version)
}

// .calmcar.perception.Header.RoadMarkVersion road_mark_version = 11;
inline void Header::clear_road_mark_version() {
  road_mark_version_ = 0;
}
inline ::calmcar::perception::Header_RoadMarkVersion Header::road_mark_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.road_mark_version)
  return static_cast< ::calmcar::perception::Header_RoadMarkVersion >(road_mark_version_);
}
inline void Header::set_road_mark_version(::calmcar::perception::Header_RoadMarkVersion value) {
  
  road_mark_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.road_mark_version)
}

// .calmcar.perception.Header.FreeSpaceVersion free_space_version = 12;
inline void Header::clear_free_space_version() {
  free_space_version_ = 0;
}
inline ::calmcar::perception::Header_FreeSpaceVersion Header::free_space_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.free_space_version)
  return static_cast< ::calmcar::perception::Header_FreeSpaceVersion >(free_space_version_);
}
inline void Header::set_free_space_version(::calmcar::perception::Header_FreeSpaceVersion value) {
  
  free_space_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.free_space_version)
}

// .calmcar.perception.Header.BarricadeVersion barricade_version = 13;
inline void Header::clear_barricade_version() {
  barricade_version_ = 0;
}
inline ::calmcar::perception::Header_BarricadeVersion Header::barricade_version() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Header.barricade_version)
  return static_cast< ::calmcar::perception::Header_BarricadeVersion >(barricade_version_);
}
inline void Header::set_barricade_version(::calmcar::perception::Header_BarricadeVersion value) {
  
  barricade_version_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Header.barricade_version)
}

// -------------------------------------------------------------------

// MeasuringStatus

// .calmcar.perception.MeasuringStatus0 measuring_status_0 = 1;
inline void MeasuringStatus::clear_measuring_status_0() {
  measuring_status_0_ = 0;
}
inline ::calmcar::perception::MeasuringStatus0 MeasuringStatus::measuring_status_0() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_0)
  return static_cast< ::calmcar::perception::MeasuringStatus0 >(measuring_status_0_);
}
inline void MeasuringStatus::set_measuring_status_0(::calmcar::perception::MeasuringStatus0 value) {
  
  measuring_status_0_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_0)
}

// .calmcar.perception.MeasuringStatus1 measuring_status_1 = 2;
inline void MeasuringStatus::clear_measuring_status_1() {
  measuring_status_1_ = 0;
}
inline ::calmcar::perception::MeasuringStatus1 MeasuringStatus::measuring_status_1() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_1)
  return static_cast< ::calmcar::perception::MeasuringStatus1 >(measuring_status_1_);
}
inline void MeasuringStatus::set_measuring_status_1(::calmcar::perception::MeasuringStatus1 value) {
  
  measuring_status_1_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_1)
}

// .calmcar.perception.MeasuringStatus2 measuring_status_2 = 3;
inline void MeasuringStatus::clear_measuring_status_2() {
  measuring_status_2_ = 0;
}
inline ::calmcar::perception::MeasuringStatus2 MeasuringStatus::measuring_status_2() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.MeasuringStatus.measuring_status_2)
  return static_cast< ::calmcar::perception::MeasuringStatus2 >(measuring_status_2_);
}
inline void MeasuringStatus::set_measuring_status_2(::calmcar::perception::MeasuringStatus2 value) {
  
  measuring_status_2_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.MeasuringStatus.measuring_status_2)
}

// -------------------------------------------------------------------

// Object

// int64 frame_index = 1;
inline void Object::clear_frame_index() {
  frame_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::frame_index() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.frame_index)
  return frame_index_;
}
inline void Object::set_frame_index(::google::protobuf::int64 value) {
  
  frame_index_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.frame_index)
}

// int64 timestamp = 2;
inline void Object::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.timestamp)
  return timestamp_;
}
inline void Object::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.timestamp)
}

// .calmcar.perception.CameraInfo.Position camera_position = 3;
inline void Object::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position Object::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void Object::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.camera_position)
}

// int64 id = 4;
inline void Object::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.id)
  return id_;
}
inline void Object::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.id)
}

// int64 class_ = 5;
inline void Object::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.class_)
  return class__;
}
inline void Object::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.class_)
}

// string class_name = 6;
inline void Object::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.class_name)
  return class_name_.GetNoArena();
}
inline void Object::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.class_name)
}
#if LANG_CXX11
inline void Object::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Object.class_name)
}
#endif
inline void Object::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Object.class_name)
}
inline void Object::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Object.class_name)
}
inline ::std::string* Object::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.class_name)
}

// int64 subclass = 7;
inline void Object::clear_subclass() {
  subclass_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.subclass)
  return subclass_;
}
inline void Object::set_subclass(::google::protobuf::int64 value) {
  
  subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.subclass)
}

// string subclass_name = 8;
inline void Object::clear_subclass_name() {
  subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Object::subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.subclass_name)
  return subclass_name_.GetNoArena();
}
inline void Object::set_subclass_name(const ::std::string& value) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.subclass_name)
}
#if LANG_CXX11
inline void Object::set_subclass_name(::std::string&& value) {
  
  subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Object.subclass_name)
}
#endif
inline void Object::set_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Object.subclass_name)
}
inline void Object::set_subclass_name(const char* value, size_t size) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Object.subclass_name)
}
inline ::std::string* Object::mutable_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.subclass_name)
  return subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Object::release_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.subclass_name)
  
  return subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Object::set_allocated_subclass_name(::std::string* subclass_name) {
  if (subclass_name != NULL) {
    
  } else {
    
  }
  subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.subclass_name)
}

// float confidence = 9;
inline void Object::clear_confidence() {
  confidence_ = 0;
}
inline float Object::confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.confidence)
  return confidence_;
}
inline void Object::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.confidence)
}

// .calmcar.perception.Rect bbox = 10;
inline bool Object::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& Object::_internal_bbox() const {
  return *bbox_;
}
inline const ::calmcar::perception::Rect& Object::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* Object::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* Object::mutable_bbox() {
  
  if (bbox_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Rect>(GetArenaNoVirtual());
    bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.bbox)
  return bbox_;
}
inline void Object::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.bbox)
}

// float length = 11;
inline void Object::clear_length() {
  length_ = 0;
}
inline float Object::length() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.length)
  return length_;
}
inline void Object::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.length)
}

// float length_std = 12;
inline void Object::clear_length_std() {
  length_std_ = 0;
}
inline float Object::length_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.length_std)
  return length_std_;
}
inline void Object::set_length_std(float value) {
  
  length_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.length_std)
}

// float width = 13;
inline void Object::clear_width() {
  width_ = 0;
}
inline float Object::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.width)
  return width_;
}
inline void Object::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.width)
}

// float width_std = 14;
inline void Object::clear_width_std() {
  width_std_ = 0;
}
inline float Object::width_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.width_std)
  return width_std_;
}
inline void Object::set_width_std(float value) {
  
  width_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.width_std)
}

// float height = 15;
inline void Object::clear_height() {
  height_ = 0;
}
inline float Object::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.height)
  return height_;
}
inline void Object::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.height)
}

// float height_std = 16;
inline void Object::clear_height_std() {
  height_std_ = 0;
}
inline float Object::height_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.height_std)
  return height_std_;
}
inline void Object::set_height_std(float value) {
  
  height_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.height_std)
}

// int64 age_count = 17;
inline void Object::clear_age_count() {
  age_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Object::age_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.age_count)
  return age_count_;
}
inline void Object::set_age_count(::google::protobuf::int64 value) {
  
  age_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.age_count)
}

// float age_seconds = 18;
inline void Object::clear_age_seconds() {
  age_seconds_ = 0;
}
inline float Object::age_seconds() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.age_seconds)
  return age_seconds_;
}
inline void Object::set_age_seconds(float value) {
  
  age_seconds_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.age_seconds)
}

// .calmcar.perception.VisibilitySide visibility_side = 19;
inline void Object::clear_visibility_side() {
  visibility_side_ = 0;
}
inline ::calmcar::perception::VisibilitySide Object::visibility_side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.visibility_side)
  return static_cast< ::calmcar::perception::VisibilitySide >(visibility_side_);
}
inline void Object::set_visibility_side(::calmcar::perception::VisibilitySide value) {
  
  visibility_side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.visibility_side)
}

// float lat_distance = 20;
inline void Object::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float Object::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lat_distance)
  return lat_distance_;
}
inline void Object::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lat_distance)
}

// float lat_distance_std = 21;
inline void Object::clear_lat_distance_std() {
  lat_distance_std_ = 0;
}
inline float Object::lat_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.lat_distance_std)
  return lat_distance_std_;
}
inline void Object::set_lat_distance_std(float value) {
  
  lat_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.lat_distance_std)
}

// float long_distance = 22;
inline void Object::clear_long_distance() {
  long_distance_ = 0;
}
inline float Object::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.long_distance)
  return long_distance_;
}
inline void Object::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.long_distance)
}

// float long_distance_std = 23;
inline void Object::clear_long_distance_std() {
  long_distance_std_ = 0;
}
inline float Object::long_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.long_distance_std)
  return long_distance_std_;
}
inline void Object::set_long_distance_std(float value) {
  
  long_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.long_distance_std)
}

// float relative_lat_velocity = 24;
inline void Object::clear_relative_lat_velocity() {
  relative_lat_velocity_ = 0;
}
inline float Object::relative_lat_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_velocity)
  return relative_lat_velocity_;
}
inline void Object::set_relative_lat_velocity(float value) {
  
  relative_lat_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_velocity)
}

// float relative_lat_velocity_std = 25;
inline void Object::clear_relative_lat_velocity_std() {
  relative_lat_velocity_std_ = 0;
}
inline float Object::relative_lat_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_velocity_std)
  return relative_lat_velocity_std_;
}
inline void Object::set_relative_lat_velocity_std(float value) {
  
  relative_lat_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_velocity_std)
}

// float relative_long_velocity = 26;
inline void Object::clear_relative_long_velocity() {
  relative_long_velocity_ = 0;
}
inline float Object::relative_long_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_velocity)
  return relative_long_velocity_;
}
inline void Object::set_relative_long_velocity(float value) {
  
  relative_long_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_velocity)
}

// float relative_long_velocity_std = 27;
inline void Object::clear_relative_long_velocity_std() {
  relative_long_velocity_std_ = 0;
}
inline float Object::relative_long_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_velocity_std)
  return relative_long_velocity_std_;
}
inline void Object::set_relative_long_velocity_std(float value) {
  
  relative_long_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_velocity_std)
}

// float abs_lat_velocity = 28;
inline void Object::clear_abs_lat_velocity() {
  abs_lat_velocity_ = 0;
}
inline float Object::abs_lat_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_velocity)
  return abs_lat_velocity_;
}
inline void Object::set_abs_lat_velocity(float value) {
  
  abs_lat_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_velocity)
}

// float abs_lat_velocity_std = 29;
inline void Object::clear_abs_lat_velocity_std() {
  abs_lat_velocity_std_ = 0;
}
inline float Object::abs_lat_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_velocity_std)
  return abs_lat_velocity_std_;
}
inline void Object::set_abs_lat_velocity_std(float value) {
  
  abs_lat_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_velocity_std)
}

// float abs_long_velocity = 30;
inline void Object::clear_abs_long_velocity() {
  abs_long_velocity_ = 0;
}
inline float Object::abs_long_velocity() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_velocity)
  return abs_long_velocity_;
}
inline void Object::set_abs_long_velocity(float value) {
  
  abs_long_velocity_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_velocity)
}

// float abs_long_velocity_std = 31;
inline void Object::clear_abs_long_velocity_std() {
  abs_long_velocity_std_ = 0;
}
inline float Object::abs_long_velocity_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_velocity_std)
  return abs_long_velocity_std_;
}
inline void Object::set_abs_long_velocity_std(float value) {
  
  abs_long_velocity_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_velocity_std)
}

// float relative_lat_acc = 32;
inline void Object::clear_relative_lat_acc() {
  relative_lat_acc_ = 0;
}
inline float Object::relative_lat_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_acc)
  return relative_lat_acc_;
}
inline void Object::set_relative_lat_acc(float value) {
  
  relative_lat_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_acc)
}

// float relative_lat_acc_std = 33;
inline void Object::clear_relative_lat_acc_std() {
  relative_lat_acc_std_ = 0;
}
inline float Object::relative_lat_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_lat_acc_std)
  return relative_lat_acc_std_;
}
inline void Object::set_relative_lat_acc_std(float value) {
  
  relative_lat_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_lat_acc_std)
}

// float relative_long_acc = 34;
inline void Object::clear_relative_long_acc() {
  relative_long_acc_ = 0;
}
inline float Object::relative_long_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_acc)
  return relative_long_acc_;
}
inline void Object::set_relative_long_acc(float value) {
  
  relative_long_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_acc)
}

// float relative_long_acc_std = 35;
inline void Object::clear_relative_long_acc_std() {
  relative_long_acc_std_ = 0;
}
inline float Object::relative_long_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.relative_long_acc_std)
  return relative_long_acc_std_;
}
inline void Object::set_relative_long_acc_std(float value) {
  
  relative_long_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.relative_long_acc_std)
}

// float abs_lat_acc = 36;
inline void Object::clear_abs_lat_acc() {
  abs_lat_acc_ = 0;
}
inline float Object::abs_lat_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_acc)
  return abs_lat_acc_;
}
inline void Object::set_abs_lat_acc(float value) {
  
  abs_lat_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_acc)
}

// float abs_lat_acc_std = 37;
inline void Object::clear_abs_lat_acc_std() {
  abs_lat_acc_std_ = 0;
}
inline float Object::abs_lat_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_lat_acc_std)
  return abs_lat_acc_std_;
}
inline void Object::set_abs_lat_acc_std(float value) {
  
  abs_lat_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_lat_acc_std)
}

// float abs_long_acc = 38;
inline void Object::clear_abs_long_acc() {
  abs_long_acc_ = 0;
}
inline float Object::abs_long_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_acc)
  return abs_long_acc_;
}
inline void Object::set_abs_long_acc(float value) {
  
  abs_long_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_acc)
}

// float abs_long_acc_std = 39;
inline void Object::clear_abs_long_acc_std() {
  abs_long_acc_std_ = 0;
}
inline float Object::abs_long_acc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_long_acc_std)
  return abs_long_acc_std_;
}
inline void Object::set_abs_long_acc_std(float value) {
  
  abs_long_acc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_long_acc_std)
}

// float abs_speed = 40;
inline void Object::clear_abs_speed() {
  abs_speed_ = 0;
}
inline float Object::abs_speed() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_speed)
  return abs_speed_;
}
inline void Object::set_abs_speed(float value) {
  
  abs_speed_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_speed)
}

// float abs_speed_std = 41;
inline void Object::clear_abs_speed_std() {
  abs_speed_std_ = 0;
}
inline float Object::abs_speed_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_speed_std)
  return abs_speed_std_;
}
inline void Object::set_abs_speed_std(float value) {
  
  abs_speed_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_speed_std)
}

// float abs_acceleration = 42;
inline void Object::clear_abs_acceleration() {
  abs_acceleration_ = 0;
}
inline float Object::abs_acceleration() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_acceleration)
  return abs_acceleration_;
}
inline void Object::set_abs_acceleration(float value) {
  
  abs_acceleration_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_acceleration)
}

// float abs_acceleration_std = 43;
inline void Object::clear_abs_acceleration_std() {
  abs_acceleration_std_ = 0;
}
inline float Object::abs_acceleration_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.abs_acceleration_std)
  return abs_acceleration_std_;
}
inline void Object::set_abs_acceleration_std(float value) {
  
  abs_acceleration_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.abs_acceleration_std)
}

// float heading = 44;
inline void Object::clear_heading() {
  heading_ = 0;
}
inline float Object::heading() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.heading)
  return heading_;
}
inline void Object::set_heading(float value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.heading)
}

// float heading_std = 45;
inline void Object::clear_heading_std() {
  heading_std_ = 0;
}
inline float Object::heading_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.heading_std)
  return heading_std_;
}
inline void Object::set_heading_std(float value) {
  
  heading_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.heading_std)
}

// float inverse_ttc = 46;
inline void Object::clear_inverse_ttc() {
  inverse_ttc_ = 0;
}
inline float Object::inverse_ttc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.inverse_ttc)
  return inverse_ttc_;
}
inline void Object::set_inverse_ttc(float value) {
  
  inverse_ttc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.inverse_ttc)
}

// float inverse_ttc_std = 47;
inline void Object::clear_inverse_ttc_std() {
  inverse_ttc_std_ = 0;
}
inline float Object::inverse_ttc_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.inverse_ttc_std)
  return inverse_ttc_std_;
}
inline void Object::set_inverse_ttc_std(float value) {
  
  inverse_ttc_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.inverse_ttc_std)
}

// float angle_left = 48;
inline void Object::clear_angle_left() {
  angle_left_ = 0;
}
inline float Object::angle_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_left)
  return angle_left_;
}
inline void Object::set_angle_left(float value) {
  
  angle_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_left)
}

// float angle_right = 49;
inline void Object::clear_angle_right() {
  angle_right_ = 0;
}
inline float Object::angle_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_right)
  return angle_right_;
}
inline void Object::set_angle_right(float value) {
  
  angle_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_right)
}

// float angle_rate = 50;
inline void Object::clear_angle_rate() {
  angle_rate_ = 0;
}
inline float Object::angle_rate() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_rate)
  return angle_rate_;
}
inline void Object::set_angle_rate(float value) {
  
  angle_rate_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_rate)
}

// float angle_side = 51;
inline void Object::clear_angle_side() {
  angle_side_ = 0;
}
inline float Object::angle_side() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.angle_side)
  return angle_side_;
}
inline void Object::set_angle_side(float value) {
  
  angle_side_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.angle_side)
}

// bool top_out_of_image = 52;
inline void Object::clear_top_out_of_image() {
  top_out_of_image_ = false;
}
inline bool Object::top_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.top_out_of_image)
  return top_out_of_image_;
}
inline void Object::set_top_out_of_image(bool value) {
  
  top_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.top_out_of_image)
}

// bool bottom_out_of_image = 53;
inline void Object::clear_bottom_out_of_image() {
  bottom_out_of_image_ = false;
}
inline bool Object::bottom_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.bottom_out_of_image)
  return bottom_out_of_image_;
}
inline void Object::set_bottom_out_of_image(bool value) {
  
  bottom_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.bottom_out_of_image)
}

// bool left_out_of_image = 54;
inline void Object::clear_left_out_of_image() {
  left_out_of_image_ = false;
}
inline bool Object::left_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.left_out_of_image)
  return left_out_of_image_;
}
inline void Object::set_left_out_of_image(bool value) {
  
  left_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.left_out_of_image)
}

// bool right_out_of_image = 55;
inline void Object::clear_right_out_of_image() {
  right_out_of_image_ = false;
}
inline bool Object::right_out_of_image() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.right_out_of_image)
  return right_out_of_image_;
}
inline void Object::set_right_out_of_image(bool value) {
  
  right_out_of_image_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.right_out_of_image)
}

// bool brake_light = 56;
inline void Object::clear_brake_light() {
  brake_light_ = false;
}
inline bool Object::brake_light() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.brake_light)
  return brake_light_;
}
inline void Object::set_brake_light(bool value) {
  
  brake_light_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.brake_light)
}

// bool turn_indicator_left = 57;
inline void Object::clear_turn_indicator_left() {
  turn_indicator_left_ = false;
}
inline bool Object::turn_indicator_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.turn_indicator_left)
  return turn_indicator_left_;
}
inline void Object::set_turn_indicator_left(bool value) {
  
  turn_indicator_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.turn_indicator_left)
}

// bool turn_indicator_right = 58;
inline void Object::clear_turn_indicator_right() {
  turn_indicator_right_ = false;
}
inline bool Object::turn_indicator_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.turn_indicator_right)
  return turn_indicator_right_;
}
inline void Object::set_turn_indicator_right(bool value) {
  
  turn_indicator_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.turn_indicator_right)
}

// .calmcar.perception.MeasuringStatus measuring_status = 59;
inline bool Object::has_measuring_status() const {
  return this != internal_default_instance() && measuring_status_ != NULL;
}
inline void Object::clear_measuring_status() {
  if (GetArenaNoVirtual() == NULL && measuring_status_ != NULL) {
    delete measuring_status_;
  }
  measuring_status_ = NULL;
}
inline const ::calmcar::perception::MeasuringStatus& Object::_internal_measuring_status() const {
  return *measuring_status_;
}
inline const ::calmcar::perception::MeasuringStatus& Object::measuring_status() const {
  const ::calmcar::perception::MeasuringStatus* p = measuring_status_;
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.measuring_status)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::MeasuringStatus*>(
      &::calmcar::perception::_MeasuringStatus_default_instance_);
}
inline ::calmcar::perception::MeasuringStatus* Object::release_measuring_status() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Object.measuring_status)
  
  ::calmcar::perception::MeasuringStatus* temp = measuring_status_;
  measuring_status_ = NULL;
  return temp;
}
inline ::calmcar::perception::MeasuringStatus* Object::mutable_measuring_status() {
  
  if (measuring_status_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::MeasuringStatus>(GetArenaNoVirtual());
    measuring_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Object.measuring_status)
  return measuring_status_;
}
inline void Object::set_allocated_measuring_status(::calmcar::perception::MeasuringStatus* measuring_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete measuring_status_;
  }
  if (measuring_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      measuring_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, measuring_status, submessage_arena);
    }
    
  } else {
    
  }
  measuring_status_ = measuring_status;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Object.measuring_status)
}

// .calmcar.perception.MotionOrientation motion_orientation = 60;
inline void Object::clear_motion_orientation() {
  motion_orientation_ = 0;
}
inline ::calmcar::perception::MotionOrientation Object::motion_orientation() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_orientation)
  return static_cast< ::calmcar::perception::MotionOrientation >(motion_orientation_);
}
inline void Object::set_motion_orientation(::calmcar::perception::MotionOrientation value) {
  
  motion_orientation_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_orientation)
}

// .calmcar.perception.MotionCategory motion_category = 61;
inline void Object::clear_motion_category() {
  motion_category_ = 0;
}
inline ::calmcar::perception::MotionCategory Object::motion_category() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_category)
  return static_cast< ::calmcar::perception::MotionCategory >(motion_category_);
}
inline void Object::set_motion_category(::calmcar::perception::MotionCategory value) {
  
  motion_category_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_category)
}

// .calmcar.perception.MotionStatus motion_status = 62;
inline void Object::clear_motion_status() {
  motion_status_ = 0;
}
inline ::calmcar::perception::MotionStatus Object::motion_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.motion_status)
  return static_cast< ::calmcar::perception::MotionStatus >(motion_status_);
}
inline void Object::set_motion_status(::calmcar::perception::MotionStatus value) {
  
  motion_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.motion_status)
}

// .calmcar.perception.CutInCutOut cutin_cutout = 63;
inline void Object::clear_cutin_cutout() {
  cutin_cutout_ = 0;
}
inline ::calmcar::perception::CutInCutOut Object::cutin_cutout() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Object.cutin_cutout)
  return static_cast< ::calmcar::perception::CutInCutOut >(cutin_cutout_);
}
inline void Object::set_cutin_cutout(::calmcar::perception::CutInCutOut value) {
  
  cutin_cutout_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Object.cutin_cutout)
}

// -------------------------------------------------------------------

// TrafficLight

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void TrafficLight::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position TrafficLight::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void TrafficLight::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.camera_position)
}

// int64 timestamp = 2;
inline void TrafficLight::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.timestamp)
  return timestamp_;
}
inline void TrafficLight::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.timestamp)
}

// int64 struct_id = 3;
inline void TrafficLight::clear_struct_id() {
  struct_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::struct_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.struct_id)
  return struct_id_;
}
inline void TrafficLight::set_struct_id(::google::protobuf::int64 value) {
  
  struct_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.struct_id)
}

// int64 spot_id = 4;
inline void TrafficLight::clear_spot_id() {
  spot_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::spot_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.spot_id)
  return spot_id_;
}
inline void TrafficLight::set_spot_id(::google::protobuf::int64 value) {
  
  spot_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.spot_id)
}

// int64 class_ = 5;
inline void TrafficLight::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.class_)
  return class__;
}
inline void TrafficLight::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.class_)
}

// string class_name = 6;
inline void TrafficLight::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficLight::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.class_name)
  return class_name_.GetNoArena();
}
inline void TrafficLight::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.class_name)
}
#if LANG_CXX11
inline void TrafficLight::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficLight.class_name)
}
#endif
inline void TrafficLight::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficLight.class_name)
}
inline void TrafficLight::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficLight.class_name)
}
inline ::std::string* TrafficLight::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLight.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLight::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficLight.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLight::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficLight.class_name)
}

// int64 tracking_age = 7;
inline void TrafficLight::clear_tracking_age() {
  tracking_age_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLight::tracking_age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.tracking_age)
  return tracking_age_;
}
inline void TrafficLight::set_tracking_age(::google::protobuf::int64 value) {
  
  tracking_age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.tracking_age)
}

// .calmcar.perception.Rect bbox = 8;
inline bool TrafficLight::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficLight::_internal_bbox() const {
  return *bbox_;
}
inline const ::calmcar::perception::Rect& TrafficLight::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficLight::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficLight.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficLight::mutable_bbox() {
  
  if (bbox_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Rect>(GetArenaNoVirtual());
    bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficLight.bbox)
  return bbox_;
}
inline void TrafficLight::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficLight.bbox)
}

// float height = 9;
inline void TrafficLight::clear_height() {
  height_ = 0;
}
inline float TrafficLight::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.height)
  return height_;
}
inline void TrafficLight::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.height)
}

// float width = 10;
inline void TrafficLight::clear_width() {
  width_ = 0;
}
inline float TrafficLight::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.width)
  return width_;
}
inline void TrafficLight::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.width)
}

// float lat_distance = 11;
inline void TrafficLight::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficLight::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.lat_distance)
  return lat_distance_;
}
inline void TrafficLight::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.lat_distance)
}

// float lat_distance_std = 12;
inline void TrafficLight::clear_lat_distance_std() {
  lat_distance_std_ = 0;
}
inline float TrafficLight::lat_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.lat_distance_std)
  return lat_distance_std_;
}
inline void TrafficLight::set_lat_distance_std(float value) {
  
  lat_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.lat_distance_std)
}

// float long_distance = 13;
inline void TrafficLight::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficLight::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.long_distance)
  return long_distance_;
}
inline void TrafficLight::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.long_distance)
}

// float long_distance_std = 14;
inline void TrafficLight::clear_long_distance_std() {
  long_distance_std_ = 0;
}
inline float TrafficLight::long_distance_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.long_distance_std)
  return long_distance_std_;
}
inline void TrafficLight::set_long_distance_std(float value) {
  
  long_distance_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.long_distance_std)
}

// float rel_height = 15;
inline void TrafficLight::clear_rel_height() {
  rel_height_ = 0;
}
inline float TrafficLight::rel_height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.rel_height)
  return rel_height_;
}
inline void TrafficLight::set_rel_height(float value) {
  
  rel_height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.rel_height)
}

// float rel_height_std = 16;
inline void TrafficLight::clear_rel_height_std() {
  rel_height_std_ = 0;
}
inline float TrafficLight::rel_height_std() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.rel_height_std)
  return rel_height_std_;
}
inline void TrafficLight::set_rel_height_std(float value) {
  
  rel_height_std_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.rel_height_std)
}

// .calmcar.perception.TrafficLight.Color color = 17;
inline void TrafficLight::clear_color() {
  color_ = 0;
}
inline ::calmcar::perception::TrafficLight_Color TrafficLight::color() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.color)
  return static_cast< ::calmcar::perception::TrafficLight_Color >(color_);
}
inline void TrafficLight::set_color(::calmcar::perception::TrafficLight_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.color)
}

// float color_confidence = 18;
inline void TrafficLight::clear_color_confidence() {
  color_confidence_ = 0;
}
inline float TrafficLight::color_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.color_confidence)
  return color_confidence_;
}
inline void TrafficLight::set_color_confidence(float value) {
  
  color_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.color_confidence)
}

// .calmcar.perception.TrafficLight.Type type = 19;
inline void TrafficLight::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::TrafficLight_Type TrafficLight::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.type)
  return static_cast< ::calmcar::perception::TrafficLight_Type >(type_);
}
inline void TrafficLight::set_type(::calmcar::perception::TrafficLight_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.type)
}

// float type_confidence = 20;
inline void TrafficLight::clear_type_confidence() {
  type_confidence_ = 0;
}
inline float TrafficLight::type_confidence() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.type_confidence)
  return type_confidence_;
}
inline void TrafficLight::set_type_confidence(float value) {
  
  type_confidence_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.type_confidence)
}

// .calmcar.perception.TrafficLight.Mode mode = 21;
inline void TrafficLight::clear_mode() {
  mode_ = 0;
}
inline ::calmcar::perception::TrafficLight_Mode TrafficLight::mode() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficLight.mode)
  return static_cast< ::calmcar::perception::TrafficLight_Mode >(mode_);
}
inline void TrafficLight::set_mode(::calmcar::perception::TrafficLight_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficLight.mode)
}

// -------------------------------------------------------------------

// TrafficSign

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void TrafficSign::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position TrafficSign::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void TrafficSign::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.camera_position)
}

// int64 timestamp = 2;
inline void TrafficSign::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.timestamp)
  return timestamp_;
}
inline void TrafficSign::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.timestamp)
}

// int64 id = 3;
inline void TrafficSign::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.id)
  return id_;
}
inline void TrafficSign::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.id)
}

// int64 class_ = 4;
inline void TrafficSign::clear_class_() {
  class__ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::class_() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.class_)
  return class__;
}
inline void TrafficSign::set_class_(::google::protobuf::int64 value) {
  
  class__ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.class_)
}

// int64 subclass = 5;
inline void TrafficSign::clear_subclass() {
  subclass_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::subclass() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.subclass)
  return subclass_;
}
inline void TrafficSign::set_subclass(::google::protobuf::int64 value) {
  
  subclass_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.subclass)
}

// string class_name = 6;
inline void TrafficSign::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficSign::class_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.class_name)
  return class_name_.GetNoArena();
}
inline void TrafficSign::set_class_name(const ::std::string& value) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.class_name)
}
#if LANG_CXX11
inline void TrafficSign::set_class_name(::std::string&& value) {
  
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficSign.class_name)
}
#endif
inline void TrafficSign::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficSign.class_name)
}
inline void TrafficSign::set_class_name(const char* value, size_t size) {
  
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficSign.class_name)
}
inline ::std::string* TrafficSign::mutable_class_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficSign::release_class_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.class_name)
  
  return class_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    
  } else {
    
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.class_name)
}

// string subclass_name = 7;
inline void TrafficSign::clear_subclass_name() {
  subclass_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrafficSign::subclass_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.subclass_name)
  return subclass_name_.GetNoArena();
}
inline void TrafficSign::set_subclass_name(const ::std::string& value) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.subclass_name)
}
#if LANG_CXX11
inline void TrafficSign::set_subclass_name(::std::string&& value) {
  
  subclass_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.TrafficSign.subclass_name)
}
#endif
inline void TrafficSign::set_subclass_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.TrafficSign.subclass_name)
}
inline void TrafficSign::set_subclass_name(const char* value, size_t size) {
  
  subclass_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.TrafficSign.subclass_name)
}
inline ::std::string* TrafficSign::mutable_subclass_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.subclass_name)
  return subclass_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficSign::release_subclass_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.subclass_name)
  
  return subclass_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficSign::set_allocated_subclass_name(::std::string* subclass_name) {
  if (subclass_name != NULL) {
    
  } else {
    
  }
  subclass_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subclass_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.subclass_name)
}

// .calmcar.perception.Rect bbox = 8;
inline bool TrafficSign::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficSign::_internal_bbox() const {
  return *bbox_;
}
inline const ::calmcar::perception::Rect& TrafficSign::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficSign::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSign.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficSign::mutable_bbox() {
  
  if (bbox_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Rect>(GetArenaNoVirtual());
    bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSign.bbox)
  return bbox_;
}
inline void TrafficSign::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSign.bbox)
}

// float height = 9;
inline void TrafficSign::clear_height() {
  height_ = 0;
}
inline float TrafficSign::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.height)
  return height_;
}
inline void TrafficSign::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.height)
}

// float width = 10;
inline void TrafficSign::clear_width() {
  width_ = 0;
}
inline float TrafficSign::width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.width)
  return width_;
}
inline void TrafficSign::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.width)
}

// float lat_distance = 11;
inline void TrafficSign::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficSign::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.lat_distance)
  return lat_distance_;
}
inline void TrafficSign::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.lat_distance)
}

// float long_distance = 12;
inline void TrafficSign::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficSign::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.long_distance)
  return long_distance_;
}
inline void TrafficSign::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.long_distance)
}

// int64 tracking_age = 13;
inline void TrafficSign::clear_tracking_age() {
  tracking_age_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficSign::tracking_age() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.tracking_age)
  return tracking_age_;
}
inline void TrafficSign::set_tracking_age(::google::protobuf::int64 value) {
  
  tracking_age_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.tracking_age)
}

// .calmcar.perception.TrafficSign.TrafficSIgnRelevancy relevance = 14;
inline void TrafficSign::clear_relevance() {
  relevance_ = 0;
}
inline ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy TrafficSign::relevance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSign.relevance)
  return static_cast< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy >(relevance_);
}
inline void TrafficSign::set_relevance(::calmcar::perception::TrafficSign_TrafficSIgnRelevancy value) {
  
  relevance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSign.relevance)
}

// -------------------------------------------------------------------

// TrafficSignType

// .calmcar.perception.TrafficSignType.Type type = 1;
inline void TrafficSignType::clear_type() {
  type_ = 0;
}
inline ::calmcar::perception::TrafficSignType_Type TrafficSignType::type() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignType.type)
  return static_cast< ::calmcar::perception::TrafficSignType_Type >(type_);
}
inline void TrafficSignType::set_type(::calmcar::perception::TrafficSignType_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignType.type)
}

// .google.protobuf.Int32Value sign = 2;
inline bool TrafficSignType::has_sign() const {
  return this != internal_default_instance() && sign_ != NULL;
}
inline const ::google::protobuf::Int32Value& TrafficSignType::_internal_sign() const {
  return *sign_;
}
inline const ::google::protobuf::Int32Value& TrafficSignType::sign() const {
  const ::google::protobuf::Int32Value* p = sign_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignType.sign)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* TrafficSignType::release_sign() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignType.sign)
  
  ::google::protobuf::Int32Value* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* TrafficSignType::mutable_sign() {
  
  if (sign_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    sign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignType.sign)
  return sign_;
}
inline void TrafficSignType::set_allocated_sign(::google::protobuf::Int32Value* sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sign_);
  }
  if (sign) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(sign)->GetArena();
    if (message_arena != submessage_arena) {
      sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignType.sign)
}

// -------------------------------------------------------------------

// TrafficSignStatus

// .calmcar.perception.TrafficSignType sign = 1;
inline bool TrafficSignStatus::has_sign() const {
  return this != internal_default_instance() && sign_ != NULL;
}
inline void TrafficSignStatus::clear_sign() {
  if (GetArenaNoVirtual() == NULL && sign_ != NULL) {
    delete sign_;
  }
  sign_ = NULL;
}
inline const ::calmcar::perception::TrafficSignType& TrafficSignStatus::_internal_sign() const {
  return *sign_;
}
inline const ::calmcar::perception::TrafficSignType& TrafficSignStatus::sign() const {
  const ::calmcar::perception::TrafficSignType* p = sign_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.sign)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::TrafficSignType*>(
      &::calmcar::perception::_TrafficSignType_default_instance_);
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::release_sign() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.sign)
  
  ::calmcar::perception::TrafficSignType* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::mutable_sign() {
  
  if (sign_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::TrafficSignType>(GetArenaNoVirtual());
    sign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.sign)
  return sign_;
}
inline void TrafficSignStatus::set_allocated_sign(::calmcar::perception::TrafficSignType* sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sign_;
  }
  if (sign) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.sign)
}

// repeated .calmcar.perception.TrafficSignType derived_signs = 2;
inline int TrafficSignStatus::derived_signs_size() const {
  return derived_signs_.size();
}
inline void TrafficSignStatus::clear_derived_signs() {
  derived_signs_.Clear();
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::mutable_derived_signs(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >*
TrafficSignStatus::mutable_derived_signs() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.TrafficSignStatus.derived_signs)
  return &derived_signs_;
}
inline const ::calmcar::perception::TrafficSignType& TrafficSignStatus::derived_signs(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Get(index);
}
inline ::calmcar::perception::TrafficSignType* TrafficSignStatus::add_derived_signs() {
  // @@protoc_insertion_point(field_add:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignType >&
TrafficSignStatus::derived_signs() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.TrafficSignStatus.derived_signs)
  return derived_signs_;
}

// .calmcar.perception.Rect bbox = 3;
inline bool TrafficSignStatus::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline const ::calmcar::perception::Rect& TrafficSignStatus::_internal_bbox() const {
  return *bbox_;
}
inline const ::calmcar::perception::Rect& TrafficSignStatus::bbox() const {
  const ::calmcar::perception::Rect* p = bbox_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.bbox)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Rect*>(
      &::calmcar::perception::_Rect_default_instance_);
}
inline ::calmcar::perception::Rect* TrafficSignStatus::release_bbox() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.bbox)
  
  ::calmcar::perception::Rect* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline ::calmcar::perception::Rect* TrafficSignStatus::mutable_bbox() {
  
  if (bbox_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Rect>(GetArenaNoVirtual());
    bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.bbox)
  return bbox_;
}
inline void TrafficSignStatus::set_allocated_bbox(::calmcar::perception::Rect* bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    
  } else {
    
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.bbox)
}

// float lat_distance = 4;
inline void TrafficSignStatus::clear_lat_distance() {
  lat_distance_ = 0;
}
inline float TrafficSignStatus::lat_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.lat_distance)
  return lat_distance_;
}
inline void TrafficSignStatus::set_lat_distance(float value) {
  
  lat_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.lat_distance)
}

// float long_distance = 5;
inline void TrafficSignStatus::clear_long_distance() {
  long_distance_ = 0;
}
inline float TrafficSignStatus::long_distance() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.long_distance)
  return long_distance_;
}
inline void TrafficSignStatus::set_long_distance(float value) {
  
  long_distance_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.long_distance)
}

// float panel_width = 6;
inline void TrafficSignStatus::clear_panel_width() {
  panel_width_ = 0;
}
inline float TrafficSignStatus::panel_width() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.panel_width)
  return panel_width_;
}
inline void TrafficSignStatus::set_panel_width(float value) {
  
  panel_width_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.panel_width)
}

// float panel_height = 7;
inline void TrafficSignStatus::clear_panel_height() {
  panel_height_ = 0;
}
inline float TrafficSignStatus::panel_height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.panel_height)
  return panel_height_;
}
inline void TrafficSignStatus::set_panel_height(float value) {
  
  panel_height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.panel_height)
}

// float height = 8;
inline void TrafficSignStatus::clear_height() {
  height_ = 0;
}
inline float TrafficSignStatus::height() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.height)
  return height_;
}
inline void TrafficSignStatus::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.TrafficSignStatus.height)
}

// .google.protobuf.FloatValue speed_limit = 9;
inline bool TrafficSignStatus::has_speed_limit() const {
  return this != internal_default_instance() && speed_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::_internal_speed_limit() const {
  return *speed_limit_;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::speed_limit() const {
  const ::google::protobuf::FloatValue* p = speed_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.speed_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_speed_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.speed_limit)
  
  ::google::protobuf::FloatValue* temp = speed_limit_;
  speed_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_speed_limit() {
  
  if (speed_limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    speed_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.speed_limit)
  return speed_limit_;
}
inline void TrafficSignStatus::set_allocated_speed_limit(::google::protobuf::FloatValue* speed_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(speed_limit_);
  }
  if (speed_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(speed_limit)->GetArena();
    if (message_arena != submessage_arena) {
      speed_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speed_limit, submessage_arena);
    }
    
  } else {
    
  }
  speed_limit_ = speed_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.speed_limit)
}

// .google.protobuf.FloatValue height_limit = 10;
inline bool TrafficSignStatus::has_height_limit() const {
  return this != internal_default_instance() && height_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::_internal_height_limit() const {
  return *height_limit_;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::height_limit() const {
  const ::google::protobuf::FloatValue* p = height_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.height_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_height_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.height_limit)
  
  ::google::protobuf::FloatValue* temp = height_limit_;
  height_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_height_limit() {
  
  if (height_limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    height_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.height_limit)
  return height_limit_;
}
inline void TrafficSignStatus::set_allocated_height_limit(::google::protobuf::FloatValue* height_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_limit_);
  }
  if (height_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(height_limit)->GetArena();
    if (message_arena != submessage_arena) {
      height_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_limit, submessage_arena);
    }
    
  } else {
    
  }
  height_limit_ = height_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.height_limit)
}

// .google.protobuf.FloatValue weight_limit = 11;
inline bool TrafficSignStatus::has_weight_limit() const {
  return this != internal_default_instance() && weight_limit_ != NULL;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::_internal_weight_limit() const {
  return *weight_limit_;
}
inline const ::google::protobuf::FloatValue& TrafficSignStatus::weight_limit() const {
  const ::google::protobuf::FloatValue* p = weight_limit_;
  // @@protoc_insertion_point(field_get:calmcar.perception.TrafficSignStatus.weight_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::release_weight_limit() {
  // @@protoc_insertion_point(field_release:calmcar.perception.TrafficSignStatus.weight_limit)
  
  ::google::protobuf::FloatValue* temp = weight_limit_;
  weight_limit_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* TrafficSignStatus::mutable_weight_limit() {
  
  if (weight_limit_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::FloatValue>(GetArenaNoVirtual());
    weight_limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.TrafficSignStatus.weight_limit)
  return weight_limit_;
}
inline void TrafficSignStatus::set_allocated_weight_limit(::google::protobuf::FloatValue* weight_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(weight_limit_);
  }
  if (weight_limit) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(weight_limit)->GetArena();
    if (message_arena != submessage_arena) {
      weight_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, weight_limit, submessage_arena);
    }
    
  } else {
    
  }
  weight_limit_ = weight_limit;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.TrafficSignStatus.weight_limit)
}

// -------------------------------------------------------------------

// Failsafe

// .calmcar.perception.CameraInfo.Position camera_position = 1;
inline void Failsafe::clear_camera_position() {
  camera_position_ = 0;
}
inline ::calmcar::perception::CameraInfo_Position Failsafe::camera_position() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.camera_position)
  return static_cast< ::calmcar::perception::CameraInfo_Position >(camera_position_);
}
inline void Failsafe::set_camera_position(::calmcar::perception::CameraInfo_Position value) {
  
  camera_position_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.camera_position)
}

// int64 timestamp = 2;
inline void Failsafe::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Failsafe::timestamp() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.timestamp)
  return timestamp_;
}
inline void Failsafe::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.timestamp)
}

// .calmcar.perception.Failsafe.FailSafeBlockage blockage_status = 3;
inline void Failsafe::clear_blockage_status() {
  blockage_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeBlockage Failsafe::blockage_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.blockage_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeBlockage >(blockage_status_);
}
inline void Failsafe::set_blockage_status(::calmcar::perception::Failsafe_FailSafeBlockage value) {
  
  blockage_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.blockage_status)
}

// string blockage_name = 4;
inline void Failsafe::clear_blockage_name() {
  blockage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::blockage_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.blockage_name)
  return blockage_name_.GetNoArena();
}
inline void Failsafe::set_blockage_name(const ::std::string& value) {
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.blockage_name)
}
#if LANG_CXX11
inline void Failsafe::set_blockage_name(::std::string&& value) {
  
  blockage_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.blockage_name)
}
#endif
inline void Failsafe::set_blockage_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.blockage_name)
}
inline void Failsafe::set_blockage_name(const char* value, size_t size) {
  
  blockage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.blockage_name)
}
inline ::std::string* Failsafe::mutable_blockage_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.blockage_name)
  return blockage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_blockage_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.blockage_name)
  
  return blockage_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_blockage_name(::std::string* blockage_name) {
  if (blockage_name != NULL) {
    
  } else {
    
  }
  blockage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blockage_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.blockage_name)
}

// .calmcar.perception.Failsafe.FailSafeWeather weather_status = 5;
inline void Failsafe::clear_weather_status() {
  weather_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeWeather Failsafe::weather_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.weather_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeWeather >(weather_status_);
}
inline void Failsafe::set_weather_status(::calmcar::perception::Failsafe_FailSafeWeather value) {
  
  weather_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.weather_status)
}

// string weather_name = 6;
inline void Failsafe::clear_weather_name() {
  weather_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::weather_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.weather_name)
  return weather_name_.GetNoArena();
}
inline void Failsafe::set_weather_name(const ::std::string& value) {
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.weather_name)
}
#if LANG_CXX11
inline void Failsafe::set_weather_name(::std::string&& value) {
  
  weather_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.weather_name)
}
#endif
inline void Failsafe::set_weather_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.weather_name)
}
inline void Failsafe::set_weather_name(const char* value, size_t size) {
  
  weather_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.weather_name)
}
inline ::std::string* Failsafe::mutable_weather_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.weather_name)
  return weather_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_weather_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.weather_name)
  
  return weather_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_weather_name(::std::string* weather_name) {
  if (weather_name != NULL) {
    
  } else {
    
  }
  weather_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weather_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.weather_name)
}

// .calmcar.perception.Failsafe.FailSafeIllumination illumination_status = 7;
inline void Failsafe::clear_illumination_status() {
  illumination_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeIllumination Failsafe::illumination_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.illumination_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeIllumination >(illumination_status_);
}
inline void Failsafe::set_illumination_status(::calmcar::perception::Failsafe_FailSafeIllumination value) {
  
  illumination_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.illumination_status)
}

// string illumination_name = 8;
inline void Failsafe::clear_illumination_name() {
  illumination_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::illumination_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.illumination_name)
  return illumination_name_.GetNoArena();
}
inline void Failsafe::set_illumination_name(const ::std::string& value) {
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.illumination_name)
}
#if LANG_CXX11
inline void Failsafe::set_illumination_name(::std::string&& value) {
  
  illumination_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.illumination_name)
}
#endif
inline void Failsafe::set_illumination_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.illumination_name)
}
inline void Failsafe::set_illumination_name(const char* value, size_t size) {
  
  illumination_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.illumination_name)
}
inline ::std::string* Failsafe::mutable_illumination_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.illumination_name)
  return illumination_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_illumination_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.illumination_name)
  
  return illumination_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_illumination_name(::std::string* illumination_name) {
  if (illumination_name != NULL) {
    
  } else {
    
  }
  illumination_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), illumination_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.illumination_name)
}

// .calmcar.perception.Failsafe.FailSafeImageLimited image_limited_status = 9;
inline void Failsafe::clear_image_limited_status() {
  image_limited_status_ = 0;
}
inline ::calmcar::perception::Failsafe_FailSafeImageLimited Failsafe::image_limited_status() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.image_limited_status)
  return static_cast< ::calmcar::perception::Failsafe_FailSafeImageLimited >(image_limited_status_);
}
inline void Failsafe::set_image_limited_status(::calmcar::perception::Failsafe_FailSafeImageLimited value) {
  
  image_limited_status_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.image_limited_status)
}

// string image_limited_name = 10;
inline void Failsafe::clear_image_limited_name() {
  image_limited_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Failsafe::image_limited_name() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.image_limited_name)
  return image_limited_name_.GetNoArena();
}
inline void Failsafe::set_image_limited_name(const ::std::string& value) {
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.image_limited_name)
}
#if LANG_CXX11
inline void Failsafe::set_image_limited_name(::std::string&& value) {
  
  image_limited_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calmcar.perception.Failsafe.image_limited_name)
}
#endif
inline void Failsafe::set_image_limited_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calmcar.perception.Failsafe.image_limited_name)
}
inline void Failsafe::set_image_limited_name(const char* value, size_t size) {
  
  image_limited_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calmcar.perception.Failsafe.image_limited_name)
}
inline ::std::string* Failsafe::mutable_image_limited_name() {
  
  // @@protoc_insertion_point(field_mutable:calmcar.perception.Failsafe.image_limited_name)
  return image_limited_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failsafe::release_image_limited_name() {
  // @@protoc_insertion_point(field_release:calmcar.perception.Failsafe.image_limited_name)
  
  return image_limited_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failsafe::set_allocated_image_limited_name(::std::string* image_limited_name) {
  if (image_limited_name != NULL) {
    
  } else {
    
  }
  image_limited_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_limited_name);
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.Failsafe.image_limited_name)
}

// bool out_of_focus = 11;
inline void Failsafe::clear_out_of_focus() {
  out_of_focus_ = false;
}
inline bool Failsafe::out_of_focus() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.out_of_focus)
  return out_of_focus_;
}
inline void Failsafe::set_out_of_focus(bool value) {
  
  out_of_focus_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.out_of_focus)
}

// int32 impacted_technologies = 12;
inline void Failsafe::clear_impacted_technologies() {
  impacted_technologies_ = 0;
}
inline ::google::protobuf::int32 Failsafe::impacted_technologies() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.Failsafe.impacted_technologies)
  return impacted_technologies_;
}
inline void Failsafe::set_impacted_technologies(::google::protobuf::int32 value) {
  
  impacted_technologies_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.Failsafe.impacted_technologies)
}

// -------------------------------------------------------------------

// PerceptionFrame

// .calmcar.perception.Header header = 1;
inline bool PerceptionFrame::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void PerceptionFrame::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::calmcar::perception::Header& PerceptionFrame::_internal_header() const {
  return *header_;
}
inline const ::calmcar::perception::Header& PerceptionFrame::header() const {
  const ::calmcar::perception::Header* p = header_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Header*>(
      &::calmcar::perception::_Header_default_instance_);
}
inline ::calmcar::perception::Header* PerceptionFrame::release_header() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.header)
  
  ::calmcar::perception::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::calmcar::perception::Header* PerceptionFrame::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.header)
  return header_;
}
inline void PerceptionFrame::set_allocated_header(::calmcar::perception::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.header)
}

// int64 vd_count = 2;
inline void PerceptionFrame::clear_vd_count() {
  vd_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_count)
  return vd_count_;
}
inline void PerceptionFrame::set_vd_count(::google::protobuf::int64 value) {
  
  vd_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_count)
}

// int64 vru_count = 3;
inline void PerceptionFrame::clear_vru_count() {
  vru_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vru_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vru_count)
  return vru_count_;
}
inline void PerceptionFrame::set_vru_count(::google::protobuf::int64 value) {
  
  vru_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vru_count)
}

// int64 num_of_objects = 4;
inline void PerceptionFrame::clear_num_of_objects() {
  num_of_objects_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::num_of_objects() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.num_of_objects)
  return num_of_objects_;
}
inline void PerceptionFrame::set_num_of_objects(::google::protobuf::int64 value) {
  
  num_of_objects_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.num_of_objects)
}

// int64 cipv_id = 5;
inline void PerceptionFrame::clear_cipv_id() {
  cipv_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::cipv_id() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.cipv_id)
  return cipv_id_;
}
inline void PerceptionFrame::set_cipv_id(::google::protobuf::int64 value) {
  
  cipv_id_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.cipv_id)
}

// int64 vd_niv_left = 6;
inline void PerceptionFrame::clear_vd_niv_left() {
  vd_niv_left_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_niv_left() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_niv_left)
  return vd_niv_left_;
}
inline void PerceptionFrame::set_vd_niv_left(::google::protobuf::int64 value) {
  
  vd_niv_left_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_niv_left)
}

// int64 vd_niv_right = 7;
inline void PerceptionFrame::clear_vd_niv_right() {
  vd_niv_right_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::vd_niv_right() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vd_niv_right)
  return vd_niv_right_;
}
inline void PerceptionFrame::set_vd_niv_right(::google::protobuf::int64 value) {
  
  vd_niv_right_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.vd_niv_right)
}

// .calmcar.perception.CipvLost cipv_lost = 8;
inline void PerceptionFrame::clear_cipv_lost() {
  cipv_lost_ = 0;
}
inline ::calmcar::perception::CipvLost PerceptionFrame::cipv_lost() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.cipv_lost)
  return static_cast< ::calmcar::perception::CipvLost >(cipv_lost_);
}
inline void PerceptionFrame::set_cipv_lost(::calmcar::perception::CipvLost value) {
  
  cipv_lost_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.cipv_lost)
}

// .calmcar.perception.AllowAcc allow_acc = 9;
inline void PerceptionFrame::clear_allow_acc() {
  allow_acc_ = 0;
}
inline ::calmcar::perception::AllowAcc PerceptionFrame::allow_acc() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.allow_acc)
  return static_cast< ::calmcar::perception::AllowAcc >(allow_acc_);
}
inline void PerceptionFrame::set_allow_acc(::calmcar::perception::AllowAcc value) {
  
  allow_acc_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.allow_acc)
}

// repeated .calmcar.perception.Object object = 10;
inline int PerceptionFrame::object_size() const {
  return object_.size();
}
inline void PerceptionFrame::clear_object() {
  object_.Clear();
}
inline ::calmcar::perception::Object* PerceptionFrame::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.object)
  return object_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >*
PerceptionFrame::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.object)
  return &object_;
}
inline const ::calmcar::perception::Object& PerceptionFrame::object(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.object)
  return object_.Get(index);
}
inline ::calmcar::perception::Object* PerceptionFrame::add_object() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.object)
  return object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Object >&
PerceptionFrame::object() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.object)
  return object_;
}

// repeated .calmcar.perception.RoadMark road_mark = 11;
inline int PerceptionFrame::road_mark_size() const {
  return road_mark_.size();
}
inline ::calmcar::perception::RoadMark* PerceptionFrame::mutable_road_mark(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >*
PerceptionFrame::mutable_road_mark() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.road_mark)
  return &road_mark_;
}
inline const ::calmcar::perception::RoadMark& PerceptionFrame::road_mark(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Get(index);
}
inline ::calmcar::perception::RoadMark* PerceptionFrame::add_road_mark() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::RoadMark >&
PerceptionFrame::road_mark() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.road_mark)
  return road_mark_;
}

// .calmcar.perception.Lane lane = 12;
inline bool PerceptionFrame::has_lane() const {
  return this != internal_default_instance() && lane_ != NULL;
}
inline const ::calmcar::perception::Lane& PerceptionFrame::_internal_lane() const {
  return *lane_;
}
inline const ::calmcar::perception::Lane& PerceptionFrame::lane() const {
  const ::calmcar::perception::Lane* p = lane_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.lane)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::Lane*>(
      &::calmcar::perception::_Lane_default_instance_);
}
inline ::calmcar::perception::Lane* PerceptionFrame::release_lane() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.lane)
  
  ::calmcar::perception::Lane* temp = lane_;
  lane_ = NULL;
  return temp;
}
inline ::calmcar::perception::Lane* PerceptionFrame::mutable_lane() {
  
  if (lane_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::Lane>(GetArenaNoVirtual());
    lane_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.lane)
  return lane_;
}
inline void PerceptionFrame::set_allocated_lane(::calmcar::perception::Lane* lane) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lane_);
  }
  if (lane) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane, submessage_arena);
    }
    
  } else {
    
  }
  lane_ = lane;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.lane)
}

// .calmcar.perception.FreeSpace free_space = 13;
inline bool PerceptionFrame::has_free_space() const {
  return this != internal_default_instance() && free_space_ != NULL;
}
inline const ::calmcar::perception::FreeSpace& PerceptionFrame::_internal_free_space() const {
  return *free_space_;
}
inline const ::calmcar::perception::FreeSpace& PerceptionFrame::free_space() const {
  const ::calmcar::perception::FreeSpace* p = free_space_;
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.free_space)
  return p != NULL ? *p : *reinterpret_cast<const ::calmcar::perception::FreeSpace*>(
      &::calmcar::perception::_FreeSpace_default_instance_);
}
inline ::calmcar::perception::FreeSpace* PerceptionFrame::release_free_space() {
  // @@protoc_insertion_point(field_release:calmcar.perception.PerceptionFrame.free_space)
  
  ::calmcar::perception::FreeSpace* temp = free_space_;
  free_space_ = NULL;
  return temp;
}
inline ::calmcar::perception::FreeSpace* PerceptionFrame::mutable_free_space() {
  
  if (free_space_ == NULL) {
    auto* p = CreateMaybeMessage<::calmcar::perception::FreeSpace>(GetArenaNoVirtual());
    free_space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.free_space)
  return free_space_;
}
inline void PerceptionFrame::set_allocated_free_space(::calmcar::perception::FreeSpace* free_space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(free_space_);
  }
  if (free_space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      free_space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, free_space, submessage_arena);
    }
    
  } else {
    
  }
  free_space_ = free_space;
  // @@protoc_insertion_point(field_set_allocated:calmcar.perception.PerceptionFrame.free_space)
}

// repeated .calmcar.perception.TrafficLight tfl_structure = 14;
inline int PerceptionFrame::tfl_structure_size() const {
  return tfl_structure_.size();
}
inline void PerceptionFrame::clear_tfl_structure() {
  tfl_structure_.Clear();
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::mutable_tfl_structure(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
PerceptionFrame::mutable_tfl_structure() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.tfl_structure)
  return &tfl_structure_;
}
inline const ::calmcar::perception::TrafficLight& PerceptionFrame::tfl_structure(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Get(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::add_tfl_structure() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
PerceptionFrame::tfl_structure() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.tfl_structure)
  return tfl_structure_;
}

// repeated .calmcar.perception.TrafficLight tfl_struct_state = 15;
inline int PerceptionFrame::tfl_struct_state_size() const {
  return tfl_struct_state_.size();
}
inline void PerceptionFrame::clear_tfl_struct_state() {
  tfl_struct_state_.Clear();
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::mutable_tfl_struct_state(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >*
PerceptionFrame::mutable_tfl_struct_state() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return &tfl_struct_state_;
}
inline const ::calmcar::perception::TrafficLight& PerceptionFrame::tfl_struct_state(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Get(index);
}
inline ::calmcar::perception::TrafficLight* PerceptionFrame::add_tfl_struct_state() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficLight >&
PerceptionFrame::tfl_struct_state() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.tfl_struct_state)
  return tfl_struct_state_;
}

// int64 tfl_struct_count = 16;
inline void PerceptionFrame::clear_tfl_struct_count() {
  tfl_struct_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::tfl_struct_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_struct_count)
  return tfl_struct_count_;
}
inline void PerceptionFrame::set_tfl_struct_count(::google::protobuf::int64 value) {
  
  tfl_struct_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.tfl_struct_count)
}

// int64 tfl_spot_count = 17;
inline void PerceptionFrame::clear_tfl_spot_count() {
  tfl_spot_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::tfl_spot_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.tfl_spot_count)
  return tfl_spot_count_;
}
inline void PerceptionFrame::set_tfl_spot_count(::google::protobuf::int64 value) {
  
  tfl_spot_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.tfl_spot_count)
}

// repeated .calmcar.perception.TrafficSign traffic_sign = 18;
inline int PerceptionFrame::traffic_sign_size() const {
  return traffic_sign_.size();
}
inline void PerceptionFrame::clear_traffic_sign() {
  traffic_sign_.Clear();
}
inline ::calmcar::perception::TrafficSign* PerceptionFrame::mutable_traffic_sign(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >*
PerceptionFrame::mutable_traffic_sign() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.traffic_sign)
  return &traffic_sign_;
}
inline const ::calmcar::perception::TrafficSign& PerceptionFrame::traffic_sign(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Get(index);
}
inline ::calmcar::perception::TrafficSign* PerceptionFrame::add_traffic_sign() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSign >&
PerceptionFrame::traffic_sign() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.traffic_sign)
  return traffic_sign_;
}

// repeated .calmcar.perception.TrafficSignStatus traffic_sign_status = 19;
inline int PerceptionFrame::traffic_sign_status_size() const {
  return traffic_sign_status_.size();
}
inline void PerceptionFrame::clear_traffic_sign_status() {
  traffic_sign_status_.Clear();
}
inline ::calmcar::perception::TrafficSignStatus* PerceptionFrame::mutable_traffic_sign_status(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >*
PerceptionFrame::mutable_traffic_sign_status() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return &traffic_sign_status_;
}
inline const ::calmcar::perception::TrafficSignStatus& PerceptionFrame::traffic_sign_status(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Get(index);
}
inline ::calmcar::perception::TrafficSignStatus* PerceptionFrame::add_traffic_sign_status() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::TrafficSignStatus >&
PerceptionFrame::traffic_sign_status() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.traffic_sign_status)
  return traffic_sign_status_;
}

// repeated .calmcar.perception.Failsafe failsafe = 20;
inline int PerceptionFrame::failsafe_size() const {
  return failsafe_.size();
}
inline void PerceptionFrame::clear_failsafe() {
  failsafe_.Clear();
}
inline ::calmcar::perception::Failsafe* PerceptionFrame::mutable_failsafe(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >*
PerceptionFrame::mutable_failsafe() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.failsafe)
  return &failsafe_;
}
inline const ::calmcar::perception::Failsafe& PerceptionFrame::failsafe(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Get(index);
}
inline ::calmcar::perception::Failsafe* PerceptionFrame::add_failsafe() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Failsafe >&
PerceptionFrame::failsafe() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.failsafe)
  return failsafe_;
}

// repeated .calmcar.perception.Vehicle vehicle_info = 21;
inline int PerceptionFrame::vehicle_info_size() const {
  return vehicle_info_.size();
}
inline ::calmcar::perception::Vehicle* PerceptionFrame::mutable_vehicle_info(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >*
PerceptionFrame::mutable_vehicle_info() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.vehicle_info)
  return &vehicle_info_;
}
inline const ::calmcar::perception::Vehicle& PerceptionFrame::vehicle_info(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Get(index);
}
inline ::calmcar::perception::Vehicle* PerceptionFrame::add_vehicle_info() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Vehicle >&
PerceptionFrame::vehicle_info() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.vehicle_info)
  return vehicle_info_;
}

// int64 barricade_count = 22;
inline void PerceptionFrame::clear_barricade_count() {
  barricade_count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PerceptionFrame::barricade_count() const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.barricade_count)
  return barricade_count_;
}
inline void PerceptionFrame::set_barricade_count(::google::protobuf::int64 value) {
  
  barricade_count_ = value;
  // @@protoc_insertion_point(field_set:calmcar.perception.PerceptionFrame.barricade_count)
}

// repeated .calmcar.perception.Barricade barricade_object = 23;
inline int PerceptionFrame::barricade_object_size() const {
  return barricade_object_.size();
}
inline ::calmcar::perception::Barricade* PerceptionFrame::mutable_barricade_object(int index) {
  // @@protoc_insertion_point(field_mutable:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >*
PerceptionFrame::mutable_barricade_object() {
  // @@protoc_insertion_point(field_mutable_list:calmcar.perception.PerceptionFrame.barricade_object)
  return &barricade_object_;
}
inline const ::calmcar::perception::Barricade& PerceptionFrame::barricade_object(int index) const {
  // @@protoc_insertion_point(field_get:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Get(index);
}
inline ::calmcar::perception::Barricade* PerceptionFrame::add_barricade_object() {
  // @@protoc_insertion_point(field_add:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::calmcar::perception::Barricade >&
PerceptionFrame::barricade_object() const {
  // @@protoc_insertion_point(field_list:calmcar.perception.PerceptionFrame.barricade_object)
  return barricade_object_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace calmcar

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::calmcar::perception::Header_ProtobufVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_ProtobufVersion>() {
  return ::calmcar::perception::Header_ProtobufVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_ObjectVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_ObjectVersion>() {
  return ::calmcar::perception::Header_ObjectVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficLightStructVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficLightStructVersion>() {
  return ::calmcar::perception::Header_TrafficLightStructVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficLightSpotVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficLightSpotVersion>() {
  return ::calmcar::perception::Header_TrafficLightSpotVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_TrafficSignVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_TrafficSignVersion>() {
  return ::calmcar::perception::Header_TrafficSignVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_FailSafeVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_FailSafeVersion>() {
  return ::calmcar::perception::Header_FailSafeVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_LaneVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_LaneVersion>() {
  return ::calmcar::perception::Header_LaneVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_RoadMarkVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_RoadMarkVersion>() {
  return ::calmcar::perception::Header_RoadMarkVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_FreeSpaceVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_FreeSpaceVersion>() {
  return ::calmcar::perception::Header_FreeSpaceVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Header_BarricadeVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Header_BarricadeVersion>() {
  return ::calmcar::perception::Header_BarricadeVersion_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Color>() {
  return ::calmcar::perception::TrafficLight_Color_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Type>() {
  return ::calmcar::perception::TrafficLight_Type_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficLight_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficLight_Mode>() {
  return ::calmcar::perception::TrafficLight_Mode_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy>() {
  return ::calmcar::perception::TrafficSign_TrafficSIgnRelevancy_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_Type>() {
  return ::calmcar::perception::TrafficSignType_Type_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_ProhibitionSign> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_ProhibitionSign>() {
  return ::calmcar::perception::TrafficSignType_ProhibitionSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_WarningSign> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_WarningSign>() {
  return ::calmcar::perception::TrafficSignType_WarningSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::TrafficSignType_AssistSign> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::TrafficSignType_AssistSign>() {
  return ::calmcar::perception::TrafficSignType_AssistSign_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeBlockage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeBlockage>() {
  return ::calmcar::perception::Failsafe_FailSafeBlockage_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeWeather> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeWeather>() {
  return ::calmcar::perception::Failsafe_FailSafeWeather_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeIllumination> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeIllumination>() {
  return ::calmcar::perception::Failsafe_FailSafeIllumination_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::Failsafe_FailSafeImageLimited> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::Failsafe_FailSafeImageLimited>() {
  return ::calmcar::perception::Failsafe_FailSafeImageLimited_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus0> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus0>() {
  return ::calmcar::perception::MeasuringStatus0_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus1> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus1>() {
  return ::calmcar::perception::MeasuringStatus1_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MeasuringStatus2> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MeasuringStatus2>() {
  return ::calmcar::perception::MeasuringStatus2_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionCategory>() {
  return ::calmcar::perception::MotionCategory_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionOrientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionOrientation>() {
  return ::calmcar::perception::MotionOrientation_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::VisibilitySide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::VisibilitySide>() {
  return ::calmcar::perception::VisibilitySide_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::MotionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::MotionStatus>() {
  return ::calmcar::perception::MotionStatus_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::CutInCutOut> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::CutInCutOut>() {
  return ::calmcar::perception::CutInCutOut_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::CipvLost> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::CipvLost>() {
  return ::calmcar::perception::CipvLost_descriptor();
}
template <> struct is_proto_enum< ::calmcar::perception::AllowAcc> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::calmcar::perception::AllowAcc>() {
  return ::calmcar::perception::AllowAcc_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_perception_2eproto
