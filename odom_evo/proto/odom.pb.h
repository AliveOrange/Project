// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: odom.proto

#ifndef PROTOBUF_INCLUDED_odom_2eproto
#define PROTOBUF_INCLUDED_odom_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_odom_2eproto 

namespace protobuf_odom_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_odom_2eproto
namespace odom {
namespace proto {
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Frame_Header;
class Frame_HeaderDefaultTypeInternal;
extern Frame_HeaderDefaultTypeInternal _Frame_Header_default_instance_;
class Frame_Info;
class Frame_InfoDefaultTypeInternal;
extern Frame_InfoDefaultTypeInternal _Frame_Info_default_instance_;
class Odom;
class OdomDefaultTypeInternal;
extern OdomDefaultTypeInternal _Odom_default_instance_;
class Odom_AngleSpeed;
class Odom_AngleSpeedDefaultTypeInternal;
extern Odom_AngleSpeedDefaultTypeInternal _Odom_AngleSpeed_default_instance_;
class Odom_AngleSpeedStd;
class Odom_AngleSpeedStdDefaultTypeInternal;
extern Odom_AngleSpeedStdDefaultTypeInternal _Odom_AngleSpeedStd_default_instance_;
class Odom_LinearSpeed;
class Odom_LinearSpeedDefaultTypeInternal;
extern Odom_LinearSpeedDefaultTypeInternal _Odom_LinearSpeed_default_instance_;
class Odom_LinearSpeedStd;
class Odom_LinearSpeedStdDefaultTypeInternal;
extern Odom_LinearSpeedStdDefaultTypeInternal _Odom_LinearSpeedStd_default_instance_;
class Odom_PoseQuaternion;
class Odom_PoseQuaternionDefaultTypeInternal;
extern Odom_PoseQuaternionDefaultTypeInternal _Odom_PoseQuaternion_default_instance_;
class Odom_PoseStd;
class Odom_PoseStdDefaultTypeInternal;
extern Odom_PoseStdDefaultTypeInternal _Odom_PoseStd_default_instance_;
class Odom_Position;
class Odom_PositionDefaultTypeInternal;
extern Odom_PositionDefaultTypeInternal _Odom_Position_default_instance_;
class Odom_PositionStd;
class Odom_PositionStdDefaultTypeInternal;
extern Odom_PositionStdDefaultTypeInternal _Odom_PositionStd_default_instance_;
class Odom_TransformMatrix;
class Odom_TransformMatrixDefaultTypeInternal;
extern Odom_TransformMatrixDefaultTypeInternal _Odom_TransformMatrix_default_instance_;
}  // namespace proto
}  // namespace odom
namespace google {
namespace protobuf {
template<> ::odom::proto::Frame* Arena::CreateMaybeMessage<::odom::proto::Frame>(Arena*);
template<> ::odom::proto::Frame_Header* Arena::CreateMaybeMessage<::odom::proto::Frame_Header>(Arena*);
template<> ::odom::proto::Frame_Info* Arena::CreateMaybeMessage<::odom::proto::Frame_Info>(Arena*);
template<> ::odom::proto::Odom* Arena::CreateMaybeMessage<::odom::proto::Odom>(Arena*);
template<> ::odom::proto::Odom_AngleSpeed* Arena::CreateMaybeMessage<::odom::proto::Odom_AngleSpeed>(Arena*);
template<> ::odom::proto::Odom_AngleSpeedStd* Arena::CreateMaybeMessage<::odom::proto::Odom_AngleSpeedStd>(Arena*);
template<> ::odom::proto::Odom_LinearSpeed* Arena::CreateMaybeMessage<::odom::proto::Odom_LinearSpeed>(Arena*);
template<> ::odom::proto::Odom_LinearSpeedStd* Arena::CreateMaybeMessage<::odom::proto::Odom_LinearSpeedStd>(Arena*);
template<> ::odom::proto::Odom_PoseQuaternion* Arena::CreateMaybeMessage<::odom::proto::Odom_PoseQuaternion>(Arena*);
template<> ::odom::proto::Odom_PoseStd* Arena::CreateMaybeMessage<::odom::proto::Odom_PoseStd>(Arena*);
template<> ::odom::proto::Odom_Position* Arena::CreateMaybeMessage<::odom::proto::Odom_Position>(Arena*);
template<> ::odom::proto::Odom_PositionStd* Arena::CreateMaybeMessage<::odom::proto::Odom_PositionStd>(Arena*);
template<> ::odom::proto::Odom_TransformMatrix* Arena::CreateMaybeMessage<::odom::proto::Odom_TransformMatrix>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace odom {
namespace proto {

enum OdomId {
  ODOM_CHASSIS = 0,
  ODOM_INS = 1,
  OdomId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdomId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdomId_IsValid(int value);
const OdomId OdomId_MIN = ODOM_CHASSIS;
const OdomId OdomId_MAX = ODOM_INS;
const int OdomId_ARRAYSIZE = OdomId_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdomId_descriptor();
inline const ::std::string& OdomId_Name(OdomId value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdomId_descriptor(), value);
}
inline bool OdomId_Parse(
    const ::std::string& name, OdomId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdomId>(
    OdomId_descriptor(), name, value);
}
// ===================================================================

class Odom_Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.Position) */ {
 public:
  Odom_Position();
  virtual ~Odom_Position();

  Odom_Position(const Odom_Position& from);

  inline Odom_Position& operator=(const Odom_Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_Position(Odom_Position&& from) noexcept
    : Odom_Position() {
    *this = ::std::move(from);
  }

  inline Odom_Position& operator=(Odom_Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_Position* internal_default_instance() {
    return reinterpret_cast<const Odom_Position*>(
               &_Odom_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Odom_Position* other);
  friend void swap(Odom_Position& a, Odom_Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_Position* New() const final {
    return CreateMaybeMessage<Odom_Position>(NULL);
  }

  Odom_Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_Position& from);
  void MergeFrom(const Odom_Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_PositionStd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.PositionStd) */ {
 public:
  Odom_PositionStd();
  virtual ~Odom_PositionStd();

  Odom_PositionStd(const Odom_PositionStd& from);

  inline Odom_PositionStd& operator=(const Odom_PositionStd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_PositionStd(Odom_PositionStd&& from) noexcept
    : Odom_PositionStd() {
    *this = ::std::move(from);
  }

  inline Odom_PositionStd& operator=(Odom_PositionStd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_PositionStd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_PositionStd* internal_default_instance() {
    return reinterpret_cast<const Odom_PositionStd*>(
               &_Odom_PositionStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Odom_PositionStd* other);
  friend void swap(Odom_PositionStd& a, Odom_PositionStd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_PositionStd* New() const final {
    return CreateMaybeMessage<Odom_PositionStd>(NULL);
  }

  Odom_PositionStd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_PositionStd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_PositionStd& from);
  void MergeFrom(const Odom_PositionStd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_PositionStd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x_std = 1;
  void clear_x_std();
  static const int kXStdFieldNumber = 1;
  double x_std() const;
  void set_x_std(double value);

  // double y_std = 2;
  void clear_y_std();
  static const int kYStdFieldNumber = 2;
  double y_std() const;
  void set_y_std(double value);

  // double z_std = 3;
  void clear_z_std();
  static const int kZStdFieldNumber = 3;
  double z_std() const;
  void set_z_std(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.PositionStd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_std_;
  double y_std_;
  double z_std_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_PoseQuaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.PoseQuaternion) */ {
 public:
  Odom_PoseQuaternion();
  virtual ~Odom_PoseQuaternion();

  Odom_PoseQuaternion(const Odom_PoseQuaternion& from);

  inline Odom_PoseQuaternion& operator=(const Odom_PoseQuaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_PoseQuaternion(Odom_PoseQuaternion&& from) noexcept
    : Odom_PoseQuaternion() {
    *this = ::std::move(from);
  }

  inline Odom_PoseQuaternion& operator=(Odom_PoseQuaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_PoseQuaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_PoseQuaternion* internal_default_instance() {
    return reinterpret_cast<const Odom_PoseQuaternion*>(
               &_Odom_PoseQuaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Odom_PoseQuaternion* other);
  friend void swap(Odom_PoseQuaternion& a, Odom_PoseQuaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_PoseQuaternion* New() const final {
    return CreateMaybeMessage<Odom_PoseQuaternion>(NULL);
  }

  Odom_PoseQuaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_PoseQuaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_PoseQuaternion& from);
  void MergeFrom(const Odom_PoseQuaternion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_PoseQuaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double w = 1;
  void clear_w();
  static const int kWFieldNumber = 1;
  double w() const;
  void set_w(double value);

  // double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // double z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.PoseQuaternion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double w_;
  double x_;
  double y_;
  double z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_PoseStd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.PoseStd) */ {
 public:
  Odom_PoseStd();
  virtual ~Odom_PoseStd();

  Odom_PoseStd(const Odom_PoseStd& from);

  inline Odom_PoseStd& operator=(const Odom_PoseStd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_PoseStd(Odom_PoseStd&& from) noexcept
    : Odom_PoseStd() {
    *this = ::std::move(from);
  }

  inline Odom_PoseStd& operator=(Odom_PoseStd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_PoseStd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_PoseStd* internal_default_instance() {
    return reinterpret_cast<const Odom_PoseStd*>(
               &_Odom_PoseStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Odom_PoseStd* other);
  friend void swap(Odom_PoseStd& a, Odom_PoseStd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_PoseStd* New() const final {
    return CreateMaybeMessage<Odom_PoseStd>(NULL);
  }

  Odom_PoseStd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_PoseStd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_PoseStd& from);
  void MergeFrom(const Odom_PoseStd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_PoseStd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double roll_std = 1;
  void clear_roll_std();
  static const int kRollStdFieldNumber = 1;
  double roll_std() const;
  void set_roll_std(double value);

  // double pitch_std = 2;
  void clear_pitch_std();
  static const int kPitchStdFieldNumber = 2;
  double pitch_std() const;
  void set_pitch_std(double value);

  // double yaw_std = 3;
  void clear_yaw_std();
  static const int kYawStdFieldNumber = 3;
  double yaw_std() const;
  void set_yaw_std(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.PoseStd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double roll_std_;
  double pitch_std_;
  double yaw_std_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_AngleSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.AngleSpeed) */ {
 public:
  Odom_AngleSpeed();
  virtual ~Odom_AngleSpeed();

  Odom_AngleSpeed(const Odom_AngleSpeed& from);

  inline Odom_AngleSpeed& operator=(const Odom_AngleSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_AngleSpeed(Odom_AngleSpeed&& from) noexcept
    : Odom_AngleSpeed() {
    *this = ::std::move(from);
  }

  inline Odom_AngleSpeed& operator=(Odom_AngleSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_AngleSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_AngleSpeed* internal_default_instance() {
    return reinterpret_cast<const Odom_AngleSpeed*>(
               &_Odom_AngleSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Odom_AngleSpeed* other);
  friend void swap(Odom_AngleSpeed& a, Odom_AngleSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_AngleSpeed* New() const final {
    return CreateMaybeMessage<Odom_AngleSpeed>(NULL);
  }

  Odom_AngleSpeed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_AngleSpeed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_AngleSpeed& from);
  void MergeFrom(const Odom_AngleSpeed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_AngleSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double roll = 1;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  double roll() const;
  void set_roll(double value);

  // double pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  double pitch() const;
  void set_pitch(double value);

  // double yaw = 3;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  double yaw() const;
  void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.AngleSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double roll_;
  double pitch_;
  double yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_AngleSpeedStd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.AngleSpeedStd) */ {
 public:
  Odom_AngleSpeedStd();
  virtual ~Odom_AngleSpeedStd();

  Odom_AngleSpeedStd(const Odom_AngleSpeedStd& from);

  inline Odom_AngleSpeedStd& operator=(const Odom_AngleSpeedStd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_AngleSpeedStd(Odom_AngleSpeedStd&& from) noexcept
    : Odom_AngleSpeedStd() {
    *this = ::std::move(from);
  }

  inline Odom_AngleSpeedStd& operator=(Odom_AngleSpeedStd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_AngleSpeedStd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_AngleSpeedStd* internal_default_instance() {
    return reinterpret_cast<const Odom_AngleSpeedStd*>(
               &_Odom_AngleSpeedStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Odom_AngleSpeedStd* other);
  friend void swap(Odom_AngleSpeedStd& a, Odom_AngleSpeedStd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_AngleSpeedStd* New() const final {
    return CreateMaybeMessage<Odom_AngleSpeedStd>(NULL);
  }

  Odom_AngleSpeedStd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_AngleSpeedStd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_AngleSpeedStd& from);
  void MergeFrom(const Odom_AngleSpeedStd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_AngleSpeedStd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double roll_std = 1;
  void clear_roll_std();
  static const int kRollStdFieldNumber = 1;
  double roll_std() const;
  void set_roll_std(double value);

  // double pitch_std = 2;
  void clear_pitch_std();
  static const int kPitchStdFieldNumber = 2;
  double pitch_std() const;
  void set_pitch_std(double value);

  // double yaw_std = 3;
  void clear_yaw_std();
  static const int kYawStdFieldNumber = 3;
  double yaw_std() const;
  void set_yaw_std(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.AngleSpeedStd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double roll_std_;
  double pitch_std_;
  double yaw_std_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_LinearSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.LinearSpeed) */ {
 public:
  Odom_LinearSpeed();
  virtual ~Odom_LinearSpeed();

  Odom_LinearSpeed(const Odom_LinearSpeed& from);

  inline Odom_LinearSpeed& operator=(const Odom_LinearSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_LinearSpeed(Odom_LinearSpeed&& from) noexcept
    : Odom_LinearSpeed() {
    *this = ::std::move(from);
  }

  inline Odom_LinearSpeed& operator=(Odom_LinearSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_LinearSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_LinearSpeed* internal_default_instance() {
    return reinterpret_cast<const Odom_LinearSpeed*>(
               &_Odom_LinearSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Odom_LinearSpeed* other);
  friend void swap(Odom_LinearSpeed& a, Odom_LinearSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_LinearSpeed* New() const final {
    return CreateMaybeMessage<Odom_LinearSpeed>(NULL);
  }

  Odom_LinearSpeed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_LinearSpeed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_LinearSpeed& from);
  void MergeFrom(const Odom_LinearSpeed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_LinearSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double vehicle_speed = 4;
  void clear_vehicle_speed();
  static const int kVehicleSpeedFieldNumber = 4;
  double vehicle_speed() const;
  void set_vehicle_speed(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.LinearSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double vehicle_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_LinearSpeedStd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.LinearSpeedStd) */ {
 public:
  Odom_LinearSpeedStd();
  virtual ~Odom_LinearSpeedStd();

  Odom_LinearSpeedStd(const Odom_LinearSpeedStd& from);

  inline Odom_LinearSpeedStd& operator=(const Odom_LinearSpeedStd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_LinearSpeedStd(Odom_LinearSpeedStd&& from) noexcept
    : Odom_LinearSpeedStd() {
    *this = ::std::move(from);
  }

  inline Odom_LinearSpeedStd& operator=(Odom_LinearSpeedStd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_LinearSpeedStd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_LinearSpeedStd* internal_default_instance() {
    return reinterpret_cast<const Odom_LinearSpeedStd*>(
               &_Odom_LinearSpeedStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Odom_LinearSpeedStd* other);
  friend void swap(Odom_LinearSpeedStd& a, Odom_LinearSpeedStd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_LinearSpeedStd* New() const final {
    return CreateMaybeMessage<Odom_LinearSpeedStd>(NULL);
  }

  Odom_LinearSpeedStd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_LinearSpeedStd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_LinearSpeedStd& from);
  void MergeFrom(const Odom_LinearSpeedStd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_LinearSpeedStd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x_std = 1;
  void clear_x_std();
  static const int kXStdFieldNumber = 1;
  double x_std() const;
  void set_x_std(double value);

  // double y_std = 2;
  void clear_y_std();
  static const int kYStdFieldNumber = 2;
  double y_std() const;
  void set_y_std(double value);

  // double z_std = 3;
  void clear_z_std();
  static const int kZStdFieldNumber = 3;
  double z_std() const;
  void set_z_std(double value);

  // double vehicle_speed_std = 4;
  void clear_vehicle_speed_std();
  static const int kVehicleSpeedStdFieldNumber = 4;
  double vehicle_speed_std() const;
  void set_vehicle_speed_std(double value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.LinearSpeedStd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_std_;
  double y_std_;
  double z_std_;
  double vehicle_speed_std_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom_TransformMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom.TransformMatrix) */ {
 public:
  Odom_TransformMatrix();
  virtual ~Odom_TransformMatrix();

  Odom_TransformMatrix(const Odom_TransformMatrix& from);

  inline Odom_TransformMatrix& operator=(const Odom_TransformMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom_TransformMatrix(Odom_TransformMatrix&& from) noexcept
    : Odom_TransformMatrix() {
    *this = ::std::move(from);
  }

  inline Odom_TransformMatrix& operator=(Odom_TransformMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom_TransformMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom_TransformMatrix* internal_default_instance() {
    return reinterpret_cast<const Odom_TransformMatrix*>(
               &_Odom_TransformMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Odom_TransformMatrix* other);
  friend void swap(Odom_TransformMatrix& a, Odom_TransformMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom_TransformMatrix* New() const final {
    return CreateMaybeMessage<Odom_TransformMatrix>(NULL);
  }

  Odom_TransformMatrix* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom_TransformMatrix>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom_TransformMatrix& from);
  void MergeFrom(const Odom_TransformMatrix& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom_TransformMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double data = 3;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField< double >&
      data() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // int32 rows = 1;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  ::google::protobuf::int32 rows() const;
  void set_rows(::google::protobuf::int32 value);

  // int32 columns = 2;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  ::google::protobuf::int32 columns() const;
  void set_columns(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom.TransformMatrix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 columns_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Odom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Odom) */ {
 public:
  Odom();
  virtual ~Odom();

  Odom(const Odom& from);

  inline Odom& operator=(const Odom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odom(Odom&& from) noexcept
    : Odom() {
    *this = ::std::move(from);
  }

  inline Odom& operator=(Odom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odom* internal_default_instance() {
    return reinterpret_cast<const Odom*>(
               &_Odom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Odom* other);
  friend void swap(Odom& a, Odom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odom* New() const final {
    return CreateMaybeMessage<Odom>(NULL);
  }

  Odom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Odom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Odom& from);
  void MergeFrom(const Odom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Odom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Odom_Position Position;
  typedef Odom_PositionStd PositionStd;
  typedef Odom_PoseQuaternion PoseQuaternion;
  typedef Odom_PoseStd PoseStd;
  typedef Odom_AngleSpeed AngleSpeed;
  typedef Odom_AngleSpeedStd AngleSpeedStd;
  typedef Odom_LinearSpeed LinearSpeed;
  typedef Odom_LinearSpeedStd LinearSpeedStd;
  typedef Odom_TransformMatrix TransformMatrix;

  // accessors -------------------------------------------------------

  // .odom.proto.Odom.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::odom::proto::Odom_Position& _internal_position() const;
  public:
  const ::odom::proto::Odom_Position& position() const;
  ::odom::proto::Odom_Position* release_position();
  ::odom::proto::Odom_Position* mutable_position();
  void set_allocated_position(::odom::proto::Odom_Position* position);

  // .odom.proto.Odom.PositionStd position_std = 2;
  bool has_position_std() const;
  void clear_position_std();
  static const int kPositionStdFieldNumber = 2;
  private:
  const ::odom::proto::Odom_PositionStd& _internal_position_std() const;
  public:
  const ::odom::proto::Odom_PositionStd& position_std() const;
  ::odom::proto::Odom_PositionStd* release_position_std();
  ::odom::proto::Odom_PositionStd* mutable_position_std();
  void set_allocated_position_std(::odom::proto::Odom_PositionStd* position_std);

  // .odom.proto.Odom.PoseQuaternion pose_quaternion = 3;
  bool has_pose_quaternion() const;
  void clear_pose_quaternion();
  static const int kPoseQuaternionFieldNumber = 3;
  private:
  const ::odom::proto::Odom_PoseQuaternion& _internal_pose_quaternion() const;
  public:
  const ::odom::proto::Odom_PoseQuaternion& pose_quaternion() const;
  ::odom::proto::Odom_PoseQuaternion* release_pose_quaternion();
  ::odom::proto::Odom_PoseQuaternion* mutable_pose_quaternion();
  void set_allocated_pose_quaternion(::odom::proto::Odom_PoseQuaternion* pose_quaternion);

  // .odom.proto.Odom.PoseStd pose_std = 4;
  bool has_pose_std() const;
  void clear_pose_std();
  static const int kPoseStdFieldNumber = 4;
  private:
  const ::odom::proto::Odom_PoseStd& _internal_pose_std() const;
  public:
  const ::odom::proto::Odom_PoseStd& pose_std() const;
  ::odom::proto::Odom_PoseStd* release_pose_std();
  ::odom::proto::Odom_PoseStd* mutable_pose_std();
  void set_allocated_pose_std(::odom::proto::Odom_PoseStd* pose_std);

  // .odom.proto.Odom.AngleSpeed angle_speed = 5;
  bool has_angle_speed() const;
  void clear_angle_speed();
  static const int kAngleSpeedFieldNumber = 5;
  private:
  const ::odom::proto::Odom_AngleSpeed& _internal_angle_speed() const;
  public:
  const ::odom::proto::Odom_AngleSpeed& angle_speed() const;
  ::odom::proto::Odom_AngleSpeed* release_angle_speed();
  ::odom::proto::Odom_AngleSpeed* mutable_angle_speed();
  void set_allocated_angle_speed(::odom::proto::Odom_AngleSpeed* angle_speed);

  // .odom.proto.Odom.AngleSpeedStd angle_speed_std = 6;
  bool has_angle_speed_std() const;
  void clear_angle_speed_std();
  static const int kAngleSpeedStdFieldNumber = 6;
  private:
  const ::odom::proto::Odom_AngleSpeedStd& _internal_angle_speed_std() const;
  public:
  const ::odom::proto::Odom_AngleSpeedStd& angle_speed_std() const;
  ::odom::proto::Odom_AngleSpeedStd* release_angle_speed_std();
  ::odom::proto::Odom_AngleSpeedStd* mutable_angle_speed_std();
  void set_allocated_angle_speed_std(::odom::proto::Odom_AngleSpeedStd* angle_speed_std);

  // .odom.proto.Odom.LinearSpeed linear_speed = 7;
  bool has_linear_speed() const;
  void clear_linear_speed();
  static const int kLinearSpeedFieldNumber = 7;
  private:
  const ::odom::proto::Odom_LinearSpeed& _internal_linear_speed() const;
  public:
  const ::odom::proto::Odom_LinearSpeed& linear_speed() const;
  ::odom::proto::Odom_LinearSpeed* release_linear_speed();
  ::odom::proto::Odom_LinearSpeed* mutable_linear_speed();
  void set_allocated_linear_speed(::odom::proto::Odom_LinearSpeed* linear_speed);

  // .odom.proto.Odom.LinearSpeedStd linear_speed_std = 8;
  bool has_linear_speed_std() const;
  void clear_linear_speed_std();
  static const int kLinearSpeedStdFieldNumber = 8;
  private:
  const ::odom::proto::Odom_LinearSpeedStd& _internal_linear_speed_std() const;
  public:
  const ::odom::proto::Odom_LinearSpeedStd& linear_speed_std() const;
  ::odom::proto::Odom_LinearSpeedStd* release_linear_speed_std();
  ::odom::proto::Odom_LinearSpeedStd* mutable_linear_speed_std();
  void set_allocated_linear_speed_std(::odom::proto::Odom_LinearSpeedStd* linear_speed_std);

  // .odom.proto.Odom.TransformMatrix transform_matrix = 9;
  bool has_transform_matrix() const;
  void clear_transform_matrix();
  static const int kTransformMatrixFieldNumber = 9;
  private:
  const ::odom::proto::Odom_TransformMatrix& _internal_transform_matrix() const;
  public:
  const ::odom::proto::Odom_TransformMatrix& transform_matrix() const;
  ::odom::proto::Odom_TransformMatrix* release_transform_matrix();
  ::odom::proto::Odom_TransformMatrix* mutable_transform_matrix();
  void set_allocated_transform_matrix(::odom::proto::Odom_TransformMatrix* transform_matrix);

  // @@protoc_insertion_point(class_scope:odom.proto.Odom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::odom::proto::Odom_Position* position_;
  ::odom::proto::Odom_PositionStd* position_std_;
  ::odom::proto::Odom_PoseQuaternion* pose_quaternion_;
  ::odom::proto::Odom_PoseStd* pose_std_;
  ::odom::proto::Odom_AngleSpeed* angle_speed_;
  ::odom::proto::Odom_AngleSpeedStd* angle_speed_std_;
  ::odom::proto::Odom_LinearSpeed* linear_speed_;
  ::odom::proto::Odom_LinearSpeedStd* linear_speed_std_;
  ::odom::proto::Odom_TransformMatrix* transform_matrix_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Frame_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Frame.Header) */ {
 public:
  Frame_Header();
  virtual ~Frame_Header();

  Frame_Header(const Frame_Header& from);

  inline Frame_Header& operator=(const Frame_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Frame_Header(Frame_Header&& from) noexcept
    : Frame_Header() {
    *this = ::std::move(from);
  }

  inline Frame_Header& operator=(Frame_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame_Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame_Header* internal_default_instance() {
    return reinterpret_cast<const Frame_Header*>(
               &_Frame_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Frame_Header* other);
  friend void swap(Frame_Header& a, Frame_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Frame_Header* New() const final {
    return CreateMaybeMessage<Frame_Header>(NULL);
  }

  Frame_Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Frame_Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Frame_Header& from);
  void MergeFrom(const Frame_Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string frame_id = 4;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 4;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // uint64 sys_timestamp = 2;
  void clear_sys_timestamp();
  static const int kSysTimestampFieldNumber = 2;
  ::google::protobuf::uint64 sys_timestamp() const;
  void set_sys_timestamp(::google::protobuf::uint64 value);

  // uint64 rolling_counter = 3;
  void clear_rolling_counter();
  static const int kRollingCounterFieldNumber = 3;
  ::google::protobuf::uint64 rolling_counter() const;
  void set_rolling_counter(::google::protobuf::uint64 value);

  // uint64 ins_utm_timestamp = 5;
  void clear_ins_utm_timestamp();
  static const int kInsUtmTimestampFieldNumber = 5;
  ::google::protobuf::uint64 ins_utm_timestamp() const;
  void set_ins_utm_timestamp(::google::protobuf::uint64 value);

  // .odom.proto.OdomId odom_id = 1;
  void clear_odom_id();
  static const int kOdomIdFieldNumber = 1;
  ::odom::proto::OdomId odom_id() const;
  void set_odom_id(::odom::proto::OdomId value);

  // @@protoc_insertion_point(class_scope:odom.proto.Frame.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::uint64 sys_timestamp_;
  ::google::protobuf::uint64 rolling_counter_;
  ::google::protobuf::uint64 ins_utm_timestamp_;
  int odom_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Frame_Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Frame.Info) */ {
 public:
  Frame_Info();
  virtual ~Frame_Info();

  Frame_Info(const Frame_Info& from);

  inline Frame_Info& operator=(const Frame_Info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Frame_Info(Frame_Info&& from) noexcept
    : Frame_Info() {
    *this = ::std::move(from);
  }

  inline Frame_Info& operator=(Frame_Info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame_Info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame_Info* internal_default_instance() {
    return reinterpret_cast<const Frame_Info*>(
               &_Frame_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Frame_Info* other);
  friend void swap(Frame_Info& a, Frame_Info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Frame_Info* New() const final {
    return CreateMaybeMessage<Frame_Info>(NULL);
  }

  Frame_Info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Frame_Info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Frame_Info& from);
  void MergeFrom(const Frame_Info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame_Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  double confidence() const;
  void set_confidence(double value);

  // bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:odom.proto.Frame.Info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double confidence_;
  bool status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:odom.proto.Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Frame* other);
  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(NULL);
  }

  Frame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Frame_Header Header;
  typedef Frame_Info Info;

  // accessors -------------------------------------------------------

  // .odom.proto.Frame.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::odom::proto::Frame_Header& _internal_header() const;
  public:
  const ::odom::proto::Frame_Header& header() const;
  ::odom::proto::Frame_Header* release_header();
  ::odom::proto::Frame_Header* mutable_header();
  void set_allocated_header(::odom::proto::Frame_Header* header);

  // .odom.proto.Frame.Info info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  private:
  const ::odom::proto::Frame_Info& _internal_info() const;
  public:
  const ::odom::proto::Frame_Info& info() const;
  ::odom::proto::Frame_Info* release_info();
  ::odom::proto::Frame_Info* mutable_info();
  void set_allocated_info(::odom::proto::Frame_Info* info);

  // .odom.proto.Odom odom = 3;
  bool has_odom() const;
  void clear_odom();
  static const int kOdomFieldNumber = 3;
  private:
  const ::odom::proto::Odom& _internal_odom() const;
  public:
  const ::odom::proto::Odom& odom() const;
  ::odom::proto::Odom* release_odom();
  ::odom::proto::Odom* mutable_odom();
  void set_allocated_odom(::odom::proto::Odom* odom);

  // @@protoc_insertion_point(class_scope:odom.proto.Frame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::odom::proto::Frame_Header* header_;
  ::odom::proto::Frame_Info* info_;
  ::odom::proto::Odom* odom_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_odom_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Odom_Position

// double x = 1;
inline void Odom_Position::clear_x() {
  x_ = 0;
}
inline double Odom_Position::x() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.Position.x)
  return x_;
}
inline void Odom_Position::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.Position.x)
}

// double y = 2;
inline void Odom_Position::clear_y() {
  y_ = 0;
}
inline double Odom_Position::y() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.Position.y)
  return y_;
}
inline void Odom_Position::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.Position.y)
}

// double z = 3;
inline void Odom_Position::clear_z() {
  z_ = 0;
}
inline double Odom_Position::z() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.Position.z)
  return z_;
}
inline void Odom_Position::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.Position.z)
}

// -------------------------------------------------------------------

// Odom_PositionStd

// double x_std = 1;
inline void Odom_PositionStd::clear_x_std() {
  x_std_ = 0;
}
inline double Odom_PositionStd::x_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PositionStd.x_std)
  return x_std_;
}
inline void Odom_PositionStd::set_x_std(double value) {
  
  x_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PositionStd.x_std)
}

// double y_std = 2;
inline void Odom_PositionStd::clear_y_std() {
  y_std_ = 0;
}
inline double Odom_PositionStd::y_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PositionStd.y_std)
  return y_std_;
}
inline void Odom_PositionStd::set_y_std(double value) {
  
  y_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PositionStd.y_std)
}

// double z_std = 3;
inline void Odom_PositionStd::clear_z_std() {
  z_std_ = 0;
}
inline double Odom_PositionStd::z_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PositionStd.z_std)
  return z_std_;
}
inline void Odom_PositionStd::set_z_std(double value) {
  
  z_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PositionStd.z_std)
}

// -------------------------------------------------------------------

// Odom_PoseQuaternion

// double w = 1;
inline void Odom_PoseQuaternion::clear_w() {
  w_ = 0;
}
inline double Odom_PoseQuaternion::w() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseQuaternion.w)
  return w_;
}
inline void Odom_PoseQuaternion::set_w(double value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseQuaternion.w)
}

// double x = 2;
inline void Odom_PoseQuaternion::clear_x() {
  x_ = 0;
}
inline double Odom_PoseQuaternion::x() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseQuaternion.x)
  return x_;
}
inline void Odom_PoseQuaternion::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseQuaternion.x)
}

// double y = 3;
inline void Odom_PoseQuaternion::clear_y() {
  y_ = 0;
}
inline double Odom_PoseQuaternion::y() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseQuaternion.y)
  return y_;
}
inline void Odom_PoseQuaternion::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseQuaternion.y)
}

// double z = 4;
inline void Odom_PoseQuaternion::clear_z() {
  z_ = 0;
}
inline double Odom_PoseQuaternion::z() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseQuaternion.z)
  return z_;
}
inline void Odom_PoseQuaternion::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseQuaternion.z)
}

// -------------------------------------------------------------------

// Odom_PoseStd

// double roll_std = 1;
inline void Odom_PoseStd::clear_roll_std() {
  roll_std_ = 0;
}
inline double Odom_PoseStd::roll_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseStd.roll_std)
  return roll_std_;
}
inline void Odom_PoseStd::set_roll_std(double value) {
  
  roll_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseStd.roll_std)
}

// double pitch_std = 2;
inline void Odom_PoseStd::clear_pitch_std() {
  pitch_std_ = 0;
}
inline double Odom_PoseStd::pitch_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseStd.pitch_std)
  return pitch_std_;
}
inline void Odom_PoseStd::set_pitch_std(double value) {
  
  pitch_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseStd.pitch_std)
}

// double yaw_std = 3;
inline void Odom_PoseStd::clear_yaw_std() {
  yaw_std_ = 0;
}
inline double Odom_PoseStd::yaw_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.PoseStd.yaw_std)
  return yaw_std_;
}
inline void Odom_PoseStd::set_yaw_std(double value) {
  
  yaw_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.PoseStd.yaw_std)
}

// -------------------------------------------------------------------

// Odom_AngleSpeed

// double roll = 1;
inline void Odom_AngleSpeed::clear_roll() {
  roll_ = 0;
}
inline double Odom_AngleSpeed::roll() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeed.roll)
  return roll_;
}
inline void Odom_AngleSpeed::set_roll(double value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeed.roll)
}

// double pitch = 2;
inline void Odom_AngleSpeed::clear_pitch() {
  pitch_ = 0;
}
inline double Odom_AngleSpeed::pitch() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeed.pitch)
  return pitch_;
}
inline void Odom_AngleSpeed::set_pitch(double value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeed.pitch)
}

// double yaw = 3;
inline void Odom_AngleSpeed::clear_yaw() {
  yaw_ = 0;
}
inline double Odom_AngleSpeed::yaw() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeed.yaw)
  return yaw_;
}
inline void Odom_AngleSpeed::set_yaw(double value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeed.yaw)
}

// -------------------------------------------------------------------

// Odom_AngleSpeedStd

// double roll_std = 1;
inline void Odom_AngleSpeedStd::clear_roll_std() {
  roll_std_ = 0;
}
inline double Odom_AngleSpeedStd::roll_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeedStd.roll_std)
  return roll_std_;
}
inline void Odom_AngleSpeedStd::set_roll_std(double value) {
  
  roll_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeedStd.roll_std)
}

// double pitch_std = 2;
inline void Odom_AngleSpeedStd::clear_pitch_std() {
  pitch_std_ = 0;
}
inline double Odom_AngleSpeedStd::pitch_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeedStd.pitch_std)
  return pitch_std_;
}
inline void Odom_AngleSpeedStd::set_pitch_std(double value) {
  
  pitch_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeedStd.pitch_std)
}

// double yaw_std = 3;
inline void Odom_AngleSpeedStd::clear_yaw_std() {
  yaw_std_ = 0;
}
inline double Odom_AngleSpeedStd::yaw_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.AngleSpeedStd.yaw_std)
  return yaw_std_;
}
inline void Odom_AngleSpeedStd::set_yaw_std(double value) {
  
  yaw_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.AngleSpeedStd.yaw_std)
}

// -------------------------------------------------------------------

// Odom_LinearSpeed

// double x = 1;
inline void Odom_LinearSpeed::clear_x() {
  x_ = 0;
}
inline double Odom_LinearSpeed::x() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeed.x)
  return x_;
}
inline void Odom_LinearSpeed::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeed.x)
}

// double y = 2;
inline void Odom_LinearSpeed::clear_y() {
  y_ = 0;
}
inline double Odom_LinearSpeed::y() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeed.y)
  return y_;
}
inline void Odom_LinearSpeed::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeed.y)
}

// double z = 3;
inline void Odom_LinearSpeed::clear_z() {
  z_ = 0;
}
inline double Odom_LinearSpeed::z() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeed.z)
  return z_;
}
inline void Odom_LinearSpeed::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeed.z)
}

// double vehicle_speed = 4;
inline void Odom_LinearSpeed::clear_vehicle_speed() {
  vehicle_speed_ = 0;
}
inline double Odom_LinearSpeed::vehicle_speed() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeed.vehicle_speed)
  return vehicle_speed_;
}
inline void Odom_LinearSpeed::set_vehicle_speed(double value) {
  
  vehicle_speed_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeed.vehicle_speed)
}

// -------------------------------------------------------------------

// Odom_LinearSpeedStd

// double x_std = 1;
inline void Odom_LinearSpeedStd::clear_x_std() {
  x_std_ = 0;
}
inline double Odom_LinearSpeedStd::x_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeedStd.x_std)
  return x_std_;
}
inline void Odom_LinearSpeedStd::set_x_std(double value) {
  
  x_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeedStd.x_std)
}

// double y_std = 2;
inline void Odom_LinearSpeedStd::clear_y_std() {
  y_std_ = 0;
}
inline double Odom_LinearSpeedStd::y_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeedStd.y_std)
  return y_std_;
}
inline void Odom_LinearSpeedStd::set_y_std(double value) {
  
  y_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeedStd.y_std)
}

// double z_std = 3;
inline void Odom_LinearSpeedStd::clear_z_std() {
  z_std_ = 0;
}
inline double Odom_LinearSpeedStd::z_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeedStd.z_std)
  return z_std_;
}
inline void Odom_LinearSpeedStd::set_z_std(double value) {
  
  z_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeedStd.z_std)
}

// double vehicle_speed_std = 4;
inline void Odom_LinearSpeedStd::clear_vehicle_speed_std() {
  vehicle_speed_std_ = 0;
}
inline double Odom_LinearSpeedStd::vehicle_speed_std() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.LinearSpeedStd.vehicle_speed_std)
  return vehicle_speed_std_;
}
inline void Odom_LinearSpeedStd::set_vehicle_speed_std(double value) {
  
  vehicle_speed_std_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.LinearSpeedStd.vehicle_speed_std)
}

// -------------------------------------------------------------------

// Odom_TransformMatrix

// int32 rows = 1;
inline void Odom_TransformMatrix::clear_rows() {
  rows_ = 0;
}
inline ::google::protobuf::int32 Odom_TransformMatrix::rows() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.TransformMatrix.rows)
  return rows_;
}
inline void Odom_TransformMatrix::set_rows(::google::protobuf::int32 value) {
  
  rows_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.TransformMatrix.rows)
}

// int32 columns = 2;
inline void Odom_TransformMatrix::clear_columns() {
  columns_ = 0;
}
inline ::google::protobuf::int32 Odom_TransformMatrix::columns() const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.TransformMatrix.columns)
  return columns_;
}
inline void Odom_TransformMatrix::set_columns(::google::protobuf::int32 value) {
  
  columns_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Odom.TransformMatrix.columns)
}

// repeated double data = 3;
inline int Odom_TransformMatrix::data_size() const {
  return data_.size();
}
inline void Odom_TransformMatrix::clear_data() {
  data_.Clear();
}
inline double Odom_TransformMatrix::data(int index) const {
  // @@protoc_insertion_point(field_get:odom.proto.Odom.TransformMatrix.data)
  return data_.Get(index);
}
inline void Odom_TransformMatrix::set_data(int index, double value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:odom.proto.Odom.TransformMatrix.data)
}
inline void Odom_TransformMatrix::add_data(double value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:odom.proto.Odom.TransformMatrix.data)
}
inline const ::google::protobuf::RepeatedField< double >&
Odom_TransformMatrix::data() const {
  // @@protoc_insertion_point(field_list:odom.proto.Odom.TransformMatrix.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
Odom_TransformMatrix::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:odom.proto.Odom.TransformMatrix.data)
  return &data_;
}

// -------------------------------------------------------------------

// Odom

// .odom.proto.Odom.Position position = 1;
inline bool Odom::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Odom::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::odom::proto::Odom_Position& Odom::_internal_position() const {
  return *position_;
}
inline const ::odom::proto::Odom_Position& Odom::position() const {
  const ::odom::proto::Odom_Position* p = position_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.position)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_Position*>(
      &::odom::proto::_Odom_Position_default_instance_);
}
inline ::odom::proto::Odom_Position* Odom::release_position() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.position)
  
  ::odom::proto::Odom_Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_Position* Odom::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.position)
  return position_;
}
inline void Odom::set_allocated_position(::odom::proto::Odom_Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.position)
}

// .odom.proto.Odom.PositionStd position_std = 2;
inline bool Odom::has_position_std() const {
  return this != internal_default_instance() && position_std_ != NULL;
}
inline void Odom::clear_position_std() {
  if (GetArenaNoVirtual() == NULL && position_std_ != NULL) {
    delete position_std_;
  }
  position_std_ = NULL;
}
inline const ::odom::proto::Odom_PositionStd& Odom::_internal_position_std() const {
  return *position_std_;
}
inline const ::odom::proto::Odom_PositionStd& Odom::position_std() const {
  const ::odom::proto::Odom_PositionStd* p = position_std_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.position_std)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_PositionStd*>(
      &::odom::proto::_Odom_PositionStd_default_instance_);
}
inline ::odom::proto::Odom_PositionStd* Odom::release_position_std() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.position_std)
  
  ::odom::proto::Odom_PositionStd* temp = position_std_;
  position_std_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_PositionStd* Odom::mutable_position_std() {
  
  if (position_std_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_PositionStd>(GetArenaNoVirtual());
    position_std_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.position_std)
  return position_std_;
}
inline void Odom::set_allocated_position_std(::odom::proto::Odom_PositionStd* position_std) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_std_;
  }
  if (position_std) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_std = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_std, submessage_arena);
    }
    
  } else {
    
  }
  position_std_ = position_std;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.position_std)
}

// .odom.proto.Odom.PoseQuaternion pose_quaternion = 3;
inline bool Odom::has_pose_quaternion() const {
  return this != internal_default_instance() && pose_quaternion_ != NULL;
}
inline void Odom::clear_pose_quaternion() {
  if (GetArenaNoVirtual() == NULL && pose_quaternion_ != NULL) {
    delete pose_quaternion_;
  }
  pose_quaternion_ = NULL;
}
inline const ::odom::proto::Odom_PoseQuaternion& Odom::_internal_pose_quaternion() const {
  return *pose_quaternion_;
}
inline const ::odom::proto::Odom_PoseQuaternion& Odom::pose_quaternion() const {
  const ::odom::proto::Odom_PoseQuaternion* p = pose_quaternion_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.pose_quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_PoseQuaternion*>(
      &::odom::proto::_Odom_PoseQuaternion_default_instance_);
}
inline ::odom::proto::Odom_PoseQuaternion* Odom::release_pose_quaternion() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.pose_quaternion)
  
  ::odom::proto::Odom_PoseQuaternion* temp = pose_quaternion_;
  pose_quaternion_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_PoseQuaternion* Odom::mutable_pose_quaternion() {
  
  if (pose_quaternion_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_PoseQuaternion>(GetArenaNoVirtual());
    pose_quaternion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.pose_quaternion)
  return pose_quaternion_;
}
inline void Odom::set_allocated_pose_quaternion(::odom::proto::Odom_PoseQuaternion* pose_quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_quaternion_;
  }
  if (pose_quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose_quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose_quaternion, submessage_arena);
    }
    
  } else {
    
  }
  pose_quaternion_ = pose_quaternion;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.pose_quaternion)
}

// .odom.proto.Odom.PoseStd pose_std = 4;
inline bool Odom::has_pose_std() const {
  return this != internal_default_instance() && pose_std_ != NULL;
}
inline void Odom::clear_pose_std() {
  if (GetArenaNoVirtual() == NULL && pose_std_ != NULL) {
    delete pose_std_;
  }
  pose_std_ = NULL;
}
inline const ::odom::proto::Odom_PoseStd& Odom::_internal_pose_std() const {
  return *pose_std_;
}
inline const ::odom::proto::Odom_PoseStd& Odom::pose_std() const {
  const ::odom::proto::Odom_PoseStd* p = pose_std_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.pose_std)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_PoseStd*>(
      &::odom::proto::_Odom_PoseStd_default_instance_);
}
inline ::odom::proto::Odom_PoseStd* Odom::release_pose_std() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.pose_std)
  
  ::odom::proto::Odom_PoseStd* temp = pose_std_;
  pose_std_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_PoseStd* Odom::mutable_pose_std() {
  
  if (pose_std_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_PoseStd>(GetArenaNoVirtual());
    pose_std_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.pose_std)
  return pose_std_;
}
inline void Odom::set_allocated_pose_std(::odom::proto::Odom_PoseStd* pose_std) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_std_;
  }
  if (pose_std) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose_std = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose_std, submessage_arena);
    }
    
  } else {
    
  }
  pose_std_ = pose_std;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.pose_std)
}

// .odom.proto.Odom.AngleSpeed angle_speed = 5;
inline bool Odom::has_angle_speed() const {
  return this != internal_default_instance() && angle_speed_ != NULL;
}
inline void Odom::clear_angle_speed() {
  if (GetArenaNoVirtual() == NULL && angle_speed_ != NULL) {
    delete angle_speed_;
  }
  angle_speed_ = NULL;
}
inline const ::odom::proto::Odom_AngleSpeed& Odom::_internal_angle_speed() const {
  return *angle_speed_;
}
inline const ::odom::proto::Odom_AngleSpeed& Odom::angle_speed() const {
  const ::odom::proto::Odom_AngleSpeed* p = angle_speed_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.angle_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_AngleSpeed*>(
      &::odom::proto::_Odom_AngleSpeed_default_instance_);
}
inline ::odom::proto::Odom_AngleSpeed* Odom::release_angle_speed() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.angle_speed)
  
  ::odom::proto::Odom_AngleSpeed* temp = angle_speed_;
  angle_speed_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_AngleSpeed* Odom::mutable_angle_speed() {
  
  if (angle_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_AngleSpeed>(GetArenaNoVirtual());
    angle_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.angle_speed)
  return angle_speed_;
}
inline void Odom::set_allocated_angle_speed(::odom::proto::Odom_AngleSpeed* angle_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angle_speed_;
  }
  if (angle_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angle_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angle_speed, submessage_arena);
    }
    
  } else {
    
  }
  angle_speed_ = angle_speed;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.angle_speed)
}

// .odom.proto.Odom.AngleSpeedStd angle_speed_std = 6;
inline bool Odom::has_angle_speed_std() const {
  return this != internal_default_instance() && angle_speed_std_ != NULL;
}
inline void Odom::clear_angle_speed_std() {
  if (GetArenaNoVirtual() == NULL && angle_speed_std_ != NULL) {
    delete angle_speed_std_;
  }
  angle_speed_std_ = NULL;
}
inline const ::odom::proto::Odom_AngleSpeedStd& Odom::_internal_angle_speed_std() const {
  return *angle_speed_std_;
}
inline const ::odom::proto::Odom_AngleSpeedStd& Odom::angle_speed_std() const {
  const ::odom::proto::Odom_AngleSpeedStd* p = angle_speed_std_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.angle_speed_std)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_AngleSpeedStd*>(
      &::odom::proto::_Odom_AngleSpeedStd_default_instance_);
}
inline ::odom::proto::Odom_AngleSpeedStd* Odom::release_angle_speed_std() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.angle_speed_std)
  
  ::odom::proto::Odom_AngleSpeedStd* temp = angle_speed_std_;
  angle_speed_std_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_AngleSpeedStd* Odom::mutable_angle_speed_std() {
  
  if (angle_speed_std_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_AngleSpeedStd>(GetArenaNoVirtual());
    angle_speed_std_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.angle_speed_std)
  return angle_speed_std_;
}
inline void Odom::set_allocated_angle_speed_std(::odom::proto::Odom_AngleSpeedStd* angle_speed_std) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angle_speed_std_;
  }
  if (angle_speed_std) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angle_speed_std = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angle_speed_std, submessage_arena);
    }
    
  } else {
    
  }
  angle_speed_std_ = angle_speed_std;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.angle_speed_std)
}

// .odom.proto.Odom.LinearSpeed linear_speed = 7;
inline bool Odom::has_linear_speed() const {
  return this != internal_default_instance() && linear_speed_ != NULL;
}
inline void Odom::clear_linear_speed() {
  if (GetArenaNoVirtual() == NULL && linear_speed_ != NULL) {
    delete linear_speed_;
  }
  linear_speed_ = NULL;
}
inline const ::odom::proto::Odom_LinearSpeed& Odom::_internal_linear_speed() const {
  return *linear_speed_;
}
inline const ::odom::proto::Odom_LinearSpeed& Odom::linear_speed() const {
  const ::odom::proto::Odom_LinearSpeed* p = linear_speed_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.linear_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_LinearSpeed*>(
      &::odom::proto::_Odom_LinearSpeed_default_instance_);
}
inline ::odom::proto::Odom_LinearSpeed* Odom::release_linear_speed() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.linear_speed)
  
  ::odom::proto::Odom_LinearSpeed* temp = linear_speed_;
  linear_speed_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_LinearSpeed* Odom::mutable_linear_speed() {
  
  if (linear_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_LinearSpeed>(GetArenaNoVirtual());
    linear_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.linear_speed)
  return linear_speed_;
}
inline void Odom::set_allocated_linear_speed(::odom::proto::Odom_LinearSpeed* linear_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_speed_;
  }
  if (linear_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_speed, submessage_arena);
    }
    
  } else {
    
  }
  linear_speed_ = linear_speed;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.linear_speed)
}

// .odom.proto.Odom.LinearSpeedStd linear_speed_std = 8;
inline bool Odom::has_linear_speed_std() const {
  return this != internal_default_instance() && linear_speed_std_ != NULL;
}
inline void Odom::clear_linear_speed_std() {
  if (GetArenaNoVirtual() == NULL && linear_speed_std_ != NULL) {
    delete linear_speed_std_;
  }
  linear_speed_std_ = NULL;
}
inline const ::odom::proto::Odom_LinearSpeedStd& Odom::_internal_linear_speed_std() const {
  return *linear_speed_std_;
}
inline const ::odom::proto::Odom_LinearSpeedStd& Odom::linear_speed_std() const {
  const ::odom::proto::Odom_LinearSpeedStd* p = linear_speed_std_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.linear_speed_std)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_LinearSpeedStd*>(
      &::odom::proto::_Odom_LinearSpeedStd_default_instance_);
}
inline ::odom::proto::Odom_LinearSpeedStd* Odom::release_linear_speed_std() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.linear_speed_std)
  
  ::odom::proto::Odom_LinearSpeedStd* temp = linear_speed_std_;
  linear_speed_std_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_LinearSpeedStd* Odom::mutable_linear_speed_std() {
  
  if (linear_speed_std_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_LinearSpeedStd>(GetArenaNoVirtual());
    linear_speed_std_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.linear_speed_std)
  return linear_speed_std_;
}
inline void Odom::set_allocated_linear_speed_std(::odom::proto::Odom_LinearSpeedStd* linear_speed_std) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_speed_std_;
  }
  if (linear_speed_std) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_speed_std = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_speed_std, submessage_arena);
    }
    
  } else {
    
  }
  linear_speed_std_ = linear_speed_std;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.linear_speed_std)
}

// .odom.proto.Odom.TransformMatrix transform_matrix = 9;
inline bool Odom::has_transform_matrix() const {
  return this != internal_default_instance() && transform_matrix_ != NULL;
}
inline void Odom::clear_transform_matrix() {
  if (GetArenaNoVirtual() == NULL && transform_matrix_ != NULL) {
    delete transform_matrix_;
  }
  transform_matrix_ = NULL;
}
inline const ::odom::proto::Odom_TransformMatrix& Odom::_internal_transform_matrix() const {
  return *transform_matrix_;
}
inline const ::odom::proto::Odom_TransformMatrix& Odom::transform_matrix() const {
  const ::odom::proto::Odom_TransformMatrix* p = transform_matrix_;
  // @@protoc_insertion_point(field_get:odom.proto.Odom.transform_matrix)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom_TransformMatrix*>(
      &::odom::proto::_Odom_TransformMatrix_default_instance_);
}
inline ::odom::proto::Odom_TransformMatrix* Odom::release_transform_matrix() {
  // @@protoc_insertion_point(field_release:odom.proto.Odom.transform_matrix)
  
  ::odom::proto::Odom_TransformMatrix* temp = transform_matrix_;
  transform_matrix_ = NULL;
  return temp;
}
inline ::odom::proto::Odom_TransformMatrix* Odom::mutable_transform_matrix() {
  
  if (transform_matrix_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom_TransformMatrix>(GetArenaNoVirtual());
    transform_matrix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Odom.transform_matrix)
  return transform_matrix_;
}
inline void Odom::set_allocated_transform_matrix(::odom::proto::Odom_TransformMatrix* transform_matrix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_matrix_;
  }
  if (transform_matrix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform_matrix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform_matrix, submessage_arena);
    }
    
  } else {
    
  }
  transform_matrix_ = transform_matrix;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Odom.transform_matrix)
}

// -------------------------------------------------------------------

// Frame_Header

// .odom.proto.OdomId odom_id = 1;
inline void Frame_Header::clear_odom_id() {
  odom_id_ = 0;
}
inline ::odom::proto::OdomId Frame_Header::odom_id() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Header.odom_id)
  return static_cast< ::odom::proto::OdomId >(odom_id_);
}
inline void Frame_Header::set_odom_id(::odom::proto::OdomId value) {
  
  odom_id_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Header.odom_id)
}

// uint64 sys_timestamp = 2;
inline void Frame_Header::clear_sys_timestamp() {
  sys_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Frame_Header::sys_timestamp() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Header.sys_timestamp)
  return sys_timestamp_;
}
inline void Frame_Header::set_sys_timestamp(::google::protobuf::uint64 value) {
  
  sys_timestamp_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Header.sys_timestamp)
}

// uint64 rolling_counter = 3;
inline void Frame_Header::clear_rolling_counter() {
  rolling_counter_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Frame_Header::rolling_counter() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Header.rolling_counter)
  return rolling_counter_;
}
inline void Frame_Header::set_rolling_counter(::google::protobuf::uint64 value) {
  
  rolling_counter_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Header.rolling_counter)
}

// string frame_id = 4;
inline void Frame_Header::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Frame_Header::frame_id() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Header.frame_id)
  return frame_id_.GetNoArena();
}
inline void Frame_Header::set_frame_id(const ::std::string& value) {
  
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Header.frame_id)
}
#if LANG_CXX11
inline void Frame_Header::set_frame_id(::std::string&& value) {
  
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:odom.proto.Frame.Header.frame_id)
}
#endif
inline void Frame_Header::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:odom.proto.Frame.Header.frame_id)
}
inline void Frame_Header::set_frame_id(const char* value, size_t size) {
  
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:odom.proto.Frame.Header.frame_id)
}
inline ::std::string* Frame_Header::mutable_frame_id() {
  
  // @@protoc_insertion_point(field_mutable:odom.proto.Frame.Header.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_Header::release_frame_id() {
  // @@protoc_insertion_point(field_release:odom.proto.Frame.Header.frame_id)
  
  return frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_Header::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    
  } else {
    
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Frame.Header.frame_id)
}

// uint64 ins_utm_timestamp = 5;
inline void Frame_Header::clear_ins_utm_timestamp() {
  ins_utm_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Frame_Header::ins_utm_timestamp() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Header.ins_utm_timestamp)
  return ins_utm_timestamp_;
}
inline void Frame_Header::set_ins_utm_timestamp(::google::protobuf::uint64 value) {
  
  ins_utm_timestamp_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Header.ins_utm_timestamp)
}

// -------------------------------------------------------------------

// Frame_Info

// bool status = 1;
inline void Frame_Info::clear_status() {
  status_ = false;
}
inline bool Frame_Info::status() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Info.status)
  return status_;
}
inline void Frame_Info::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Info.status)
}

// double confidence = 2;
inline void Frame_Info::clear_confidence() {
  confidence_ = 0;
}
inline double Frame_Info::confidence() const {
  // @@protoc_insertion_point(field_get:odom.proto.Frame.Info.confidence)
  return confidence_;
}
inline void Frame_Info::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:odom.proto.Frame.Info.confidence)
}

// -------------------------------------------------------------------

// Frame

// .odom.proto.Frame.Header header = 1;
inline bool Frame::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Frame::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::odom::proto::Frame_Header& Frame::_internal_header() const {
  return *header_;
}
inline const ::odom::proto::Frame_Header& Frame::header() const {
  const ::odom::proto::Frame_Header* p = header_;
  // @@protoc_insertion_point(field_get:odom.proto.Frame.header)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Frame_Header*>(
      &::odom::proto::_Frame_Header_default_instance_);
}
inline ::odom::proto::Frame_Header* Frame::release_header() {
  // @@protoc_insertion_point(field_release:odom.proto.Frame.header)
  
  ::odom::proto::Frame_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::odom::proto::Frame_Header* Frame::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Frame_Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Frame.header)
  return header_;
}
inline void Frame::set_allocated_header(::odom::proto::Frame_Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Frame.header)
}

// .odom.proto.Frame.Info info = 2;
inline bool Frame::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void Frame::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::odom::proto::Frame_Info& Frame::_internal_info() const {
  return *info_;
}
inline const ::odom::proto::Frame_Info& Frame::info() const {
  const ::odom::proto::Frame_Info* p = info_;
  // @@protoc_insertion_point(field_get:odom.proto.Frame.info)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Frame_Info*>(
      &::odom::proto::_Frame_Info_default_instance_);
}
inline ::odom::proto::Frame_Info* Frame::release_info() {
  // @@protoc_insertion_point(field_release:odom.proto.Frame.info)
  
  ::odom::proto::Frame_Info* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::odom::proto::Frame_Info* Frame::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Frame_Info>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Frame.info)
  return info_;
}
inline void Frame::set_allocated_info(::odom::proto::Frame_Info* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Frame.info)
}

// .odom.proto.Odom odom = 3;
inline bool Frame::has_odom() const {
  return this != internal_default_instance() && odom_ != NULL;
}
inline void Frame::clear_odom() {
  if (GetArenaNoVirtual() == NULL && odom_ != NULL) {
    delete odom_;
  }
  odom_ = NULL;
}
inline const ::odom::proto::Odom& Frame::_internal_odom() const {
  return *odom_;
}
inline const ::odom::proto::Odom& Frame::odom() const {
  const ::odom::proto::Odom* p = odom_;
  // @@protoc_insertion_point(field_get:odom.proto.Frame.odom)
  return p != NULL ? *p : *reinterpret_cast<const ::odom::proto::Odom*>(
      &::odom::proto::_Odom_default_instance_);
}
inline ::odom::proto::Odom* Frame::release_odom() {
  // @@protoc_insertion_point(field_release:odom.proto.Frame.odom)
  
  ::odom::proto::Odom* temp = odom_;
  odom_ = NULL;
  return temp;
}
inline ::odom::proto::Odom* Frame::mutable_odom() {
  
  if (odom_ == NULL) {
    auto* p = CreateMaybeMessage<::odom::proto::Odom>(GetArenaNoVirtual());
    odom_ = p;
  }
  // @@protoc_insertion_point(field_mutable:odom.proto.Frame.odom)
  return odom_;
}
inline void Frame::set_allocated_odom(::odom::proto::Odom* odom) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete odom_;
  }
  if (odom) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odom = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odom, submessage_arena);
    }
    
  } else {
    
  }
  odom_ = odom;
  // @@protoc_insertion_point(field_set_allocated:odom.proto.Frame.odom)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace odom

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::odom::proto::OdomId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::odom::proto::OdomId>() {
  return ::odom::proto::OdomId_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_odom_2eproto
